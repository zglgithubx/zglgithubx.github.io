<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang项目部署</title>
    <url>/posts/36933.html</url>
    <content><![CDATA[<p>此博客提供了三种方案，可以根据项目需求适当选择</p>
<span id="more"></span>
<h3 id="前言">前言</h3>
<p>Golang项目部署流程：编译——&gt;上传到服务器——&gt;运行。<br>
简单的实现方案有：本地编译上传部署，构建docker镜像部署，自动化docker镜像部署</p>
<h3 id="1、本地编译上传部署">1、本地编译上传部署</h3>
<blockquote>
<p>注：在本地（window环镜）编译，需修改Go语言的环境配置<br>
命令：go env -w GOOS=linux</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>在项目根目录执行,生成二进制文件server</span><br><span class="line">go build -o server .</span><br><span class="line"><span class="regexp">//</span>上传到服务器，<span class="number">22</span>为服务端口，/xxx为服务器目录</span><br><span class="line">scp -P <span class="number">22</span> server root@ip:/xxx</span><br><span class="line"><span class="regexp">//</span>在服务器切换到文件目录</span><br><span class="line">cd /xxx</span><br><span class="line"><span class="regexp">//</span>运行二进制文件</span><br><span class="line">nohup ./server &gt;start.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>查看日志</span><br><span class="line">tail -f <span class="number">200</span> start.log</span><br></pre></td></tr></table></figure>
<h3 id="2、构建docker镜像部署">2、构建docker镜像部署</h3>
<ul>
<li>在项目根目录创建Dockerfile文件</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一阶段构建编译环境</span></span><br><span class="line"><span class="keyword">FROM</span> golang:alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /project/go</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go <span class="built_in">env</span> -w GO111MODULE=on \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go generate &amp;&amp; go <span class="built_in">env</span> &amp;&amp; go build -o server .</span></span><br><span class="line"><span class="comment"># 第二阶段构建运行环境，alpine为linux轻量级发行版</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /project/go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /project/go ./</span></span><br><span class="line">//暴露的端口号</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8888</span></span><br><span class="line">//容器运行时执行，直接运行二进制文件，防止容器挂掉</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./server</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3huLS1zaGVsbGdvLWlnNWtxN3VweDhhaGNwbHVlc3I2aC5zaA==">创建shell脚本文件go.sh<i class="fa fa-external-link-alt"></i></span>（简化部署步骤）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 镜像名字</span></span><br><span class="line">IMAGE_NAME=centos7_go_database</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker容器名字</span></span><br><span class="line">CONTAINER_NAME=go</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译好的二进制文件</span></span><br><span class="line">SERVER_NAME=server</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数X</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [start]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">#构建镜像和并启动容器(在宿主机执行)</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#容器id</span></span><br><span class="line">  CID=$(docker ps -a | grep <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#镜像id</span></span><br><span class="line">  IID=$(docker images | grep <span class="string">&quot;<span class="variable">$IMAGE_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建docker镜像</span></span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$IMAGE_NAME</span> image，IID=<span class="variable">$IID</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;NOT exit <span class="variable">$IMAGE_NAME</span> image，start build image...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据项目个路径下的Dockerfile文件，构建镜像</span></span><br><span class="line"></span><br><span class="line">    docker build -t <span class="variable">$IMAGE_NAME</span> .</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$IMAGE_NAME</span> image has been builded&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$CONTAINER_NAME</span> container，CID=<span class="variable">$CID</span>.   ---Remove container&quot;</span></span><br><span class="line"></span><br><span class="line">      docker stop <span class="variable">$CONTAINER_NAME</span>   <span class="comment"># 停止运行中的容器</span></span><br><span class="line"></span><br><span class="line">      docker <span class="built_in">rm</span> <span class="variable">$CONTAINER_NAME</span>     <span class="comment">##删除原来的容器</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建容器</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span> container,start build...&quot;</span></span><br><span class="line">  <span class="comment"># 运行容器</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># --name 容器的名字</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#   -d   容器后台运行</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#   -p   指定容器映射的端口和主机对应的端口</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#   -v   将主机的目录挂载到容器的目录中（不可少）</span></span><br><span class="line"></span><br><span class="line">  docker run -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -p 8888:8888 -<span class="built_in">id</span> --name <span class="variable">$CONTAINER_NAME</span> -v <span class="variable">$PWD</span>:/project/<span class="variable">$CONTAINER_NAME</span> <span class="variable">$IMAGE_NAME</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span> container build end&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<ul>
<li>开始部署</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh</span> <span class="keyword">go</span>.<span class="keyword">sh</span> start</span><br></pre></td></tr></table></figure>
<h3 id="3、自动化docker镜像部署">3、自动化docker镜像部署</h3>
<p>此自动化方案是基于阿里云效代码平台的流水线功能实现的，实现的效果：当有master分支有完成合并请求时执行（和其他的方案大同小异，思想可以借鉴）</p>
<ul>
<li>创建流水线选择模板</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202207161736015.png" alt=""></p>
<ul>
<li>测试步骤可以根据需要进行删改</li>
<li>点击流水线源，编辑流水线源
<ul>
<li>开启代码出发——&gt;合并请求完成后</li>
<li>设置工作目录：api</li>
</ul>
</li>
<li>编辑构建步骤
<ul>
<li>选择构建集群（可以查看官方教程）</li>
<li>选择下载部分流水线源</li>
<li>流水线源选择仓库代码</li>
<li>构建命令：</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换到流水线的工作目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/workspace/api</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译项目文件，此步骤是在平台进行项目编译，可以选择不编译，因为在Dockerfile中已经有编译的步骤</span></span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct \&amp;&amp; go <span class="built_in">env</span> -w GO111MODULE=on \&amp;&amp; go <span class="built_in">env</span> -w CGO_ENABLED=0 \&amp;&amp; go generate &amp;&amp; go <span class="built_in">env</span> &amp;&amp; go build -o server .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>* 构建物上传，打包路径为./ 此打包路径指打包项目根目录下所有文件
</code></pre>
<ul>
<li>编辑部署步骤
<ul>
<li>下载路径：下载到服务器的文件目录，需要提前创建</li>
<li>执行用户：root</li>
<li>部署脚本：</li>
</ul>
</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压项目二进制压缩包（构建物上传时直接将压缩包上传到了下载路径）</span></span><br><span class="line">tar zxvf 下载路径 -C 解压目录</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到项目目录</span></span><br><span class="line">cd 解压目录</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本文件</span></span><br><span class="line"><span class="keyword">sh </span>go.<span class="keyword">sh </span>start</span><br></pre></td></tr></table></figure>
<p>自此完成部署</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/35921.html</url>
    <content><![CDATA[<h3 id="由来">由来</h3>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<span id="more"></span>
<h3 id="KMP算法是什么">KMP算法是什么</h3>
<p>KMP算法主要应用于字符串的快速匹配。</p>
<p>比如在给定字符串中，让你找一个目标子串，常规的解法就是暴力匹配，用双层for循环分别遍历两个字符串，但是它的时间复杂度是O(m*n)。而KMP算法可以让这个匹配过程降到时间复杂度为O(m+n)。</p>
<h3 id="KMP算法为什么那么快">KMP算法为什么那么快</h3>
<h4 id="举个-chestnut">举个:chestnut:</h4>
<p>在文本串（aabaabaaf）中，找到第一次匹配到模式串（aabaaf）的索引。</p>
<p>KMP算法匹配的过程：</p>
<p>①和常规解法一样，从文本串首字符和模式串的首字符开始，一 一进行比较</p>
<p>②当遇到不匹配的时候，如下图</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171018117.png" alt="image-20211017101822955"></p>
<p>模式串会从b的位置开始匹配，文本串匹配的位置不变</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171106451.png" alt="image-20211017110657407"></p>
<p>到这里，肯定会有疑问：会什么从b开始？</p>
<p>下面的概念都是模式串的。</p>
<p>这里会提到几个概念：前缀、后缀和 最大公共字符长度表（前缀表）</p>
<ul>
<li>
<p>前缀：除了末尾字符之外的所有字符</p>
</li>
<li>
<p>后缀：除了首字符之外的所有字符</p>
</li>
<li>
<p>最大公共字符长度表：每个子串中最长相同的前后缀字符长度</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>模式串的各个子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最大公共字符长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>空</td>
<td>空</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a,aa</td>
<td>b,ba</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a,aa,aab</td>
<td>a,ba,aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a,aa,aab,aaba</td>
<td>a,aa,baa,abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a,aa,aab,aabaa</td>
<td>f,af,aaf,baaf,abaaf</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>为什么有最大公共字符长度表？</p>
<p>这个表，可以在你匹配失败时，跳跃式的匹配，避免重复已经匹配相同的字符。</p>
<p>③直到将文本串匹配完</p>
<h4 id="举个完整的-chestnut">举个完整的:chestnut:</h4>
<p>文本串：BBC ABCDAB ABCDABCDABDE</p>
<p>模式串：ABCDABD</p>
<p>前缀表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大前缀后缀公共元素长度</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>这个例子咱们就根据这个前缀表去跳跃式的匹配（表中的数值代表跳跃到模式串索引）</p>
<p>①开始匹配</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171151156.png" alt="img"></p>
<p>② 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171151451.png" alt="img"></p>
<p>③继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《前缀表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171152957.png" alt="img"></p>
<p>④模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171153610.png" alt="img"></p>
<p>⑤A与空格不匹配，向右移动1位</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171154064.png" alt="img"></p>
<p>⑥继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171154305.png" alt="img"></p>
<p>⑦经历第5步后，发现匹配成功，过程结束。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171155335.png" alt="img"></p>
<p>至此这就是KMP算法的大致原理。</p>
<h3 id="KMP算法代码实现">KMP算法代码实现</h3>
<p>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大前缀后缀公共元素长度</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>而且，根据这个表可以得出下述结论</p>
<p>当失配时，模式串向右移动的位数为：已匹配字符数-失配字符的上一位字符所对应的最大长度值</p>
<p>文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p>
<p>给定字符串“ABCDABD”，可求得它的next 数组如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="Next数组求法">Next数组求法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>KMP算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> strlen(s);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> strlen(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC原理</title>
    <url>/posts/12447.html</url>
    <content><![CDATA[<h3 id="RPC通信的演化">RPC通信的演化</h3>
<ul>
<li>从单机到分布式-&gt;分布式通信-&gt;最基本：二进制传输 TCP/IP
<ul>
<li>最古老也是最有效，并且永不过时，TCP/UDP的二进制传输。事实上所有的通信方式归根结底都是TCP/UDP</li>
<li>CORBA Common Ojbect Request Broker Architecture 。古老而复杂，支持面向对象的通信协议</li>
<li>Web Service （SOA SOAP RDDI WSDL 等）<br>
基于HTTP+xml的标准化Web API</li>
<li>RestFul （Representational State Transfer）<br>
回归简单化本源的Web API 的事实标准，HTTP+JSON</li>
<li>RMI Remote Message Service<br>
JavaEE 中的消息框架标准，为很多MQ提供支持</li>
<li>RPC（Remote Procedure Call）<br>
远程方法调用，这只是一个统称，重点在于方法调用（不支持对象的概念），具体实现甚至可以用RMI RestFul 等去实现，但一般不用，因为RMI不能跨语言，而RestFul效率太低。<br>
多用于服务器集群间通信，因此使用更加高效，短小精悍的传输模式以提高效率。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h4 id="1、什么是RPC">1、什么是RPC</h4>
<ul>
<li>RPC的概念与技术早在1981年由Nelson提出。1984年，Birrell和Nelson把其用于支持异构型分布式系统间的通讯。Birrell的RPC模型引入存根进程（stub）作为远程的本地代理，调用RPC运行时库来传输网络中的调用。Stub和RPC runtime屏蔽了网络调用所涉及的许多细节，特别是，参数的编码/译码及网络通讯是由stub和RPC runtime完成的，因此这一模式被各类RPC所采用。——百度百科</li>
<li>对于RPC框架来说，有两个核心部分，一个被称为Stub，还有一个RPCRuntime。
<ul>
<li>这个存根进程主要是在作为服务的提供方和调用方的代理来屏蔽底层的实现细节，包括：调用参数的序列化和网络传输的一些过程。</li>
<li>RPC运行时值承担服务提供方和调用之间的进行网络传输的网络调用。</li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202209201031116.png" alt="image-20220920103141918"></li>
</ul>
</li>
</ul>
<h4 id="2、RPC的使用场景">2、RPC的使用场景</h4>
<ul>
<li>RPC：内部系统、同步调用</li>
<li>MQ：内部系统、异步调用</li>
<li>REST/GraphQL：外部系统调用</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202209201034717.png" alt="image-20220920103451642"></p>
<h4 id="3、RPC的核心流程">3、RPC的核心流程</h4>
<p>本地调用—&gt;User Stub（打包参数：服务的名称、调用的方法、参数列表，以及返回参数等信息）—&gt;RPCRuntime—&gt;Server Stub接收打包好的参数—&gt;调用方法，得到响应的信息—&gt;将信息进行打包（序列化）—&gt;RPC Runtime—&gt;User Stub对信息进行反序列化—&gt;本地</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202209201036278.png" alt="image-20220920103628173"></p>
<p>RPC所做的事情就是对User Stub到Server  Stub的过程，对这个过程进行包装后形成的就是一个RPC框架，对于调用方而言，所感知的就是一个本地调用的过程，而底层的一些网络传输和各种实现细节就被RPC框架所屏蔽了。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置之location</title>
    <url>/posts/35269.html</url>
    <content><![CDATA[<p>nginx学习location的使用</p>
<span id="more"></span>
<h3 id="1、location介绍">1、location介绍</h3>
<p>location是Nginx中的块级指令(block directive),location指令的功能是用来匹配不同的url请求，进而对请求做不同的处理和响应，这其中较难理解的是多个location的匹配顺序。</p>
<p>开始之前先明确一些约定，我们输入的网址叫做请求URI，nginx用请求URI与location中配置的URI做匹配。</p>
<h3 id="2、location-语法">2、location 语法</h3>
<p>location有两种匹配规则：</p>
<ul>
<li>匹配URL类型，有四种参数可选，当然也可以不带参数。 location [ = | ~ | ~* | ^~ ] uri { … }</li>
<li>命名location，用@标识，类似于定于goto语句块。 location @name { … }</li>
</ul>
<p>location匹配参数解释：</p>
<p>（1） “=” ，精确匹配</p>
<ul>
<li>内容要同表达式完全一致才匹配成功</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> =/abc&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.baidu.com/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问 http://117.50.162.61:88/abc-&gt;http://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<p>（2） “~”，执行正则匹配，区分大小写</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /Abc</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问http://117.50.162.61:88/Abc-&gt;</span></span><br><span class="line">http://www.baidu.com/Abc</span><br></pre></td></tr></table></figure>
<p>（3）“~*”，执行正则匹配，忽略大小写</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> ~*/Def&#123;</span><br><span class="line">     <span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问http://117.50.162.61:88/def|Def-&gt;</span></span><br><span class="line">http://www.baidu.com/def|Def</span><br></pre></td></tr></table></figure>
<p>（4）“^~”，表示普通字符串匹配上以后不再进行正则匹配。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /index &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.baidu.com/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问http://117.50.162.61:88/index-&gt;</span></span><br><span class="line">http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>（5）不加任何规则时，默认是大小写敏感，前缀匹配，相当于加了“~”与“^~”</p>
<p>（6）“@”，nginx内部跳转</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /index/ &#123;</span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">404</span> <span class="variable">@index_error</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> <span class="variable">@index_error</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#以 /index/ 开头的请求，如果链接的状态为 404。则会匹配到 @index_error 这条规则上。</span></span><br></pre></td></tr></table></figure>
<h3 id="3、location-URI结尾带不带">3、location URI结尾带不带 /</h3>
<p>(1)结尾不带/</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">proxy_proxy</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问：http://117.50.162.61:88/test-&gt;</span></span><br><span class="line">http://www.baidu.com/<span class="attribute">test</span></span><br><span class="line">即此种情况会把所有的路径加uri中</span><br></pre></td></tr></table></figure>
<p>(1)结尾带/</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">proxy_proxy</span> http://www.baidu.com/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问：http://117.50.162.61:88/test/index-&gt;</span></span><br><span class="line">http://www.baidu.com/<span class="attribute">index</span></span><br><span class="line">即此种情况会把除了匹配路径之外的地址加到uri中</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣_50之x的n次幂</title>
    <url>/posts/4606.html</url>
    <content><![CDATA[<p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。</p>
<p><strong>示例 1：</strong><br>
输入：x = 2.00000, n = 10<br>
输出：1024.00000</p>
<p><strong>示例 2：</strong><br>
输入：x = 2.10000, n = 3<br>
输出：9.26100</p>
<p><strong>示例 3：</strong><br>
输入：x = 2.00000, n = -2<br>
输出：0.25000<br>
解释：2-2 = 1/22 = 1/4 = 0.25</p>
<p>来源：力扣（LeetCode）<br>
链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3d4LW4=">https://leetcode.cn/problems/powx-n<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h3 id="方法1：迭代">方法1：迭代</h3>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">myPow1</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> res=<span class="number">1.00000</span>;</span><br><span class="line">    <span class="comment">//判断0次幂和1的任何次幂；</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||x==res)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断-1的n次幂</span></span><br><span class="line">    <span class="keyword">if</span>(x*<span class="number">-1</span>==res)&#123;</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断最小次幂及0的n次幂</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">-2147483648</span>||x==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res*<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代求n次幂</span></span><br><span class="line">    <span class="type">int</span> len=n&lt;<span class="number">0</span>?n*<span class="number">-1</span>:n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        res=res*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1.0</span>/res:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：2484ms</p>
<h3 id="方法2：快速幂-递归-官方">方法2：快速幂 + 递归(官方)</h3>
<p>「快速幂算法」的本质是分治算法。<br>
举个例子，如果我们要计算 x64，我们可以按照：x→x2→x4→x8→x16→x32→x64的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 x64的值，而不需要对 x 乘 63 次 x。再举一个例子，如果我们要计算 x77，我们可以按照：x→x2→x4→x9→x19→x38→x77的顺序，在 x→x2，x2→x4，x19→x38这些步骤中，我们直接把上一次的结果进行平方，而在 x4→x9，x9→x19，x38→x77这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：</p>
<ul>
<li>当我们要计算 xn时，我们可以先递归地计算出 y=x⌊n/2⌋，其中 ⌊a⌋ 表示对 a 进行下取整；</li>
<li>根据递归计算的结果，如果 n 为偶数，那么 xn=y2；如果 n 为奇数，那么 xn=y2×x；</li>
<li>递归的边界为 n=0，任意数的 0 次方均为 1。<br>
由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> N = n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分治法</span></span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//判断奇偶次幂</span></span><br><span class="line">    <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：&lt;1ms</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣_56之合并区间</title>
    <url>/posts/28381.html</url>
    <content><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<span id="more"></span>
<h3 id="示例">示例</h3>
<p>1、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
<h3 id="解题思路">解题思路</h3>
<p>从题目描述，这个题就是把给定的数组，如有重叠就组合到一起，直到所有的数组都无法重叠，然后输出所有的数组。这个题，常规的做法就是将每个数组先按第一个元素排序，然后将根据数组的第二个元素拿出来和后一个数组进行比较，根据结果来进行是否合并或者保留。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">//先对二维数组中的一维数组进行排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//在判断merged中的数组的第二个元素和当前遍历到的数组的两个元素进行比较，然后再判断如何添加</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202112122059641.png" alt="image-20211212205935591"></p>
<p>我的思路是：</p>
<p>1、创建一个长度为n的数组box，n的值为给定的二维数组的数字的最大值。</p>
<p>2、然后遍历给定的数组，根据每一个一维数组元素，将其设为遍历box的起点和终点，并且把中间值设为1，起点设为1，终点设为2。（也可以设为其他值）</p>
<p>3、遍历所有的一维数组后，此时的box数组，将相当于，把所有覆盖的区间都设定了值。</p>
<p>4、再次遍历一维数组，把box中所有已经设定的值得区间的起点和终点记录下来即可。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge1(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">		<span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    	<span class="comment">//获取数组中的最大值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>[] interval:intervals)&#123;</span><br><span class="line">			max= Math.max(max, interval[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>[] ints=<span class="keyword">new</span> <span class="title class_">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    	<span class="comment">//遍历给定数组，相当于把所有区间数在ints数组进行标记</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>[] interval:intervals)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=interval[<span class="number">0</span>];i&lt;interval[<span class="number">1</span>];i++)&#123;</span><br><span class="line">				ints[i]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ints[interval[<span class="number">1</span>]]=ints[interval[<span class="number">1</span>]]==<span class="number">1</span>?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//用两个栈来存结果的一维数组的左元素和右元素</span></span><br><span class="line">		Stack&lt;Integer&gt; left=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; right=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ints.length;i++)&#123;</span><br><span class="line">            <span class="comment">//判断特殊情况</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;ints[i]==<span class="number">2</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;ints[i]==<span class="number">1</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">1</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">1</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">2</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">2</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">2</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==ints.length-<span class="number">1</span>&amp;&amp;ints[i]==<span class="number">2</span>)&#123;</span><br><span class="line">				right.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> leng=right.size();</span><br><span class="line">		<span class="type">int</span>[][] result=<span class="keyword">new</span> <span class="title class_">int</span>[leng][<span class="number">2</span>];</span><br><span class="line">    	<span class="comment">//处理返回结果，从左栈和右栈分别取出左元素和右元素分别作为一维数组的第一个元素和第二个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line">            <span class="comment">//pop元素可以从栈顶拿除元素，并删除栈中的元素</span></span><br><span class="line">			result[i][<span class="number">0</span>]=left.pop();</span><br><span class="line">			result[i][<span class="number">1</span>]=right.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202112122057242.png" alt="image-20211212205705100"></p>
<p>看这两种思路的时间可能第二种的时间更短（第一种的方法主要浪费在排序上了），但第二种思路不太好想，而且特殊情况需要考虑完全，才能通过，所以大家可以根据实际情况来选择合适的方法解题。</p>
<p>来源：力扣（LeetCode）<br>
链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtaW50ZXJ2YWxz">https://leetcode-cn.com/problems/merge-intervals<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/posts/29203.html</url>
    <content><![CDATA[<h3 id="what">what</h3>
<p>哈夫曼树是一颗最优二叉树，带权路径长度最小的二叉树，经常来用来进行数据压缩。</p>
<h3 id="why">why</h3>
<h4 id="为什么这棵树是最优的？">为什么这棵树是最优的？</h4>
<p>一个棵树是不是最优的，要看它是否满足构建的这棵树的带权路径长度最小。</p>
<span id="more"></span>
<p>在证明哈夫曼树是一颗最优二叉树之前，要先知道这几个概念：</p>
<ul>
<li>路径：从树中一个节点到另一个节点之间的分支构成这两个节点之间的路径。</li>
<li>路径长度：从根节点开始计数到该节点，路径上的分支数目称作路径长度。</li>
<li>权：也称为权值，指的是节点的属性数值。</li>
<li>树的带权路径长度：树中所有叶子节点的带权路径长度之和，一般用WPL表示。</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202109221714863.png" alt="avatar"></p>
<p>如上图中，a的权值为7，路径长度为1；b的权值为5，路径长度为2。</p>
<p>树的带权路径长度WPL=7x1+5x2+2x3+4x3=35</p>
<p>知道了这些，那为什么是最优的，知道构建的哈夫曼树，你就知道为什么了。</p>
<p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p>
<ol>
<li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li>
<li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li>
<li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li>
</ol>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202109221713874.png" alt="img"></p>
<p>在上图中（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。</p>
<p>哈夫曼树在构建的过程中，将最短的路径，巧妙的给了权值最大的，最长的路径给了权值最小的，所以可使WPL最小。</p>
<h4 id="为什么可以用来进行数据压缩（无损压缩）？">为什么可以用来进行数据压缩（无损压缩）？</h4>
<p>压缩不外乎就是对数据的编码处理，使其占用的内存更小。</p>
<p>在数据压缩中，有一种叫做无损压缩，它其中的原理利用了哈夫曼编码，哈夫曼编码相当于哈夫曼树理论的实践。</p>
<p>哈夫曼编码，是一种非常巧妙的编码方式，而且也是可变的，依据字符出现的概率来决定字符编码长度。</p>
<p>在编码时，首先根据待编码的文本统计出每个字符出现的概率，组成初始的节点。然后每次取出概率最小的两个节点，新建一个节点，使得新建节点的左右儿子为选取的两个节点，并且其概率是两个节点概率之和，把新建的节点再放进所有节点中重新选择最小的两个节点。重复此过程直到只剩一个节点，这个就是哈夫曼树的根节点。</p>
<p>以下以字符串&quot;aaaaaabbbbccddd&quot;为例进行说明，为了方便，以字符出现的频数来代替频率（实际中通常使用的是频率，二者效果上是一样的），经过统计，可以知道每个字符出现的频数为：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>具体建树过程如下：</p>
<ol>
<li>首先节点权值为6、4、2、3，选择最小的2和3，组成一个根节点为5的组合节点。</li>
<li>当前节点权值为6、4、5，选择最小的4和5，组成一个根节点为9的组合节点。</li>
<li>当前节点权值为6、9，选择最小的6和9，组成一个根节点为15的组合节点。</li>
<li>当前节点权值为15，只有一个节点，哈夫曼树建立完成。<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202109221715998.png" alt="avatar"></li>
</ol>
<p>要从哈夫曼树得到每个字符的编码，只要在哈夫曼树中从根节点遍历到该字符节点，每次向左走时加一个0，向右走时加一个1，最终得到的字符串即为该字符的编码字符串。</p>
<p>如从上图可以看到，a的编码为0，b的编码为10，c的编码为110，d的编码为111。</p>
<p>哈夫曼编码之所以可以这样解码，是因为它是一种前缀编码，任何一个字符的编码都不会是另一个字符编码的前缀。于是给定一个编码后的串，其解码的结果是唯一的。</p>
<p>最终经过哈夫曼编码后为：  0 0 0 0 0 0 10 10 10 10 110 110 111 111 111 一共为31位，在原始的数据中，一个字符占用3bit, 一共需要45bit</p>
<p>一串字符串，经过哈夫曼编码从45bit压缩到了31bit。因为在这个过程没有数据的丢失，所以是无损压缩。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序提现功能实现</title>
    <url>/posts/4359.html</url>
    <content><![CDATA[<h2 id="需求">需求</h2>
<p>在微信小程序中实现一个提现功能 ，提现的钱其实来自系统中的其他功能。</p>
<p>当然这个功能，需要一个微信支付的商户号，并且账户中需要有充足的余额。</p>
<span id="more"></span>
<h2 id="前期准备">前期准备</h2>
<h3 id="1、登录微信商户平台官网：微信支付-中国领先的第三方支付平台-｜-微信支付提供安全快捷的支付方式-qq-com">1、登录微信商户平台官网：<span class="exturl" data-url="aHR0cHM6Ly9wYXkud2VpeGluLnFxLmNvbS9pbmRleC5waHAvY29yZS9ob21lL2xvZ2luP3JldHVybl91cmw9JTJG">微信支付 - 中国领先的第三方支付平台 ｜ 微信支付提供安全快捷的支付方式 (qq.com)<i class="fa fa-external-link-alt"></i></span></h3>
<h3 id="2、找到产品中心的企业付款到零钱，并开通企业付款到零钱功能">2、找到产品中心的企业付款到零钱，并开通企业付款到零钱功能</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122047375.png" alt="image-20220212204704151"></p>
<h3 id="3、找到AppID账号管理，添加关联AppID">3、找到AppID账号管理，添加关联AppID</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122049879.png" alt="image-20220212204950779"></p>
<h3 id="4、将微信商户号和小程序进行绑定">4、将微信商户号和小程序进行绑定</h3>
<h3 id="5、申请API证书和APIv2密钥，妥善保存，后面会使用">5、申请API证书和APIv2密钥，妥善保存，后面会使用</h3>
<p>注：API证书文件的后缀是.p12</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122101758.png" alt="image-20220212210121591"></p>
<h3 id="6、获取商户号">6、获取商户号</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122106554.png" alt="image-20220212210613468"></p>
<h2 id="代码实现（SpringBoot）">代码实现（SpringBoot）</h2>
<h3 id="1、引入相关官方依赖">1、引入相关官方依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.wxpay<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wxpay-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、在yaml文件添加配置">2、在yaml文件添加配置</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">withDraw:</span><br><span class="line">	apiKey: xxxxxxxx</span><br><span class="line">     mchid: xxxxxx</span><br><span class="line">     mch_appid: xxxxxxxxx</span><br><span class="line">     <span class="comment">//此路径代表是在项目的resouce根目录</span></span><br><span class="line">     certPath: /xxxxxxxx.p12</span><br><span class="line">     count: <span class="number">10</span></span><br><span class="line">     quota: <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="3、编写配置类">3、编写配置类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithDrawConfig</span> <span class="keyword">implements</span> <span class="title class_">WXPayConfig</span> &#123;</span><br><span class="line">    <span class="comment">//从yaml注入配置</span></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mch_appid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mch_appid;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.apiKey&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String apiKey;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mchid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mchid;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.certPath&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String certPath;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getAppID</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mch_appid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMchID</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mchid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> apiKey;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> InputStream <span class="title function_">getCertStream</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//获取证书,证书建议放到resource目录下</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.getClass().getResourceAsStream(certPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHttpConnectTimeoutMs</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">8000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHttpReadTimeoutMs</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、编写提现工具类">4、编写提现工具类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithDrawUtils</span> &#123;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mch_appid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mch_appid;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mchid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mchid;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.apiKey&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String apiKey;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WithDrawConfig withDrawConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成订单号日期时间+随机字符</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getOrderNumber</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> date.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + RandomStringUtils.randomNumeric(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">fillRequest</span><span class="params">(Map&lt;String, String&gt; reqData)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		reqData.put(<span class="string">&quot;mch_appid&quot;</span>, mch_appid);</span><br><span class="line">		reqData.put(<span class="string">&quot;mchid&quot;</span>, mchid);</span><br><span class="line">		reqData.put(<span class="string">&quot;nonce_str&quot;</span>, WXPayUtil.generateNonceStr().toUpperCase());</span><br><span class="line">		reqData.put(<span class="string">&quot;sign&quot;</span>, WXPayUtil.generateSignature(reqData, apiKey, WXPayConstants.SignType.MD5));</span><br><span class="line">		<span class="keyword">return</span> reqData;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMd5ByString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">hexString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">MessageDigest</span> <span class="variable">mdTemp</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">			mdTemp.update(str.getBytes());</span><br><span class="line">			<span class="type">byte</span>[] hash = mdTemp.digest();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">byte</span> b : hash) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((<span class="number">0xff</span> &amp; b) &lt; <span class="number">0x10</span>) &#123;</span><br><span class="line">					hexString.append(<span class="string">&quot;0&quot;</span>).append(Integer.toHexString((<span class="number">0xFF</span> &amp; b)));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					hexString.append(Integer.toHexString(<span class="number">0xFF</span> &amp; b));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hexString.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将对象直接转换成String类型的 XML输出</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">convertToXml</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建输出流</span></span><br><span class="line">		<span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 利用jdk中自带的转换类实现</span></span><br><span class="line">			<span class="type">JAXBContext</span> <span class="variable">context</span> <span class="operator">=</span> JAXBContext.newInstance(obj.getClass());</span><br><span class="line"></span><br><span class="line">			<span class="type">Marshaller</span> <span class="variable">marshaller</span> <span class="operator">=</span> context.createMarshaller();</span><br><span class="line">			<span class="comment">// 格式化xml输出的格式</span></span><br><span class="line">			marshaller.setProperty(Marshaller.JAXB_FRAGMENT,</span><br><span class="line">					Boolean.TRUE);</span><br><span class="line">			<span class="comment">// 将对象转换成输出流形式的xml</span></span><br><span class="line">			marshaller.marshal(obj, sw);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JAXBException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sw.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getRestInstance</span><span class="params">(String url, String data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">UTF8</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">		<span class="type">URL</span> <span class="variable">httpUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">		<span class="type">char</span>[] password = mchid.toCharArray();<span class="comment">//证书密码</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">certStream</span> <span class="operator">=</span> withDrawConfig.getCertStream();<span class="comment">//获取证书的流</span></span><br><span class="line">		<span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);</span><br><span class="line">		ks.load(certStream, password);</span><br><span class="line">		<span class="comment">// 实例化密钥库 &amp; 初始化密钥工厂</span></span><br><span class="line">		<span class="type">KeyManagerFactory</span> <span class="variable">kmf</span> <span class="operator">=</span> KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">		kmf.init(ks, password);</span><br><span class="line">		<span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">		sslContext.init(kmf.getKeyManagers(), (TrustManager[]) <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">		HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());</span><br><span class="line">		<span class="type">HttpURLConnection</span> <span class="variable">httpURLConnection</span> <span class="operator">=</span> (HttpURLConnection) httpUrl.openConnection();</span><br><span class="line">		httpURLConnection.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">		httpURLConnection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">		httpURLConnection.setConnectTimeout(withDrawConfig.getHttpConnectTimeoutMs());</span><br><span class="line">		httpURLConnection.setReadTimeout(withDrawConfig.getHttpReadTimeoutMs());</span><br><span class="line">		httpURLConnection.connect();</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> httpURLConnection.getOutputStream();</span><br><span class="line">		outputStream.write(data.getBytes(UTF8));</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> httpURLConnection.getInputStream();</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, UTF8));</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		String line;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">			stringBuffer.append(line);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			bufferedReader.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			outputStream.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (certStream != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				certStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、提现的业务实现">5、提现的业务实现</h3>
<p>官方接口文档：<span class="exturl" data-url="aHR0cHM6Ly9wYXkud2VpeGluLnFxLmNvbS93aWtpL2RvYy9hcGkvdG9vbHMvbWNoX3BheS5waHA/Y2hhcHRlcj0xNF8y">【微信支付】付款开发者文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始提现，生成订单号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">orderNumber</span> <span class="operator">=</span> withDrawUtils.getOrderNumber();</span><br><span class="line"><span class="comment">//自定义的将提现所需要的参数封装的实体类</span></span><br><span class="line"><span class="type">WithDrawDTO</span> <span class="variable">withDrawDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithDrawDTO</span>();</span><br><span class="line">withDrawDTO.setPartner_trade_no(orderNumber);</span><br><span class="line">withDrawDTO.setDesc(<span class="string">&quot;xxxxx&quot;</span>);</span><br><span class="line">withDrawDTO.setAmount(appletWithDrawDTO.getAmount());</span><br><span class="line"><span class="comment">//此参数代表，开启真实姓名校验，也可以关闭，详看官方文档的参数说明</span></span><br><span class="line">withDrawDTO.setCheck_name(<span class="string">&quot;FORCE_CHECK&quot;</span>);</span><br><span class="line">withDrawDTO.setRe_user_name(appletWithDrawDTO.getName());</span><br><span class="line"><span class="comment">//微信小程序用户的openid</span></span><br><span class="line">withDrawDTO.setOpenid(wxUser.getOpenid());</span><br><span class="line">Map&lt;String, String&gt; params = JSON.parseObject(JSON.toJSONString(withDrawDTO), <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">params = withDrawUtils.fillRequest(params);</span><br><span class="line">withDrawDTO.setNonce_str(params.get(<span class="string">&quot;nonce_str&quot;</span>));</span><br><span class="line">withDrawDTO.setMchid(params.get(<span class="string">&quot;mchid&quot;</span>));</span><br><span class="line">withDrawDTO.setMch_appid(params.get(<span class="string">&quot;mch_appid&quot;</span>));</span><br><span class="line">withDrawDTO.setSign(params.get(<span class="string">&quot;sign&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">post</span> <span class="operator">=</span> withDrawUtils.getRestInstance(url, withDrawUtils.convertToXml(withDrawDTO));</span><br><span class="line">Map&lt;String, String&gt; result = WXPayUtil.xmlToMap(post);</span><br><span class="line"><span class="comment">//result为调用接口之后的返回参数，可以根据返回参数判断是否成功</span></span><br><span class="line"></span><br><span class="line">WithDrawEnum resultEnum;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;SUCCESS&quot;</span>.equals(result.get(<span class="string">&quot;result_code&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">//提现成功</span></span><br><span class="line">    resultEnum = WithDrawEnum.fromText(<span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> resultEnum;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//提现失败</span></span><br><span class="line">    resultEnum = WithDrawEnum.fromText(result.get(<span class="string">&quot;err_code&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(resultEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、提现返回错误代码的枚举类">6、提现返回错误代码的枚举类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">WithDrawEnum</span> &#123;</span><br><span class="line">	SUCCESS(<span class="number">0</span>, <span class="string">&quot;提现成功&quot;</span>),</span><br><span class="line">	FAIL(<span class="number">400</span>, <span class="string">&quot;提现失败，余额小于提现金额&quot;</span>),</span><br><span class="line">	HANDLE_FRE(<span class="number">5000</span>, <span class="string">&quot;操作太频繁&quot;</span>),</span><br><span class="line">	NO_AUTH(<span class="number">5001</span>, <span class="string">&quot;没有该接口权限&quot;</span>),</span><br><span class="line">	AMOUNT_LIMIT(<span class="number">5002</span>, <span class="string">&quot;金额超限&quot;</span>),</span><br><span class="line">	PARAM_ERROR(<span class="number">5003</span>, <span class="string">&quot;参数错误&quot;</span>),</span><br><span class="line">	OPENID_ERROR(<span class="number">5004</span>, <span class="string">&quot;Openid错误&quot;</span>),</span><br><span class="line">	SEND_FAILED(<span class="number">5005</span>, <span class="string">&quot;付款错误&quot;</span>),</span><br><span class="line">	NOTENOUGH(<span class="number">5006</span>, <span class="string">&quot;余额不足&quot;</span>),</span><br><span class="line">	SYSTEMERROR(<span class="number">5007</span>, <span class="string">&quot;系统繁忙，请稍后再试。&quot;</span>),</span><br><span class="line">	NAME_MISMATCH(<span class="number">5008</span>, <span class="string">&quot;姓名校验出错&quot;</span>),</span><br><span class="line">	SIGN_ERROR(<span class="number">5009</span>, <span class="string">&quot;签名错误&quot;</span>),</span><br><span class="line">	XML_ERROR(<span class="number">5010</span>, <span class="string">&quot;发送内容出错&quot;</span>),</span><br><span class="line">	FATAL_ERROR(<span class="number">5011</span>, <span class="string">&quot;两次发送参数不一致&quot;</span>),</span><br><span class="line">	FREQ_LIMIT(<span class="number">5012</span>, <span class="string">&quot;超过频率限制，请稍后再试。&quot;</span>),</span><br><span class="line">	MONEY_LIMIT(<span class="number">5013</span>, <span class="string">&quot;已经达到今日付款总额上限/已达到付款给此用户额度上限&quot;</span>),</span><br><span class="line">	CA_ERROR(<span class="number">5014</span>, <span class="string">&quot;商户证书校验出错&quot;</span>),</span><br><span class="line">	V2_ACCOUNT_SIMPLE_BAN(<span class="number">5015</span>, <span class="string">&quot;无法给未实名用户付款&quot;</span>),</span><br><span class="line">	PARAM_IS_NOT_UTF8(<span class="number">5016</span>, <span class="string">&quot;发送参数中包含不规范字符&quot;</span>),</span><br><span class="line">	SENDNUM_LIMIT(<span class="number">5017</span>, <span class="string">&quot;该用户今日付款次数超过限制, 如有需要请进入【微信支付商户平台-产品中心-付款到零钱-产品设置】进行修改&quot;</span>),</span><br><span class="line">	RECV_ACCOUNT_NOT_ALLOWED(<span class="number">5018</span>, <span class="string">&quot;收款账户不在收款账户列表&quot;</span>),</span><br><span class="line">	PAY_CHANNEL_NOT_ALLOWED(<span class="number">5019</span>, <span class="string">&quot;本商户号未配置此功能&quot;</span>),</span><br><span class="line">	SEND_MONEY_LIMIT(<span class="number">5020</span>, <span class="string">&quot;已达到今日商户付款额度上限&quot;</span>),</span><br><span class="line">	RECEIVED_MONEY_LIMIT(<span class="number">5021</span>, <span class="string">&quot;已达到今日付款给此用户额度上限&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> WithDrawEnum <span class="title function_">fromText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (text != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (WithDrawEnum b : WithDrawEnum.values()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (text.equalsIgnoreCase(b.name())) &#123;</span><br><span class="line">					<span class="keyword">return</span> b;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后">最后</h2>
<p>微信相关接口的调用，主要还是要耐心看文档的说明，才能实现业务需求。</p>
]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>企业付款到零钱</tag>
      </tags>
  </entry>
  <entry>
    <title>微信扫码登录实现</title>
    <url>/posts/18301.html</url>
    <content><![CDATA[<h2 id="需求-2">需求</h2>
<p>使用微信扫码登录的授权方式登录系统</p>
<span id="more"></span>
<h2 id="实现">实现</h2>
<p>此扫码登陆过程中使用了，微信开放平台（需支付300开通开发者认证）的网站应用实现的。</p>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9XZWJzaXRlX0FwcC9XZUNoYXRfTG9naW4vV2VjaGF0X0xvZ2luLmh0bWw=">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="流程：">流程：</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202052041625.png" alt="image-20220205204119502"></p>
<p>大概就是：前端调接口获取后端生成的state（可以用验证登录授权的有效性）——&gt;用户扫码后确认授权——&gt;前端开始调用微信开放平台的接口之后回调服务端接口——&gt;回调时传入了两个参数，code和state——&gt;根据code，appid和appSecret调用接口获取access_token——根据access_token获取微信用户的个人信息</p>
<h3 id="代码：">代码：</h3>
<h4 id="前端vue：">前端vue：</h4>
<h5 id="安装一个插件：">安装一个插件：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-wxlogin --save-dev</span><br></pre></td></tr></table></figure>
<h5 id="引入组件：">引入组件：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;wxlogin</span><br><span class="line">         appid=&quot;xxxxxx&quot;</span><br><span class="line">         :scope=&quot;&#x27;snsapi_login&#x27;&quot;</span><br><span class="line">         theme=&quot;black&quot;</span><br><span class="line">         redirect_uri=&quot;redirectUrl&quot;</span><br><span class="line">         :state=&quot;xxxxxx&quot;</span><br><span class="line">         :self_redirect=&quot;&#x27;true&#x27;&quot;</span><br><span class="line">         rel=&quot;external nofollow&quot;</span><br><span class="line">         /&gt;</span><br></pre></td></tr></table></figure>
<p>注：重定向地址需要使用urlEncode对链接进行处理</p>
<h4 id="后端SpringBoot：">后端SpringBoot：</h4>
<h5 id="后端生成state接口">后端生成state接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;企业端：获取扫码登录的state&quot;, notes = &quot; \n author：ZhuGuangLiang&quot;)</span></span><br><span class="line"><span class="meta">@AnonymousGetMapping(&quot;/wx/qrcode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title function_">getQrCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//生成票据</span></span><br><span class="line">    String state= IdUtil.simpleUUID();</span><br><span class="line">    <span class="comment">//可以将state参数作为存放在redis中的授权用户信息key键</span></span><br><span class="line">    redisUtils.set(state, JSON.toJSON(<span class="keyword">new</span> <span class="title class_">CompanyWxDTO</span>()), <span class="number">5</span> * <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="回调接口，并携带state和code参数">回调接口，并携带state和code参数</h5>
<p>注：回调接口，尽量不要抛出异常，异常可以在登录接口抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;企业端：微信用户授权后，回调地址&quot;, notes = &quot; \n author：ZhuGuangLiang&quot;)</span></span><br><span class="line"><span class="meta">@AnonymousGetMapping(&quot;/wx/callback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(String code, String state)</span> &#123;</span><br><span class="line">    companyAuthService.callback(code, state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法中所有第三方接口都可在官方文档中找到</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(String code, String state)</span> &#123;</span><br><span class="line">    <span class="comment">//authurl获取access_token的接口，可以看官方文档中的第二步</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">resultAuthUrl</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(authUrl, appid, secret, code)));</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultAuthUrl.containsKey(<span class="string">&quot;errcode&quot;</span>)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;授权失败&quot;</span>);</span><br><span class="line">        isSuccess = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//			throw new BadRequestException(ResultEnum.USER_NO_AUTH);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> resultAuthUrl.getString(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> resultAuthUrl.getString(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> resultAuthUrl.getString(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">    <span class="comment">//根据code获取access_toke</span></span><br><span class="line">    LambdaQueryWrapper&lt;SpiritCompanyUser&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(SpiritCompanyUser::getOpenid, openid);</span><br><span class="line">    <span class="type">CompanyWxDTO</span> <span class="variable">companyWxDTO</span> <span class="operator">=</span> loginUtils.noExceptinCheckCompanyUser(queryWrapper);</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> companyWxDTO.getType();</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">        <span class="comment">//登录失败，此时我使用type类型去记录每一种异常</span></span><br><span class="line">        companyWxDTO.setType(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span> &amp;&amp; isSuccess) &#123;</span><br><span class="line">        <span class="comment">//校验授权凭证</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resultCheckToken</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(checkTokenUrl, accessToken, openid)));</span><br><span class="line">        <span class="keyword">if</span> (resultCheckToken.getInteger(<span class="string">&quot;errcode&quot;</span>) == <span class="number">40003</span>) &#123;</span><br><span class="line">            <span class="comment">//刷新token，防止出现token失效</span></span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">resultRefreshToken</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(refreshTokenUrl, appid, refreshToken)));</span><br><span class="line">            accessToken = resultRefreshToken.getString(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resultUserInfoUrl</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(userInfoUrl, accessToken, openid)));</span><br><span class="line">        log.info(<span class="string">&quot;resultUserInfoUrl:&quot;</span> + resultUserInfoUrl.toString());</span><br><span class="line">        <span class="keyword">if</span> (resultUserInfoUrl.containsKey(<span class="string">&quot;errcode&quot;</span>)) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取用户信息失败&quot;</span>);</span><br><span class="line">            <span class="comment">//同上</span></span><br><span class="line">            companyWxDTO.setType(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        companyWxDTO.setAvatarUrl(resultUserInfoUrl.getString(<span class="string">&quot;headimgurl&quot;</span>));</span><br><span class="line">        companyWxDTO.setNickName(resultUserInfoUrl.getString(<span class="string">&quot;nickname&quot;</span>));</span><br><span class="line">        companyWxDTO.setOpenid(openid);</span><br><span class="line">        companyWxDTO.setUnionid(resultUserInfoUrl.getString(<span class="string">&quot;unionid&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;微信用户授权成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    companyWxDTO.setTicket(state);</span><br><span class="line">    redisUtils.set(state, JSON.toJSON(companyWxDTO), <span class="number">5</span> * <span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>扫码登录</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个SpringBoot组件发布到Maven中央仓库</title>
    <url>/posts/54328.html</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p>springboot组件也叫<code>starters</code>（场景启动器），这也是SpringBoot最强大的特点，把可以与SpringBoot集成的技术封装成一个个启动器，供有需要的人，因需引入。</p>
<p>以下是来自官网的 starters 描述：</p>
<p>Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access, just include the spring-boot-starter-data-jpa dependency in your project, and you are good to go.<br>
The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies.</p>
<p>starters 是一组方便的依赖性描述符，可以包括在应用程序中。您可以为所有Spring和所需的相关技术提供一站式服务，而无需搜索示例代码并复制粘贴的依赖描述符负载。例如，如果您想开始使用 Spring 和 JPA 进行数据库访问，只需在项目中包含SpringBootStarter数据 JPA 依赖项，就可以开始了。</p>
<p>常见的场景启动器有：spring-boot-starter-aop，spring-boot-starter-data-jpa等。</p>
<h3 id="starter原理">starter原理</h3>
<p>1、在maven中引入项目需要的依赖</p>
<p>2、编写项目整体的逻辑</p>
<p>3、将相关自定义的类加入springboot自动装配的范围之中</p>
<span id="more"></span>
<h3 id="1、如何手写SpringBoot组件—自定义spring-boot-starter">1、如何手写SpringBoot组件—自定义spring-boot-starter</h3>
<h4 id="1-1、创建Maven项目">1.1、创建Maven项目</h4>
<p><strong>项目名</strong></p>
<p>命名规约：<br>
官方命名空间</p>
<p>前缀：spring-boot-starter-<br>
模式：spring-boot-starter-模块名<br>
如：spring-boot-starter-web</p>
<p>自定义命名空间：</p>
<p>后缀：-spring-boot-starter<br>
模式：模块-spring-boot-starter<br>
如：xxx-spring-boot-starter</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210150952526.png" alt="image-20221015095200339"></p>
<p>注：</p>
<p>GroupId：这是一个网站，必须有效，可以填写公司的域名或者个人博客地址</p>
<p>Version：RELEASE代表稳定版本，SNAPSHOT代表快照版本，如何项目处于完善中写快照版本，如果项目处于等待发布的状态，可以写稳定版本的后缀。</p>
<h4 id="1-2、引入依赖">1.2、引入依赖</h4>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!--引入spring-boot-starter：所有starter的基本配置--&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring-boot.version&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>
<h4 id="1-3、创建包目录">1.3、创建包目录</h4>
<p>根据GroupId来创建</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210151040442.png" alt="image-20221015104007367"></p>
<h4 id="1-4、写组件功能">1.4、写组件功能</h4>
<p>下面将以我的开源项目为例，进行说明，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pnbGdpdGh1YngvYXBpbm90aWNlLXNwcmluZy1ib290LXN0YXJ0ZXI=">GitHub地址<i class="fa fa-external-link-alt"></i></span></p>
<p>大致功能：使用AOP处理使用注解@Notice的方法，并发送邮件</p>
<p><strong>引入功能所需依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP面向切面编程框架 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--邮箱--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建引用yml配置文件的属性类NoticeProperties</strong></p>
<p>这个类主要作用让用户在项目配置文件中可以自定义发件人的名称</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">&quot;abnormal&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoticeProperties</span> &#123;</span><br><span class="line">	<span class="comment">/** 发件人名称，API助手为默认值 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">String</span> sender=<span class="string">&quot;API助手&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getSender</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> sender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setSender</span>(<span class="params"><span class="built_in">String</span> sender</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">sender</span> = sender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建核心类，使用@Aspect使该类作用切面处理类</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoticeException</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">JavaMailSender</span> mailSender;</span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">NoticeProperties</span> noticeProperties;</span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">String</span> <span class="keyword">from</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setMailSender</span>(<span class="params">JavaMailSender mailSender</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">mailSender</span> = mailSender;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setNoticeProperties</span>(<span class="params">NoticeProperties noticeProperties</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">noticeProperties</span> = noticeProperties;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setFrom</span>(<span class="params"><span class="built_in">String</span> <span class="keyword">from</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">from</span> = <span class="keyword">from</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建自动装配Bean的配置类</strong></p>
<p>@Configuration：指定这个类是一个配置类<br>
@ConditionalOnXXX：在指定条件成立的情况下自动配置类生效<br>
@EnableConfigurationProperties：让 XXXProperties 类生效，加入到容器中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span><span class="comment">//在web应用中才会生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(<span class="title class_">NoticeProperties</span>.<span class="property">class</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoticeAutoConfiguration</span> &#123;</span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">JavaMailSender</span> mailSender;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">NoticeProperties</span> noticeProperties;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">&quot;$&#123;spring.mail.username&#125;&quot;</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">String</span> <span class="keyword">from</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span><span class="comment">//注入对象到bean容器中，方法名为bean名称</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title class_">NoticeException</span> <span class="title function_">noticeException</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title class_">NoticeException</span> eN=<span class="keyword">new</span> <span class="title class_">NoticeException</span>();</span><br><span class="line">		eN.<span class="title function_">setNoticeProperties</span>(noticeProperties);</span><br><span class="line">		eN.<span class="title function_">setFrom</span>(<span class="keyword">from</span>);</span><br><span class="line">		eN.<span class="title function_">setMailSender</span>(mailSender);</span><br><span class="line">		<span class="keyword">return</span> eN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>加载自动装配类</strong></p>
<p>如果要加载自动配置类，还需一步，根据Bean自动装配的原理，SpringBoot实际加载的spring.factories文件来实现自动装配。</p>
<p>在Resoures目录中创建目录：META-INF，并创建spring.factories文件，将自动配置类加入其中</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line">org.springframework.boot.autoconfigure.<span class="attribute">EnableAutoConfiguration</span>=\</span><br><span class="line">io.github.zglgithubx.apinotice.NoticeAutoConfiguration</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong></p>
<p>如果想在自定义的属性加入提示，需要引入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件提示，需加此依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在META-INF中和创建文件additional-spring-configuration-metadata.json</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;abnormal.sender&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="string">&quot;发件人名称.&quot;</span>,</span><br><span class="line">      <span class="string">&quot;defaultValue&quot;</span>: <span class="string">&quot;API助手&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果就如：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210151117561.png" alt="image-20221015111704477"></p>
<h3 id="2、测试组件—把组件安装到本地的Maven仓库">2、测试组件—把组件安装到本地的Maven仓库</h3>
<h4 id="2-1、执行-mvn-clean-install">2.1、执行 mvn clean install</h4>
<p>此时已经在本地的Maven仓库生成项目jar包</p>
<h4 id="2-2、在其他项目中引入依赖">2.2、在其他项目中引入依赖</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.zglgithubx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apinotice-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3、发布到Maven中央仓库">3、发布到Maven中央仓库</h3>
<h4 id="3-1、首先将项目推送到github仓库">3.1、首先将项目推送到github仓库</h4>
<p>在项目的pom.xml添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/zglgithubx/apinotice-spring-boot-starter<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>ApiNotice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2、注册sonatype账号">3.2、注册sonatype账号</h4>
<p>你的项目首先要通过这个平台的审核，然后才能发布</p>
<p>注册地址：[<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuc29uYXR5cGUub3JnL3NlY3VyZS9TaWdudXAhZGVmYXVsdC5qc3Bh">Sign up for Jira - Sonatype JIRA<i class="fa fa-external-link-alt"></i></span>](<span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuc29uYXR5cGUub3JnL3NlY3VyZS9TaWdudXAhZGVmYXVsdC5qc3Bh">https://issues.sonatype.org/secure/Signup!default.jspa<i class="fa fa-external-link-alt"></i></span>)</p>
<h4 id="3-3、新建issue—提交申请">3.3、新建issue—提交申请</h4>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210151543009.png" alt="image-20221015154302730"></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210151547144.png" alt="image-20221015154757018"></p>
<p>新建之后，会有工作人员审核十几分分钟左右，如果有问题，他们会有评论，按照他们修改意见修改再提交就行。</p>
<p>如果没有问题，他们则会让你在github上创建一个新的空仓库，用来验证github账号是不是你本人的，例如：Create a temporary, public repository called <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pnbGdpdGh1YngvT1NTUkgtODUzNDE=">https://github.com/zglgithubx/OSSRH-85341<i class="fa fa-external-link-alt"></i></span> to verify github account ownership.创建之后再次提交就行。</p>
<p>上面的操作顺利完成没有问题，会有这样的评论：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210151552721.png" alt="image-20221015155221597"></p>
<h4 id="3-4、安装GPG工具">3.4、安装GPG工具</h4>
<p>这个工具是防止你的仓库代码被人修改，从而破坏代码。详细的请自行百度。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251cGcub3JnL2Rvd25sb2FkLw==">GPG<i class="fa fa-external-link-alt"></i></span></p>
<p>找到：<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152002891.png" alt="image-20221015200227664"></p>
<p>下载之后，默认安装</p>
<p>在控制台打印：gpg --version，判断是否完成成功</p>
<h4 id="3-5、生成密钥">3.5、生成密钥</h4>
<p>使用管理员打开cmd</p>
<p>生成key：gpg --gen-key</p>
<p>会提示输入：用户名，邮箱，输入完成后输入o。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152006150.png" alt="image-20221015200636057"></p>
<p>回车后，会让你输入两次密码，然后ok，就会生成密钥。</p>
<h4 id="3-6、把key发送到中央仓库服务器，后面在上传时会做验证">3.6、把key发送到中央仓库服务器，后面在上传时会做验证</h4>
<p>首先找到key，在安装的gpg客户端中找到密钥id，密钥id就是接下来需要发送的key</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152010750.png" alt="image-20221015201017643"></p>
<p>执行命令：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送key</span></span><br><span class="line">gpg <span class="attr">--keyserver</span> keyserver<span class="selector-class">.ubuntu</span><span class="selector-class">.com</span> <span class="attr">--send-keys</span> E1CED113257DC99A</span><br><span class="line"><span class="comment">//判断key是否已经发送到服务器</span></span><br><span class="line">gpg <span class="attr">--keyserver</span> keyserver<span class="selector-class">.ubuntu</span><span class="selector-class">.com</span> <span class="attr">--recv-keys</span> E1CED113257DC99A</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152014339.png" alt="image-20221015201450241"></p>
<p>显示以上结果代表已经发送成功</p>
<h4 id="3-7、修改Maven配置和项目配置">3.7、修改Maven配置和项目配置</h4>
<p>在Maven的setting.xml添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  中央仓库个人存储库的账号密码 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">username</span>&gt;</span>自己的账号<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">password</span>&gt;</span>自己的密码<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在项目的pom.xml添加，根据自己的项目进行修改</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- mvn clean deploy  --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 开源许可证 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>MIT License<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://www.opensource.org/licenses/mit-license.php<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 源码信息 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/zglgithubx/apinotice-spring-boot-starter<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:https://github.com/zglgithubx/apinotice-spring-boot-starter.git<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:https://github.com/zglgithubx/apinotice-spring-boot-starter.git<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 个人信息,对应 gpg 配置 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhuguangliang<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>786945363@qq.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>+8<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 中央仓库配置id 需对应 settings.xml 的 server的id --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://s01.oss.sonatype.org/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 打包配置 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>apinotice-spring-boot-starter-$</span><span class="template-variable">&#123;version&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="comment">&lt;!-- java-doc配置 --&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">aggregate</span>&gt;</span>true<span class="tag">&lt;/<span class="name">aggregate</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span> <span class="comment">&lt;!-- add this to disable checking --&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">additionalparam</span>&gt;</span>-Xdoclint:none<span class="tag">&lt;/<span class="name">additionalparam</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="comment">&lt;!-- 使用source 进行jar打包--&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="comment">&lt;!-- gpg 配置 --&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>sign-artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>sign<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-8、上传仓库">3.8、上传仓库</h4>
<p>管理员身份打开 cmd 进入项目命令执行命令,注意在idea 编辑器中的终端无法执行 gpg 命令，无法进行上传操作</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn</span> clean deploy</span><br></pre></td></tr></table></figure>
<p>如果下显示构建成功就代表已经上传成功，但是还需要验证发布</p>
<h4 id="3-9、验证发布">3.9、验证发布</h4>
<p>访问：<span class="exturl" data-url="aHR0cHM6Ly9zMDEub3NzLnNvbmF0eXBlLm9yZy8=">Nexus Repository Manager (sonatype.org)<i class="fa fa-external-link-alt"></i></span></p>
<p>点击右上角输入账号密码登录，与申请发布项目时一样</p>
<p>登录之后点击，Staging Repositories</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152022669.png" alt="image-20221015202224501"></p>
<p>会找到项目</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152027626.png" alt="image-20221015202728465"></p>
<p>选中项目后，点击close，提交验证</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202210152028050.png" alt="image-20221015202809857"></p>
<p>提交后，如果验证通过，Release按钮会变为可点击的状态，点击Release按钮发布即可。</p>
<p>发布成功后，会有邮箱提示：</p>
<p>30分钟后可以在中央仓库中找打，4个小时后可以搜索到。</p>
<p>Central sync is activated for io.github.zglgithubx. After you successfully release, your component will be available to the public on Central <span class="exturl" data-url="aHR0cHM6Ly9yZXBvMS5tYXZlbi5vcmcvbWF2ZW4yLw==">https://repo1.maven.org/maven2/<i class="fa fa-external-link-alt"></i></span>, typically within 30 minutes, though updates to <span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnLw==">https://search.maven.org<i class="fa fa-external-link-alt"></i></span> can take up to four hours.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的接口监控及邮件提醒实现</title>
    <url>/posts/11529.html</url>
    <content><![CDATA[<h3 id="前言-2">前言</h3>
<p>最近因为疫情，不得不在家办公，而且也赶上了项目处于内测阶段，测试期间如果有问题，不能及时把问题复现出来。于是我在网上搜索有没有一些工具能对接口进行一个实时的监控，出现问题，立马通知相关人员。项目虽然有日志信息，但是因为项目是在集群中部署，日志信息，需要进入服务器的控制台中查看，比较麻烦。</p>
<p>忙活了一天，装了不少用来测试接口的框架，他们在介绍的时候，说的是对接口监控，其实是在不断的调用接口，来达到监控的效果，而且用的时候，需要准备很多工作，创建项目，创建测试用例等。</p>
<p>就在我没有思路的时候，看到一篇博客，讲的是，接口监控的原理都是在异常处理中进行的。</p>
<span id="more"></span>
<h3 id="实现-2">实现</h3>
<p>注解+异常信息的处理+发送邮件</p>
<h4 id="注解">注解</h4>
<p>该注解只是为了获取接口的创建者或者维护者的邮箱</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> Notice &#123;</span><br><span class="line">	<span class="selector-tag">String</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：创建注解之后，只需要在接口方法上添加@Notice即可，里面的内容为邮箱</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ApiOperation</span>(value = <span class="string">&quot;获取上传凭证&quot;</span>, notes = <span class="string">&quot; \n author：ZhuGuangLiang&quot;</span>)</span><br><span class="line">	<span class="variable">@AnonymousGetMapping</span>(<span class="string">&quot;/upload&quot;</span>)</span><br><span class="line">	<span class="variable">@Notice</span>(<span class="string">&quot;786945363@qq.com&quot;</span>)</span><br><span class="line">	public Result&lt;Object&gt; upload(Integer type) &#123;</span><br><span class="line">		<span class="selector-tag">if</span> (type == null) &#123;</span><br><span class="line">			<span class="selector-tag">throw</span> <span class="selector-tag">new</span> <span class="selector-tag">BadRequestException</span>(<span class="string">&quot;文件种类为空&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-tag">return</span> <span class="selector-tag">Result</span><span class="selector-class">.success</span>(fileUtils.upload(type));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异常处理">异常处理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> marchsoft.annotation.Notice;</span><br><span class="line"><span class="keyword">import</span> marchsoft.modules.spiritdeerpush.common.utils.email.EmailUtils;</span><br><span class="line"><span class="keyword">import</span> marchsoft.utils.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MyException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ZhuGuangLiang &lt;786945363@qq.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/01/09 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line">    <span class="comment">//自己封装的发送邮箱的工具类，可以注入自己的</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> EmailUtils emailUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管理员邮箱作为默认邮箱</span></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;notice.admin&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String adminEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//邮件提醒的开关</span></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;notice.open&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> on;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里代表接口监控的范围，可以通过你的项目包名进行配置</span></span><br><span class="line">	<span class="meta">@Around(&quot;execution(* com.modules.xxxx.*.controller..*.*(..))&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pj)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">starttime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			log.info(&quot;---------------------API请求参数：【&quot; + getMessage(pj, null) + &quot;】&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> pj.proceed();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (on == <span class="number">1</span>) &#123;</span><br><span class="line">				concatError(starttime, getMessage(pj, e), pj);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">concatError</span><span class="params">(<span class="type">long</span> starttime, String message, ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&lt;h3&gt;接口耗时:&lt;/h3&gt;&quot;</span>);</span><br><span class="line">		stringBuilder.append(<span class="string">&quot;接口花费时间：&quot;</span>).append(System.currentTimeMillis() - starttime).append(<span class="string">&quot;ms&lt;br/&gt;&quot;</span>);</span><br><span class="line">		stringBuilder.append(message);</span><br><span class="line">		<span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) pj.getSignature();</span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">		<span class="type">Notice</span> <span class="variable">toNotice</span> <span class="operator">=</span> method.getAnnotation(Notice.class);</span><br><span class="line">		<span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> adminEmail;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtil.isNotNull(toNotice) &amp;&amp; StringUtils.isNotBlank(toNotice.value())) &#123;</span><br><span class="line">			to = toNotice.value();</span><br><span class="line">		&#125;</span><br><span class="line">		sendErrorNotice(stringBuilder.toString(), to);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">getMessage</span><span class="params">(ProceedingJoinPoint pj, Exception e)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">			log.error(e.getMessage(), e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">RequestAttributes</span> <span class="variable">ra</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">		<span class="type">ServletRequestAttributes</span> <span class="variable">sra</span> <span class="operator">=</span> (ServletRequestAttributes) ra;</span><br><span class="line">		<span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> sra.getRequest();</span><br><span class="line">		<span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) pj.getSignature();</span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">		<span class="type">ApiOperation</span> <span class="variable">toNotice</span> <span class="operator">=</span> method.getAnnotation(ApiOperation.class);</span><br><span class="line">        <span class="comment">//这一部分是为了，添加负责人，负责人信息我是从swagger的ApiOperation注解中获取的，可以根据自己项目的配置调整</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">charger</span> <span class="operator">=</span> <span class="string">&quot;无&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtil.isNotNull(toNotice) &amp;&amp; StringUtils.isNotBlank(toNotice.notes())) &#123;</span><br><span class="line">			charger = toNotice.notes().trim();</span><br><span class="line">			charger = charger.replace(<span class="string">&quot;\\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">joiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&lt;h3&gt;负责人：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(charger)</span><br><span class="line">				.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;接口地址：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(request.getRequestURI())</span><br><span class="line">				.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;类名：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(pj.getTarget().getClass().getSimpleName())</span><br><span class="line">				.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;方法：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(pj.getSignature().getName());</span><br><span class="line">		Object[] args = pj.getArgs();</span><br><span class="line">		List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Object object : args) &#123;</span><br><span class="line">			<span class="keyword">if</span> (object <span class="keyword">instanceof</span> MultipartFile || object <span class="keyword">instanceof</span> File) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			objects.add(object);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtil.isNotNull(objects) &amp;&amp; !objects.isEmpty()) &#123;</span><br><span class="line">			joiner.append(Arrays.toString(objects.toArray()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Objects.nonNull(e)) &#123;</span><br><span class="line">			joiner.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;message：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">					.append(e.getMessage())</span><br><span class="line">					.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;异常：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">					.append(e.fillInStackTrace());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> joiner.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendErrorNotice</span><span class="params">(String content, String to)</span> &#123;</span><br><span class="line">		<span class="comment">//发送异常提醒邮件给接受人</span></span><br><span class="line">		emailUtils.sendException(to, content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="发送邮件">发送邮件</h4>
<p>可以自行百度关于发送的邮件的配置，这里就不一一陈述了。</p>
<h3 id="最后-2">最后</h3>
<p>这个功能其实还是很简单，也有一定的局限性，比如没有包含具体报错的行数，只包含的方法和参数的信息，方便复现问题吧。在接口监控方面其实也有一些现成的框架，可以实现更加详细的报告，我还是个菜鸟，继续加油学习↖(^ω^)↗。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之循环队列</title>
    <url>/posts/33202.html</url>
    <content><![CDATA[<p>为充分利用向量空间，克服&quot;<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODElODclRTYlQkElQTIlRTUlODclQkEvMTEwNTA5Mzc=">假溢出<i class="fa fa-external-link-alt"></i></span>&quot;现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。循环队列是把<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklQTElQkElRTUlQkElOEYlRTklOTglOUYlRTUlODglOTcvMjA4MzI3MzQ=">顺序队列<i class="fa fa-external-link-alt"></i></span>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p>
<span id="more"></span>
<h3 id="循环队列三种情况">循环队列三种情况</h3>
<h4 id="1、">1、</h4>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061150819.png" alt="image-20211006115040686"></p>
<ul>
<li>
<p>front指向头元素的前一个元素</p>
</li>
<li>
<p>rear指向队尾元素</p>
</li>
<li>
<p>对空、入队和队满情况判断：</p>
<ul>
<li>队空：front=rear</li>
<li>入队：rear=（rear+1）%maxsize，每次元素进入队列，队尾指针rear向后移动 一位。
<ul>
<li>queue【rear】=x</li>
</ul>
</li>
<li>队满：front==(rear+1)%maxsize</li>
</ul>
</li>
<li>
<p>根据rear和front计算队列长度：</p>
<ul>
<li>当rear&gt;front
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061424940.png" alt="image-20211006142409854"></li>
<li>很容易得到队列长度为：rear-front</li>
</ul>
</li>
<li>当rear&lt;front
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061440374.png" alt="image-20211006144049313">
<ul>
<li>因为是循环队列，rear的位置可以在front的前面，此时队列长度为：rear+1+maxsize-front-1=rear-front+maxsize
<ul>
<li>rear+ 1为其中一段的长度</li>
<li>maxsize-front-1为另一段的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2、">2、</h4>
<h4 id="image-20211006151401822"><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061514889.png" alt="image-20211006151401822"></h4>
<ul>
<li>front指向头元素</li>
<li>rear指向队尾的后一个元素</li>
<li>队满：front=(rear+1)%maxsize</li>
<li>队列长度：(rear-front+max)%maxsize</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列之RabbitMQ学习笔记</title>
    <url>/posts/49673.html</url>
    <content><![CDATA[<h3 id="什么是消息队列">什么是消息队列</h3>
<p>消息是两个应用间传递的数据。消息队列简单的来讲是将消息在传输的过程中用来存储消息的容器。</p>
<p>在消息队列中，通常会有生产者和消费者，生产者将消息放到队列中，消费者从中取出消息。</p>
<h3 id="为什么要使用消息队列">为什么要使用消息队列</h3>
<ul>
<li>解藕：
<ul>
<li>假如消息的接收方有多个，需要单独给每个接收方都要发送消息，如果又新增一个接收方，则需要增加新代码才能实现。为了降低这种耦合，使用MQ，发送方只需要把消息放到队列中，接受方只需要在队列中取消息，这样就避免了每次新增接收方而去增加新代码，从而实现解藕。</li>
</ul>
</li>
<li>异步：
<ul>
<li>个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</li>
</ul>
</li>
<li>削峰：
<ul>
<li>假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="RabbitMQ介绍">RabbitMQ介绍</h3>
<p>abbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p>
<p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
<p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h3 id="安装">安装</h3>
<h4 id="1、安装ERLang语言，配置环境变量">1、安装ERLang语言，配置环境变量</h4>
<p>ERlang<span class="exturl" data-url="aHR0cHM6Ly93d3cuZXJsYW5nLm9yZy9kb3dubG9hZHM/c3BtPWEyYzZoLjEyODczNjM5LjAuMC40MzM3MzNkZlRvaXhZWg==">官网<i class="fa fa-external-link-alt"></i></span>下载window版安装包</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071152710.png" alt="img"></p>
<p>安装中，一直点next，完成后配置环境变量</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071153051.png" alt="img"></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071154226.png" alt="img"></p>
<p>完成后，打开cmd,输入验证是否成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">erl -version</span><br></pre></td></tr></table></figure>
<h4 id="2、安装RabbitMQ服务端">2、安装RabbitMQ服务端</h4>
<p>在RabbitMQ的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhYmJpdG1xL3JhYmJpdG1xLXNlcnZlci9yZWxlYXNlcy90YWcvdjMuNy4zP3NwbT1hMmM2aC4xMjg3MzYzOS4wLjAuNDMzNzMzZGZ2emtvaTcmZmlsZT12My43LjM=">GitHub项目<i class="fa fa-external-link-alt"></i></span>中，下载window版本的服务端安装包</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071157091.png" alt="img"></p>
<p>安装后，找到安装目录：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071158360.png" alt="img"></p>
<p>在此目录打开cmd命令，输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装管理页面插件</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>在此目录下双击rabbitmq-server.bat启动脚本，然后打开服务管理可以看到RabbitMQ正在运行：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071200331.png" alt="img"></p>
<p>最后在浏览器输入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入客户端</span></span><br><span class="line">http:<span class="comment">//localhost:15672</span></span><br><span class="line">账号密码默认是：guest/guest</span><br></pre></td></tr></table></figure>
<h3 id="RabbitMQ中的组成部分">RabbitMQ中的组成部分</h3>
<ul>
<li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。</li>
<li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li>
<li>Queue：消息队列，存储消息的队列。</li>
<li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li>
<li>Consumer：消息消费者。消费队列中存储的消息。</li>
</ul>
<p>这些部分协同工作图：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071208178.png" alt="img"></p>
<ul>
<li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li>
<li>生产者声明交换机类型、名称、是否持久化等。</li>
<li>生产者发送消息，并指定消息是否持久化等属性和routing key。</li>
<li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li>
<li>消费者监听接收到消息之后开始业务处理。</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<h4 id="优点">优点</h4>
<ul>
<li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li>
<li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>
<li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li>
<li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li>
<li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>系统可用性降低：你想呀，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低</li>
<li>系统复杂性增加：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，刺痛复杂性增大。</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/posts/51189.html</url>
    <content><![CDATA[<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。<br>
计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p>
<span id="more"></span>
<h2 id="一、基础知识">一、基础知识</h2>
<h3 id="1、IPV4地址">1、IPV4地址</h3>
<h4 id="1-1、v4协议">1.1、v4协议</h4>
<p>目前的全球因特网所采用的协议族是TCP/IP协议族。IP是TCP/IP协议族中网络层的协议，是TCP/IP协议族的核心协议。目前IP协议的版本号是4(简称为IPv4)。</p>
<h4 id="1-2、v4地址">1.2、v4地址</h4>
<ul>
<li>在TCP/IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</li>
<li>IPv4地址就是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li>
<li>IP地址由因特网名字和数字分配机构ICANN进行分配。
<ul>
<li>我国用户可向亚太网络信息中心APNIC申请ip地址，需要缴费。</li>
<li>2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPv4地址已经分配完毕。</li>
<li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6 。</li>
</ul>
</li>
<li>IPv4地址的编址方法经历了如下三个历史阶段：
<ul>
<li>1981年分类编址</li>
<li>1985年划分子网</li>
<li>1993年无分类编址</li>
</ul>
</li>
<li>表示方法：
<ul>
<li>IPv4的地址位数为32位，也就是说最多有2的32次方的IPv4地址可以联到Internet上。</li>
<li>通常，IPv4地址以点分十进制表示。IPV4 就是有4 段数字，每一段由0~255 数字组成。每个部分代表一组构成8位地址方案的8位地址。<br>
<img data-src="https://img-blog.csdnimg.cn/90b0d6877b234419ab94669086681089.png" alt="image.png"><br>
<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531153426.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="1-3、分类编址的IPv4地址">1.3、分类编址的IPv4地址</h4>
<ul>
<li>A类网络，最高位固定为0
<ul>
<li>8位网络号，24位主机号</li>
<li>最小网络号0，保留不指派</li>
<li>第一个可指派的网络号为00000001，网络地址为1.0.0.0</li>
<li>最大网络号二进制011111111（127），作为本地环回测试地址，不指派。最小还回测试地址：127.0.0.1，最大的本地环回测试地址为127.255.255.254</li>
<li>最后一个可指派的网络号为126，网络地址为126.0.0.0</li>
<li>可指派的网络数量为2^(8-1)-2=126（减2的原因是除去最小网络号0和最大网络号127）</li>
<li>每个网络中可分配的IP地址数量为2^24-2=16777214（减2的原因是除去主机号为全0的网络地址和全1的广播地址）</li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531155340.png" alt=""></li>
</ul>
</li>
<li>B类网络，最高位固定为10
<ul>
<li>最小网络号也是第一个可指派的网络号128.0网络地址为128.0.0.0</li>
<li>最大网络号也是最后一个可指派的网络号191.255网络地址为191.255.0.0</li>
<li>可指派的网络数量为2^(16-2)=16384</li>
<li>每个网络中可分配的IP地址数量为2^16-2=65534（减2的原因是除去主机号为全0的网络地址和全1的广播地址）</li>
<li>在有些资料中指出128.0是保留网络号，B类第一个可指派的网络好为128.1。但根据2002年9月发表的RFC3330文档，128.0网络号已经可以分配了。</li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531160550.png" alt=""></li>
</ul>
</li>
<li>C类网络，最高位固定为110
<ul>
<li>最小网络号也是第一个可指派的网络号192.0.0，网络地址为192.0.0.0</li>
<li>最大网络号也是最后一个可指派的网络号223.255.255网络地址为223.255.255.0</li>
<li>可指派的网络数量为2^(24-3)=2097152</li>
<li>每个网络中可分配的IP地址数量为2^8-2=254（减2的原因是除去主机号为全0的网络地址和全1的广播地址）</li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531163924.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="1-4、划分子网的IPv4地址">1.4、划分子网的IPv4地址</h4>
<ul>
<li>32比特的子网掩码可以表明分类Ip地址的主机号部分被借用了几个比特作为子网号</li>
<li>子网掩码使用连续的比特1来对应网络号和子网号</li>
<li>子网掩码使用连续的比特0来对应主机号</li>
<li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址</li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531173526.png" alt=""></li>
<li>例子：
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531201838.png" alt=""></li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531202042.png" alt=""></li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531202403.png" alt=""></li>
</ul>
</li>
<li>默认的子网掩码是指未划分子网的情况下使用的子网掩码
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531202751.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="1-5、无分类编址的IPv4地址">1.5、无分类编址的IPv4地址</h4>
<ul>
<li>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间大小并没有得到充分使用，而因特网的IP地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</li>
<li>1993年，IETF发布了无分类域间路由选择CIDR
<ul>
<li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念；</li>
<li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的IPv6使用之前 允许因特网的规模继续增长。</li>
</ul>
</li>
<li>例子：
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220531204506.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="1-5、思考">1.5、思考</h4>
<h5 id="什么是子网">什么是子网</h5>
<p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网(subnet)。</strong></p>
<h5 id="什么是子网掩码">什么是子网掩码</h5>
<ul>
<li>指明一个<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9JUCVFNSU5QyVCMCVFNSU5RCU4MA==">IP地址<i class="fa fa-external-link-alt"></i></span>的哪些位标识的是<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQkIlRTYlOUMlQkEvNDU1MTUx">主机<i class="fa fa-external-link-alt"></i></span>所在的子网，以及哪些位标识的是主机的位掩码</li>
<li>通过子网掩码，就可以判断两个IP在不在一个局域网内部。</li>
<li>子网掩码可以看出有多少位是网络号，有多少位是主机号</li>
</ul>
<h5 id="子网划分的意义">子网划分的意义</h5>
<ul>
<li>节省IP地址资源</li>
<li>大大减少路由表的数目</li>
</ul>
<h2 id="二、面试题">二、面试题</h2>
<h3 id="1、浏览器中输入网址敲回车发生了什么？">1、浏览器中输入网址敲回车发生了什么？</h3>
<ul>
<li>URL解析</li>
<li>DNS查询</li>
<li>TCP连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面<br>
参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDU1MTc2OQ==">在浏览器输入 URL 回车之后发生了什么（超详细版） - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="2、服务器如何区分用户请求的？">2、服务器如何区分用户请求的？</h3>
<ul>
<li>浏览器首次访问服务器时，服务器会给客户端创建一个会话session，并响应一个会话的唯一标识sessionId。</li>
<li>浏览器收到此SessionId后，第二次请求时会将此sessionId添加中请求头的cookie中。</li>
<li>服务器判断cookie中的sessionId是否有效，来判断是否是同一浏览器进程发起的请求。<br>
参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3MTI1MzU1L2FydGljbGUvZGV0YWlscy80NDYyMTE5NQ==">一分钟解惑：上万个用户请求，服务器如何区分_君子_不器的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="3、路由器、防火墙处于哪一层？">3、路由器、防火墙处于哪一层？</h3>
<ul>
<li>路由器：则是一种典型的网络层设备，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。</li>
<li>防火墙：传统的包过滤防火墙工作在网络层，电路网关防火墙工作在传输层（线路级防火墙工作在会话层），应用网关类的代理防火墙则工作在OSI最高的应用层。</li>
</ul>
<h3 id="4、DNS协议">4、DNS协议</h3>
<ul>
<li>域名解析系统，是互联网一项服务，完成域名地址与IP地址的转换</li>
<li>参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTEwNTkyOTM=">超详细 DNS 协议解析 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQ3NTA5My9hcnRpY2xlL2RldGFpbHMvMTE3MDUwODcx">面试官：DNS 协议是什么？说说 DNS 完整的查询过程?_动感超人，的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="5、HTTP协议">5、HTTP协议</h3>
<p><code>HTTP</code>协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。</p>
<blockquote>
<p><strong>注意</strong>：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在传输层协议TCP之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。</p>
</blockquote>
<p><code>HTTP</code> 是一种<strong>无状态</strong> (stateless) 协议, <code>HTTP</code>协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持HTTP协议的简单性，从而能够快速处理大量的事务, 提高效率。</p>
<h3 id="6、HTTP和TCP区别和联系？">6、HTTP和TCP区别和联系？</h3>
<ul>
<li>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</li>
<li>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</li>
</ul>
<h3 id="7、HTTP和HTTPS的区别，HTTP中S是指什么？">7、HTTP和HTTPS的区别，HTTP中S是指什么？</h3>
<ul>
<li>区别：
<ul>
<li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口不一样，前者是80，后者是443；</li>
</ul>
</li>
<li>字母S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。
<ul>
<li>SSL/TLS协议目的：
<ul>
<li>所有信息都是加密传播，避免窃听风险</li>
<li>具有校验机制，被篡改后，通信双方可以立刻发现</li>
<li>配被身份证书，防止被冒充</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8、HTTPS原理">8、HTTPS原理</h3>
<ul>
<li>建立连接过程（非对称加密）
<ul>
<li>客户端向服务端发送请求，请求内容中包含（支持的TLS版本，客服端支持的加密套件，随机数A）
<ul>
<li>服务端响应给客户端，内容包括（确认支持的TLS版本，服务端选择的加密套件，随机数B）</li>
<li>服务端再次发送响应，此次内容为服务器的证书，客户端（浏览器查看可信任的证书列表）验证证书是否可信</li>
<li>服务端响应给客户端证书公钥</li>
</ul>
</li>
<li>客户端生成随机数C，使用公钥加密随机数C，将加密后的随机数C发送给服务端
<ul>
<li>服务端使用私钥解密随机数C</li>
</ul>
</li>
<li>客户端和服务端使用随机A，B，C，计算出会话密钥（只应用于当前会话）</li>
</ul>
</li>
<li>传输数据（对称加密）
<ul>
<li>客户端和服务端使用会话密钥对数据进行加解密</li>
</ul>
</li>
</ul>
<h3 id="9、公钥加密和私钥加密有什么区别？">9、公钥加密和私钥加密有什么区别？</h3>
<ul>
<li>公钥加密用来加密数据。公钥加密后，只能用私钥解密，而私钥不是公开的，所以保证了数据只能由私钥持有者才能看到。如果用私钥加密，公钥是公开的，这样就会导致所有人都能解密，并不能保证数据的私密性。</li>
<li>私钥加密用来签名，公钥用于验签。签名并不是为了保密，而是保证了这个签名是由特定的人发出的，而不是被其他人伪造的，所有私钥的私有性适合用在签名的用途上。</li>
<li>公私钥特性
<ul>
<li>公钥与私钥是成对出现的</li>
<li>私钥文件中包含了公钥数据，所以可以基于私钥导出公钥</li>
<li>密钥越长，越难破解，所以2048位密钥比1024位密钥要更安全</li>
<li>公钥和私钥都是密钥，被公开的那个就是公钥，没有被公开的那个就是私钥</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统学习笔记</title>
    <url>/posts/39126.html</url>
    <content><![CDATA[<p>计算机操作系统学习笔记</p>
<span id="more"></span>
<h2 id="一、基础">一、基础</h2>
<h3 id="1、物理内存和虚拟内存">1、物理内存和虚拟内存</h3>
<h4 id="1-1、物理内存">1.1、物理内存</h4>
<h5 id="1-1-1、应用中的描述">1.1.1、应用中的描述</h5>
<p>物理内存是计算机上的最重要的资源之一。Windows的内存管理器负责给活动进程、设备驱动，和操作系统自己分配内存。因为绝大多数系统所能访问的数据和代码远比物理内存多，所以从本质上来说，物理内存是代码和数据在其中运行的窗口。所以内存容量对性能有影响，因为如果进程或者操作系统所需的代码或者数据不存在，内存管理器就需要从磁盘中读取这些内容。</p>
<h5 id="1-1-2、CPU中的描述">1.1.2、CPU中的描述</h5>
<p>物理内存，CPU的地址线可以直接进行寻址的内存空间大小。比如8086只有20根地址线，那它的寻址空间就是1MB。我们就说8086能支持1MB的物理内存。即使我们安装了128M的内存条在板子上，我们也只能说8086拥有1MB的物理内存空间。同理32位的386以上CPU，就可以支持最大4GB的物理内存空间了。</p>
<h4 id="1-2虚拟内存">1.2虚拟内存</h4>
<p>虚拟内存是对主存和磁盘 I/O 设备的抽象表示，是操作系统为每个进程分配的连续的虚拟地址空间。<br>
内存和外存之和为虚拟内存<br>
<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/20220620093116.png" alt=""></p>
<h4 id="1-3区别">1.3区别</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUYlRTUlODYlODUlRTUlQUQlOTg=">虚拟内存<i class="fa fa-external-link-alt"></i></span>就与物理内存相反，是指根据系统需要从<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTElQUMlRTclOUIlOTg=">硬盘<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUY=">虚拟<i class="fa fa-external-link-alt"></i></span>地匀出来的内存空间，是一种<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkElRTclQjMlQkIlRTclQkIlOUY=">计算机系统<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODYlODUlRTUlQUQlOTglRTclQUUlQTElRTclOTAlODY=">内存管理<i class="fa fa-external-link-alt"></i></span>技术，属于<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkE=">计算机<i class="fa fa-external-link-alt"></i></span>程序，而物理内存为<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTElQUMlRTQlQkIlQjY=">硬件<i class="fa fa-external-link-alt"></i></span>。因为有时候当你处理大的程序时候<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQjMlQkIlRTclQkIlOUYlRTUlODYlODUlRTUlQUQlOTg=">系统内存<i class="fa fa-external-link-alt"></i></span>不够用，此时就会把<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQTElQUMlRTclOUIlOTg=">硬盘<i class="fa fa-external-link-alt"></i></span>当内存来使用，来<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkElQTQlRTYlOEQlQTI=">交换<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUU=">数据<i class="fa fa-external-link-alt"></i></span>做<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQkMlOTMlRTUlQUQlOTg=">缓存<i class="fa fa-external-link-alt"></i></span>区，不过物理内存的处理速度是<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUYlRTUlODYlODUlRTUlQUQlOTg=">虚拟内存<i class="fa fa-external-link-alt"></i></span>的30倍以上。</p>
<h3 id="2、缓存IO和直接IO">2、缓存IO和直接IO</h3>
<p>I/O：输入/输出(Input/Output)，分为IO设备和IO接口两个部分。在POSIX兼容的系统上，例如Linux系统，I/O操作可以有多种方式，比如DIO(Direct I/O)，AIO(Asynchronous I/O， 异步I/O)，Memory-Mapped I/O(内存映射I/O)等，不同的I/O方式有不同的实现方式和性能，在不同的应用中可以按情况选择不同的I/O方式。<br>
<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202206211111129.png" alt=""></p>
<h4 id="2-1、缓存io">2.1、缓存io</h4>
<p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制（DMA copy）到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。</p>
<blockquote>
<p>DMA:IO设备和内存之间的数据传输方式。DMA（直接内存访问，Direct Memory Access），不经过Cpu而直接进行磁盘和内存的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传输，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样在很大程度上降低了CPU占用率，大大节省了系统资源。</p>
</blockquote>
<p>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</p>
<p>写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</p>
<p><strong>缓存I/O的优点</strong>：首先，在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；其次，可以减少读盘的次数，从而提高性能。</p>
<p><strong>缓存I/O的缺点</strong>：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<h4 id="2-2-、直接io">2.2 、直接io</h4>
<p>直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区，自己管理IO缓存区，这样做的目的是减少一次内核缓冲区到用户程序缓存的数据复制。</p>
<p>引入内核缓冲区的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在内核缓冲区中，那么就不需要再次访问磁盘。而当进程需要向文件写入数据是，实际上只是写到了内核缓冲区便告诉进程已经写成功，而真正写入磁盘是通过一定的策略进行延时的。</p>
<p>然而，对于一些较复杂的应用，比如数据库服务器，他们为了充分提高性能。希望绕过内核缓冲区，由自己在用户态空间时间并管理IO缓冲区，包括缓存机制和写延迟机制等，以支持独特的查询机制，比如数据库可以根据加合理的策略来提高查询缓存命中率。另一方面，绕过内核缓冲区也可以减少系统内存的开销，因为内核缓冲区本身就在使用系统内存。</p>
<p><strong>直接IO的缺点</strong>：如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，这种直接加载会非常缓存。通常直接IO与异步IO结合使用，会得到比较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）。<br>
<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202206211114867.png" alt=""></p>
<h3 id="3、进程调度算法">3、进程调度算法</h3>
<p>操作系统中常用的进程调度算法，主要有三种优先调度算法、高优先权先调度算法和基于时间片的轮转调度算法：</p>
<h4 id="3-1、优先调度算法">3.1、优先调度算法</h4>
<ul>
<li>先来先服务调度算法（FCFS）<br>
每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存运行，分配执行资源。</li>
<li>短作业（进程）优先调度算法（SFJ）<br>
每次都是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们放入内存运行，分配执行资源。<br>
TIP:采用优先调度算法时，线程一旦获得CPU执行权限，将一直执行到完成，或发生某事件而被阻塞放弃处理时才会再重新调度<br>
缺点：优先调度算法未考虑到紧迫型作业。</li>
</ul>
<h4 id="3-2、高优先权优先调度算法">3.2、高优先权优先调度算法</h4>
<p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法，当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</p>
<ul>
<li>非抢占式优先权算法
<ul>
<li>特点：系统一旦把处理机分配给了就绪队列中优先权最高的进城后，该进程便会一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。</li>
<li>适用系统：这种调度算法主要用于批处理中，也可用于某些对实时性要求不严的实时系统中。</li>
</ul>
</li>
<li>抢占式优先权调度算法
<ul>
<li>特点：当在系统执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序立即停止当前进程（原优先权最高的进程）的执行，重新将处理机分配给信道的优先权最高的进程。</li>
<li>适用系统：显然，这种抢占式的优先权调度算法能更好的满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
</ul>
<h4 id="3-3、高响应比优先调度算法">3.3、高响应比优先调度算法</h4>
<p>原理：在短作业优先算法的基础上，为每个作业引入优先权，并使作业的优先级随着等待事件的增加而增加，则长作业在等待一定时间后，必然有机会分配到处理机。<br>
特点：</p>
<ul>
<li>如果作业的等待时间相同，则要求服务的时间越短，其优先权越高，因而该算法有利于短作业；</li>
<li>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间越长，其优先权越高，因而它实现的是先来先服务；</li>
<li>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升的很高，从而也可获得处理机。<br>
优点：该算法即照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。<br>
缺点：在利用该算法时，每当要进行调度之前，都须先做响应比计算，这会增加系统开销。</li>
</ul>
<h4 id="3-4、基于时间片的轮转调度算法">3.4、基于时间片的轮转调度算法</h4>
<p>实现：</p>
<ul>
<li>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片；</li>
<li>当执行的时间片用完时；由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；</li>
<li>然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给顶的时间内均能获得一时间片的处理机执行时间。</li>
</ul>
<h4 id="3-5、多级反馈队列调度算法">3.5、多级反馈队列调度算法</h4>
<p>实现：</p>
<ul>
<li>设置多个就绪队列，并未各个队列赋予不同的优先级与不同时间片。第一个队列的优先级最高，第二个队列次之，其余个队列的优先级逐个降低。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。例如，第二个队列的时间片要比第一个队列的时间片长一倍。。，第i+1个队列的时间片要比第i个队列的时间片长1倍；</li>
<li>当一个新进程进入内存后，首先将它放到第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片仍未完成，再依次将它放入第三队列。。。如此下去，当一个长作业（进程）从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行；</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行。仅当第1-（i-1）队列均为空，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列中，则此时新进程将抢占正在运行进程的处理及，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理及分配给新的高优先权进程。TIP：在多级反馈队列调度算法中，如果规定了第一队列的时间片略大于大多数人机交互所需之处理时间时，便能够较好的满足个类型用户的需要。</li>
</ul>
<h3 id="4、线程和进程">4、线程和进程</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29uL2FydGljbGUvZGV0YWlscy8xMDIwMjEyNzQ=">进程和线程的区别(超详细)_ThinkWon的博客-CSDN博客_进程和线程的区别<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="5、进程和线程的调度">5、进程和线程的调度</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTE0NjUyMC9hcnRpY2xlL2RldGFpbHMvMTE0NDc4MDMw">进程和线程的调度_Ryan-S的博客-CSDN博客_进程和线程的调度<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="6、线程的创建和结束">6、线程的创建和结束</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hdGFmZWl5YW5sbC9hcnRpY2xlL2RldGFpbHMvMTEwNzQyNzky">(1条消息) 第七章_线程 : 线程的概念、创建与终止_马踏飞燕&amp;lin_li的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="7、线程状态">7、线程状态</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MS9hcnRpY2xlL2RldGFpbHMvNTM4NjA2NTE=">(1条消息) Java线程的6种状态及切换(透彻讲解)_潘建南的博客-CSDN博客_线程状态<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="8、线程间通信与线程同步机制">8、线程间通信与线程同步机制</h3>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzAwNjk0NDg=">面试官：说说进程间通信和线程间通信的几种方式及区别 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85MjE4NjkyY2IyMDk=">线程间的通信、同步方式与进程间通信方式 - 简书 (jianshu.com)<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="9、互斥锁和信号量">9、互斥锁和信号量</h3>
<p>参考：<span class="exturl" data-url="aHR0cDovL3QuY3Nkbi5jbi9JWk10dQ==">详解信号量和互斥锁之间的区别和联系<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="10、线程池">10、线程池</h3>
<p>参考：<span class="exturl" data-url="aHR0cDovL3QuY3Nkbi5jbi9OcnJqRw==">java线程池 面试题<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="11、消费者和生产者">11、消费者和生产者</h3>
<p>参考：<span class="exturl" data-url="aHR0cDovL3QuY3Nkbi5jbi92VzVRTw==">http://t.csdn.cn/vW5QO<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="12、死锁">12、死锁</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80NDEyNWJiMTJlYmY=">死锁是什么？如何避免死锁？ - 简书 (jianshu.com)<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="13、并发和并行">13、并发和并行</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDI0MjQ5">面试必考的：并发和并行有什么区别？ - 腾讯云开发者社区-腾讯云 (tencent.com)<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="二、面试题-2">二、面试题</h2>
<h3 id="1、什么是纤程？">1、什么是纤程？</h3>
<ul>
<li>定义<br>
纤程是 fiber , 是由操作系统实现的一种轻量化线程上的一个执行结构。 通常是多个fiber共享一个固定的线程, 然后他们通过互相主动切换到其他fiber来交出线程的执行权.。各个子任务之间的关系非常强。</li>
</ul>
<blockquote>
<p>在Windows2000/XP中，纤程(fiber)相当于用户级别的线程或轻进程.纤程由Win32库函数支持,对核心是不可见的.纤程可以通过SwitchToFiber切换至另一合作纤程,以实现合作纤程之间的协同。</p>
</blockquote>
<ul>
<li>优缺点
<ul>
<li>优点：消耗小，切换快，一个进程可以创建成千上万个纤程。小任务顺序编程很符合人的思维方式, 规避纯异步编程中状态机的复杂性. 使得使用纤程写的程序将更加的直观, 逻辑描述方便, 简化编程.纤程用于化异步为同步, 你可以进行一个异步操作以后就切换纤程，等到异步操作完成以后在切换回来，这样，在逻辑上相关的代码就可以写到一个函数里面，而不用人为的分到多个回调函数中。没有了线程所谓的安全问题, 避免锁机制。</li>
<li>缺点：纤程一般只支持所有的纤程函数在一个线程里面跑. 无法充分利用多核CPU, 除非把所有的IO和计算操作都剥离成单独的线程。关于跨平台的纤程的实现和使用资料较少。</li>
</ul>
</li>
<li>参考：
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3ajE3NjQ3NTkwNzgxL2FydGljbGUvZGV0YWlscy8xMTkwNjI1MjA=">JVM之线程实现的不同方式、以及协程、纤程（基于《深入理解Java虚拟机》之第12章Java内存模型与线程）（下）_slow is fast.的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpbmdfd2VuZy9hcnRpY2xlL2RldGFpbHMvMTEzMzkzNDA1">纤程_king_weng的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫实践</title>
    <url>/posts/31819.html</url>
    <content><![CDATA[<h3 id="Java写爬虫分为两步：第一步打开idea，第二步开始敲代码…">Java写爬虫分为两步：第一步打开idea，第二步开始敲代码…</h3>
<span id="more"></span>   
<h3 id="1、我的见解">1、我的见解</h3>
<p>爬虫，我的理解就是，首先要可以获取大量数据，然后在大量数据中筛选出自己想要的数据，并且能对数据进行修饰。接下来，将会给大家介绍，两种爬取数据的方式：JSoup和WebClient。</p>
<h3 id="2、JSoup">2、JSoup</h3>
<h4 id="①是什么">①是什么</h4>
<p>Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果。 在本教程中，我们将介绍很多Jsoup的例子。</p>
<h4 id="②它能做什么">②它能做什么</h4>
<ul>
<li>从URL，文件或字符串中刮取并解析HTML</li>
<li>查找和提取数据，使用DOM遍历或CSS选择器</li>
<li>操纵HTML元素，属性和文本</li>
<li>根据安全的白名单清理用户提交的内容，以防止XSS攻击</li>
<li>输出整洁的HTML</li>
</ul>
<h4 id="③下载依赖">③下载依赖</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;!-- jsoup HTML parser library @ http:<span class="comment">//jsoup.org/ --&gt;</span></span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.10</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="④Jsoup用法">④Jsoup用法</h4>
<ul>
<li>
<p>从URL获取HTML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://www.baidu.com/&quot;</span>).get();</span><br><span class="line"><span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> doc.title();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其中其中JSoup.connet(“<span class="exturl" data-url="aHR0cDovL3h4eA==">http://xxx<i class="fa fa-external-link-alt"></i></span>”)方法返回了一个Connection对象</p>
</li>
<li>
<p>在Connection对象可以调用get()或post()方法执行请求，也可以在Connection对象中设置一些请求信息。比如：头信息，cookie ,请求等待时间，代理等。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">  .data(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">  .userAgent(<span class="string">&quot;Mozilla&quot;</span>)</span><br><span class="line">  .cookie(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;token&quot;</span>)</span><br><span class="line">  .timeout(<span class="number">3000</span>)</span><br><span class="line">  .post();</span><br></pre></td></tr></table></figure>
<ul>
<li>发送请求后，就会获取一个Document文档对象，内容是当前链接的html</li>
</ul>
</li>
<li>
<p>获得Document对象后，接下来就是解析Document对象，并从中获取我们想要的元素了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//doucment对象中获取相应标签的方法</span></span><br><span class="line">getElementById(String id)：通过id来获取</span><br><span class="line">getElementsByTag(String tagName)：通过标签名字来获取</span><br><span class="line">getElementsByClass(String className)：通过类名来获取</span><br><span class="line">getElementsByAttribute(String key)：通过属性名字来获取</span><br><span class="line">getElementsByAttributeValue(String key, String value)：通过指定的属性名字，属性值来获取</span><br><span class="line">getAllElements()：获取所有元素</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Jsoup的强大在于它对文档元素的检索，Select方法将返回一个Elements集合，并提供一组方法来抽取和处理结果，即Jsoup的选择器语法。</p>
<p>1、Selector选择器基本语法</p>
<ul>
<li>
<p>tagname: 通过标签查找元素，比如：a</p>
</li>
<li>
<p>ns|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 <span class="exturl" data-url="ZmI6bmFtZQ==">fb:name<i class="fa fa-external-link-alt"></i></span> 元素</p>
</li>
<li>
<p>#id: 通过ID查找元素，比如：#logo</p>
</li>
<li>
<p>.class: 通过class名称查找元素，比如：.masthead</p>
</li>
<li></li>
<li>
<p>[^attr]: 利用属性名前缀来查找元素，比如：可以用[^data-] 来查找带有HTML5 Dataset属性的元素</p>
</li>
<li></li>
<li>
<p>[attr^=value], [attr$=value], [attr*=value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href*=/path/]</p>
</li>
<li>
<p>[attr~=regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src~=(?i).(png|jpe?g)]</p>
</li>
<li>
<p>*: 这个符号将匹配所有元素</p>
</li>
</ul>
<p>2、Selector选择器组合使用语法</p>
<ul>
<li>el#id: 元素+ID，比如： div#logo</li>
<li>el.class: 元素+class，比如： div.masthead</li>
<li>el[attr]: 元素+class，比如： a[href]</li>
<li>任意组合，比如：a[href].highlight</li>
<li>ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在”body”元素下的所有 p元素</li>
<li>parent &gt; child: 查找某个父元素下的直接子元素，比如：可以用div.content &gt; p 查找 p 元素，也可以用body &gt; * 查找body标签下所有直接子元素</li>
<li>siblingA + siblingB: 查找在A元素之前第一个同级元素B，比如：div.head + div</li>
<li>siblingA ~ siblingX: 查找A元素之前的同级X元素，比如：h1 ~ p</li>
<li>el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo</li>
</ul>
<p>3、Selector伪选择器语法</p>
<ul>
<li>:lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小于三列的元素</li>
<li>:gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素</li>
<li>:eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素</li>
<li>:has(seletor): 查找匹配选择器包含元素的元素，比如：div:has§表示哪些div包含了p元素</li>
<li>:not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class=logo 元素的所有 div 列表</li>
<li>:contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup)</li>
<li>:containsOwn(text): 查找直接包含给定文本的元素</li>
<li>:matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login)</li>
<li>:matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素</li>
</ul>
<p>注意：上述伪选择器索引是从0开始的，也就是说第一个元素索引值为0，第二个元素index为1等。</p>
</li>
</ul>
</li>
</ul>
<h4 id="⑤实例">⑤实例</h4>
<ul>
<li>
<p>使用<code>Jsoup.connect()</code> 方法从URL加载HTML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Document document=Jsoup.connect(<span class="string">&quot;http://www.baidu.com&quot;</span>).get();</span><br><span class="line">    System.out.println(document);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从文件加载HTML,使用<code>Jsoup.parse()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse( <span class="keyword">new</span> <span class="title class_">File</span>( <span class="string">&quot;D:/temp/index.html&quot;</span> ) , <span class="string">&quot;utf-8&quot;</span> );</span><br><span class="line">    System.out.println(document.title());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>Jsoup.parse()</code> 方法从字符串加载HTML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">    System.out.println(document.title());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取HTML页面的图标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">favImage</span> <span class="operator">=</span> <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/temp/index.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> document.head().select(<span class="string">&quot;link[href~=.*\\.(ico|png)]&quot;</span>).first();</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="literal">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        element = document.head().select(<span class="string">&quot;meta[itemprop=image]&quot;</span>).first();</span><br><span class="line">        <span class="keyword">if</span> (element != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            favImage = element.attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        favImage = element.attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(favImage);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取HTML页面的所有链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/temp/index.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Elements</span> <span class="variable">links</span> <span class="operator">=</span> document.select(<span class="string">&quot;a[href]&quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (Element link : links) </span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;link : &quot;</span> + link.attr(<span class="string">&quot;href&quot;</span>));  </span><br><span class="line">         System.out.println(<span class="string">&quot;text : &quot;</span> + link.text());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取HTML页面中所有的图像</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/temp/index.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Elements</span> <span class="variable">images</span> <span class="operator">=</span> document.select(<span class="string">&quot;img[src~=(?i)\\.(png|jpe?g|gif)]&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Element image : images) </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;src : &quot;</span> + image.attr(<span class="string">&quot;src&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;height : &quot;</span> + image.attr(<span class="string">&quot;height&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;width : &quot;</span> + image.attr(<span class="string">&quot;width&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;alt : &quot;</span> + image.attr(<span class="string">&quot;alt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改获取的HTML标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Users/zkpkhua/Desktop/yiibai.com.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//将所有div标签替换为p标签</span></span><br><span class="line">    document.select(<span class="string">&quot;div&quot;</span>).tagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">    <span class="type">Elements</span> <span class="variable">links</span> <span class="operator">=</span> document.select(<span class="string">&quot;a[href]&quot;</span>);  </span><br><span class="line">    <span class="comment">//给所有a标签添加属性rel=&quot;nofollow&quot;</span></span><br><span class="line">    links.attr(<span class="string">&quot;rel&quot;</span>, <span class="string">&quot;nofollow&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>消除不信任的HTML（防止XSS攻击）</p>
<ul>
<li>Jsoup在提供强大的API的同时，人性化方面也做得很好。在做网站的时候，经常会提供用户的评论的功能。有些用户比较淘气，会搞一些脚本到评论内容中，而这些脚本可能会破坏整个页面的功能，更严重的是获取一些机要信息，例如XSS跨站攻击之类的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dirtyHTML</span> <span class="operator">=</span> <span class="string">&quot;&lt;p&gt;&lt;a href=&#x27;http://www.yiibai.com/&#x27; onclick=&#x27;sendCookiesToMe()&#x27;&gt;Link&lt;/a&gt;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">cleanHTML</span> <span class="operator">=</span> Jsoup.clean(dirtyHTML, Whitelist.basic());</span><br><span class="line">System.out.println(cleanHTML);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行后输出结果</span></span><br><span class="line">&lt;p&gt;&lt;a href=<span class="string">&quot;http://www.yiibai.com/&quot;</span> rel=<span class="string">&quot;nofollow&quot;</span>&gt;Link&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Jsoup使用一个Whitelist类来对HTML文档进行过滤，该类提供了几个常用的方法</p>
</li>
<li>
<table>
<thead>
<tr>
<th>方法名</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>none()</td>
<td>只允许包含文本信息</td>
</tr>
<tr>
<td>basic()</td>
<td>允许的标签包括：a,b,blockquote,br,cite, code,dd,dl,dt,em,i,li,ol,p.pre,q,small,strong,sub,sujp,u,ul,以及合适的属性</td>
</tr>
<tr>
<td>simpel(）</td>
<td>只允许b，em，i，strong，u，这些标签</td>
</tr>
<tr>
<td>basicWithImage()</td>
<td>在basic()基础上增加了图片</td>
</tr>
<tr>
<td>relax()</td>
<td>这个过滤器允许的标签最多，包括：a，b，blockquote，br，caption，cite，code，col，colgroup，dd，dl，dt，em，h1-h6，i，img，li，ol，p，pre，q，small，strike，strong，sub，sup， table，tbody，td，tfoot，th，thead，tr，u，ul</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>如果这五个过滤器都无法满足你的需求，例如你允许用户插入flase动画，没关系，Whitelist提供扩展功能，例如<code>whitelist.addTags(&quot;embed&quot;,&quot;object&quot;,&quot;param&quot;,&quot;span&quot;,&quot;div&quot;)</code>，也可以调用<code>addAttributes</code>为某些元素增加属性</p>
</li>
</ul>
</li>
</ul>
<h3 id="3、WebClient">3、WebClient</h3>
<p>ps：它比jsoup好在哪，在我的需求中，它比jsoup获取更深的数据，有时页面的链接并不会直接显式放到a标签中的href属性中，而是放到了js文件中，利用用户点击事件触发执行。webclient相当于一个能模拟浏览器的工具，比如你可以用它在页面中提交表单，发起请求等。</p>
<h4 id="①是什么-2">①是什么</h4>
<p>WebClient是从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对应的get、post、put、delete等方法，可以用来发起相应的请求。</p>
<h4 id="②怎么用">②怎么用</h4>
<ul>
<li>用maven引入依赖，或者直接下载jar包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;	</span><br></pre></td></tr></table></figure>
<ul>
<li>一个例子</li>
</ul>
<p>通过<code>WebClient.create()</code>创建一个WebClient的实例，之后可以通过get()，post() 等选择调用方式，uri() 指定需要请求的路径，retrieve（） 用来发起请求并获得响应，<code>bodyToMono(String.class) </code>用来指定请求结果需要处理为String，并包装为Reactor的Mono对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebClient webClient=WebClient.create();</span><br><span class="line">Mono&lt;String&gt; mono=webClient.get().uri(<span class="string">&quot;https://www.baidu.com&quot;</span>).retrieve().bodyToMono(String.class);</span><br><span class="line">System.out.println(mono.block());</span><br></pre></td></tr></table></figure>
<h4 id="③实例">③实例</h4>
<ul>
<li>
<p>URL中使用路径变量</p>
<ul>
<li>
<p>URL中也可以使用路径变量，路径变量的值可以通过uri方法的第2个参数指定。下面的代码中就定义了URL中拥有一个路径变量id，然后实际访问时该变量将取值1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webClient.get().uri(<span class="string">&quot;http://localhost:8081/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>URL中也可以使用多个路径变量，多个路径变量的赋值将依次使用uri方法的第2个、第3个、第N个参数。下面的代码中就定义了URL中拥有路径变量p1和p2，实际访问的时候将被替换为var1和var2。所以实际访问的URL是<code>http://localhost:8081/user/var1/var2</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webClient.get().uri(<span class="string">&quot;http://localhost:8081/user/&#123;p1&#125;/&#123;p2&#125;&quot;</span>, <span class="string">&quot;var1&quot;</span>, <span class="string">&quot;var2&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用的路径变量也可以通过Map进行赋值。面的代码中就定义了URL中拥有路径变量p1和p2，实际访问的时候会从uriVariables中获取值进行替换。所以实际访问的URL是<code>http://localhost:8081/user/var1/1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; uriVariables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">uriVariables.put(<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;var1&quot;</span>);</span><br><span class="line">uriVariables.put(<span class="string">&quot;p2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">webClient.get().uri(<span class="string">&quot;http://localhost:8081/user/&#123;p1&#125;/&#123;p2&#125;&quot;</span>, uriVariables);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用uriBuilder传递参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://192.1681.5.9:8989&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line">WebClient.<span class="type">RequestBodyUriSpec</span> <span class="variable">request</span> <span class="operator">=</span> webClient.method(HttpMethod.POST);</span><br><span class="line">request.uri(uriBuilder -&gt; uriBuilder</span><br><span class="line">            .scheme(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">            .host(<span class="string">&quot;192.168.5.9&quot;</span>)</span><br><span class="line">            .path(<span class="string">&quot;/mxtest4&quot;</span>)</span><br><span class="line">            .port(<span class="number">8989</span>)</span><br><span class="line">            .path(<span class="string">&quot;/mxtest4&quot;</span>)</span><br><span class="line">            .queryParam(<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;啊&quot;</span>)</span><br><span class="line">            .queryParam(<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;是&quot;</span>)</span><br><span class="line">            .build());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定baseUrl</p>
<ul>
<li>
<p>在应用中使用WebClient时也许你要访问的URL都来自同一个应用，只是对应不同的URL地址，这个时候可以把公用的部分抽出来定义为baseUrl，然后在进行WebClient请求的时候只指定相对于baseUrl的URL部分即可。这样的好处是你的baseUrl需要变更的时候可以只要修改一处即可。下面的代码在创建WebClient时定义了baseUrl为<code>http://localhost:8081</code>，在发起Get请求时指定了URL为<code>/user/1</code>，而实际上访问的URL是<code>http://localhost:8081/user/1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line">Mono&lt;User&gt; mono = webClient.get().uri(<span class="string">&quot;user/&#123;id&#125;&quot;</span>, <span class="number">1</span>).retrieve().bodyToMono(User.class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>表单提交</p>
<ul>
<li>
<p>当传递的请求体对象是一个MultiValueMap对象时，WebClient默认发起的是Form提交。下面的代码中就通过Form提交模拟了用户进行登录操作，给Form表单传递了参数username，值为u123，传递了参数password，值为p123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;u123&quot;</span>);</span><br><span class="line">map.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;p123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;String&gt; mono = webClient.post().uri(<span class="string">&quot;/login&quot;</span>).syncBody(map).retrieve().bodyToMono(String.class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>请求时携带JSON参数</p>
<ul>
<li>
<p>假设现在拥有一个新增User的接口，按照接口定义客户端应该传递一个JSON对象，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>客户端可以建立一个满足需要的JSON格式的对象，然后直接把该对象作为请求体，WebClient会帮我们自动把它转换为JSON对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; mono = webClient.post().uri(<span class="string">&quot;/user/add&quot;</span>).syncBody(user).retrieve().bodyToMono(Void.class);</span><br><span class="line">mono.block();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有建立对应的对象，直接包装为一个Map对象也是可以的。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">user.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; mono = webClient.post().uri(<span class="string">&quot;/user/add&quot;</span>).syncBody(user).retrieve().bodyToMono(Void.class);</span><br><span class="line">mono.block();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>直接传递一个JSON字符串也是可以的，但是此时需要指定contentType为<code>application/json</code>，也可以加上charset。默认情况下WebClient将根据传递的对象在进行解析处理后自动选择ContentType。直接传递字符串时默认使用的ContentType会是<code>text/plain</code>。其它情况下也可以主动指定ContentType。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;&#123;&quot;</span> + </span><br><span class="line">        <span class="string">&quot;    \&quot;name\&quot;:\&quot;张三\&quot;,\r\n&quot;</span> + </span><br><span class="line">        <span class="string">&quot;    \&quot;username\&quot;:\&quot;zhangsan\&quot;\r\n&quot;</span> + </span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; mono = webClient.post().uri(<span class="string">&quot;/user/add&quot;</span>).contentType(MediaType.APPLICATION_JSON_UTF8).syncBody(userJson).retrieve().bodyToMono(Void.class);</span><br><span class="line">mono.block();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>处理WebClient错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebClient.<span class="type">ResponseSpec</span> <span class="variable">retrieve</span> <span class="operator">=</span> request.retrieve();</span><br><span class="line"></span><br><span class="line">Mono&lt;String&gt; mono = retrieve</span><br><span class="line">        .onStatus(e -&gt; e.is4xxClientError(), resp -&gt; &#123;</span><br><span class="line">            System.out.println(resp.statusCode().value() + <span class="string">&quot;,&quot;</span> + resp.statusCode().getReasonPhrase());</span><br><span class="line">            <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(resp.statusCode().value() + <span class="string">&quot; : &quot;</span> + resp.statusCode().getReasonPhrase()));</span><br><span class="line">        &#125;)</span><br><span class="line">        .bodyToMono(String.class)</span><br><span class="line">        .doOnError(WebClientResponseException.class, err -&gt; &#123;</span><br><span class="line">            System.out.println(err.getRawStatusCode() + <span class="string">&quot;,&quot;</span> + err.getResponseBodyAsString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(err.getMessage());</span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorReturn(<span class="string">&quot;fallback&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;result:&quot;</span> + mono.block());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>上传和下载文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">headers.setContentType(MediaType.IMAGE_PNG);</span><br><span class="line">HttpEntity&lt;ClassPathResource&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;parallel.png&quot;</span>), headers);</span><br><span class="line">MultiValueMap&lt;String, Object&gt; parts = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">parts.add(<span class="string">&quot;file&quot;</span>, entity);</span><br><span class="line">Mono&lt;String&gt; resp = WebClient.create().post()</span><br><span class="line">        .uri(<span class="string">&quot;http://localhost:8080/upload&quot;</span>)</span><br><span class="line">        .contentType(MediaType.MULTIPART_FORM_DATA)</span><br><span class="line">        .body(BodyInserters.fromMultipartData(parts))</span><br><span class="line">        .retrieve().bodyToMono(String.class);</span><br><span class="line">LOGGER.info(<span class="string">&quot;result:&#123;&#125;&quot;</span>,resp.block());</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载图片</span></span><br><span class="line">Mono&lt;Resource&gt; resp = WebClient.create().get()</span><br><span class="line">            .uri(<span class="string">&quot;http://www.toolip.gr/captcha?complexity=99&amp;size=60&amp;length=9&quot;</span>)</span><br><span class="line">            .accept(MediaType.IMAGE_PNG)</span><br><span class="line">            .retrieve().bodyToMono(Resource.class);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resp.block();</span><br><span class="line"><span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> ImageIO.read(resource.getInputStream());</span><br><span class="line">ImageIO.write(bufferedImage, <span class="string">&quot;png&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;captcha.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载文件</span></span><br><span class="line">Mono&lt;ClientResponse&gt; resp = WebClient.create().get()</span><br><span class="line">        .uri(<span class="string">&quot;http://localhost:8080/file/download&quot;</span>)</span><br><span class="line">        .accept(MediaType.APPLICATION_OCTET_STREAM)</span><br><span class="line">        .exchange();</span><br><span class="line"><span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> resp.block();</span><br><span class="line"><span class="type">String</span> <span class="variable">disposition</span> <span class="operator">=</span> response.headers().asHttpHeaders().getFirst(HttpHeaders.CONTENT_DISPOSITION);</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> disposition.substring(disposition.indexOf(<span class="string">&quot;=&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> response.bodyToMono(Resource.class).block();</span><br><span class="line"><span class="type">File</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">FileUtils.copyInputStreamToFile(resource.getInputStream(),out);</span><br><span class="line">LOGGER.info(out.getAbsolutePath());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>异步调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = request.retrieve().bodyToFlux(String.class);</span><br><span class="line"><span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flux.subscribe(tweet -&gt; &#123;</span><br><span class="line">    <span class="comment">//如果jvm结束了，就不能显示了</span></span><br><span class="line">    System.out.println(tweet.toString());</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;result:exit&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取响应头信息</p>
<ul>
<li>前面介绍的示例都是直接获取到了响应的内容，可能你会想获取到响应的头信息、Cookie等。那就可以在通过WebClient请求时把调用<code>retrieve()</code>改为调用<code>exchange()</code>，这样可以访问到代表响应结果的<code>org.springframework.web.reactive.function.client.ClientResponse</code>对象，通过它可以获取响应的状态码、Cookie等。下面的代码先是模拟用户进行了一次表单的登录操作，通过ClientResponse获取到了登录成功后的写入Cookie的sessionId，然后继续请求了用户列表。在请求获取用户列表时传递了存储了sessionId的Cookie。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;u123&quot;</span>);</span><br><span class="line">map.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;p123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;ClientResponse&gt; mono = webClient.post().uri(<span class="string">&quot;login&quot;</span>).syncBody(map).exchange();</span><br><span class="line"><span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> mono.block();</span><br><span class="line"><span class="keyword">if</span> (response.statusCode() == HttpStatus.OK) &#123;</span><br><span class="line">    Mono&lt;Result&gt; resultMono = response.bodyToMono(Result.class);</span><br><span class="line">    resultMono.subscribe(result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">            <span class="type">ResponseCookie</span> <span class="variable">sidCookie</span> <span class="operator">=</span> response.cookies().getFirst(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">            Flux&lt;User&gt; userFlux = webClient.get().uri(<span class="string">&quot;users&quot;</span>).cookie(sidCookie.getName(), sidCookie.getValue()).retrieve().bodyToFlux(User.class);</span><br><span class="line">            userFlux.subscribe(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>WebClient.Builder</p>
<ul>
<li>除了可以通过<code>WebClient.create()</code>创建WebClient对象外，还可以通过<code>WebClient.builder()</code>创建一个<code>WebClient.Builder</code>对象，再对Builder对象进行一些配置后调用其<code>build()</code>创建WebClient对象。下面的代码展示了其用法，配置了baseUrl和默认的cookie信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder().baseUrl(baseUrl).defaultCookie(<span class="string">&quot;cookieName&quot;</span>, <span class="string">&quot;cookieValue&quot;</span>).build();</span><br><span class="line"><span class="comment">//使用WebClient构建器，可以自定义选项：包括过滤器、默认标题、cookie、客户端连接器等</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">        .defaultHeader(HttpHeaders.CONTENT_TYPE, <span class="string">&quot;application/vnd.github.v3+json&quot;</span>)</span><br><span class="line">        .defaultHeader(HttpHeaders.USER_AGENT, <span class="string">&quot;Spring 5 WebClient&quot;</span>)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<ul>
<li>Builder还可以通过<code>clientConnector()</code>定义需要使用的ClientHttpConnector，默认将使用<code>org.springframework.http.client.reactive.ReactorClientHttpConnector</code>，其底层是基于netty的，如果你使用的是Maven，需要确保你的pom.xml中定义了如下依赖。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.projectreactor.ipc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.7</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果对默认的发送请求和处理响应结果的编解码不满意，还可以通过exchangeStrategies()定义使用的ExchangeStrategies。ExchangeStrategies中定义了用来编解码的对象，其也有对应的build()方法方便我们来创建ExchangeStrategies对象。</p>
<p><em>WebClient也提供了Filter，对应于org.springframework.web.reactive.function.client.ExchangeFilterFunction接口，其接口方法定义如下。</em></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mono&lt;ClientResponse&gt; <span class="title function_">filter</span><span class="params">(ClientRequest request, ExchangeFunction next)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在进行拦截时可以拦截request，也可以拦截response。下面的代码定义的Filter就拦截了request，给每个request都添加了一个名为header1的header，值为value1。它也拦截了response，response中也是添加了一个新的header信息。拦截response时，如果新的ClientResponse对象是通过<code>ClientResponse.from(response)</code>创建的，新的response是不会包含旧的response的body的，如果需要可以通过<code>ClientResponse.Builder</code>的<code>body()</code>指定，其它诸如header、cookie、状态码是会包含的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder().baseUrl(baseUrl).filter((request, next) -&gt; &#123;</span><br><span class="line">    <span class="type">ClientRequest</span> <span class="variable">newRequest</span> <span class="operator">=</span> ClientRequest.from(request).header(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;value1&quot;</span>).build();</span><br><span class="line">    Mono&lt;ClientResponse&gt; responseMono = next.exchange(newRequest);</span><br><span class="line">    <span class="keyword">return</span> Mono.fromCallable(() -&gt; &#123;</span><br><span class="line">        <span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> responseMono.block();</span><br><span class="line">        <span class="type">ClientResponse</span> <span class="variable">newResponse</span> <span class="operator">=</span> ClientResponse.from(response).header(<span class="string">&quot;responseHeader1&quot;</span>, <span class="string">&quot;Value1&quot;</span>).build();</span><br><span class="line">        <span class="keyword">return</span> newResponse;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure>
<ul>
<li>如果定义的Filter只期望对某个或某些request起作用，可以在Filter内部通过request的相关属性进行拦截，比如cookie信息、header信息、请求的方式或请求的URL等。也可以通过<code>ClientRequest.attribute(attrName)</code>获取某个特定的属性，该属性是在请求时通过<code>attribute(&quot;attrName&quot;, &quot;attrValue&quot;)</code>指定的。这跟在HttpServletRequest中添加的属性的作用范围是类似的。</li>
</ul>
</li>
<li>
<p>配置连接池，超时时间等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ReactorResourceFactory <span class="title function_">resourceFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReactorResourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReactorResourceFactory</span>();</span><br><span class="line">        factory.setUseGlobalResources(<span class="literal">false</span>);</span><br><span class="line">        factory.setConnectionProvider(ConnectionProvider.fixed(<span class="string">&quot;httpClient&quot;</span>, <span class="number">50</span>, <span class="number">10</span>));</span><br><span class="line">        factory.setLoopResources(LoopResources.create(<span class="string">&quot;httpClient&quot;</span>, <span class="number">50</span>, <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebClient <span class="title function_">webClient</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;HttpClient, HttpClient&gt; mapper = client -&gt;</span><br><span class="line">                client.tcpConfiguration(c -&gt;</span><br><span class="line">                        c.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">10</span>)</span><br><span class="line">                                .option(TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                                .doOnConnected(conn -&gt; &#123;</span><br><span class="line">                                    conn.addHandlerLast(<span class="keyword">new</span> <span class="title class_">ReadTimeoutHandler</span>(<span class="number">10</span>));</span><br><span class="line">                                    conn.addHandlerLast(<span class="keyword">new</span> <span class="title class_">WriteTimeoutHandler</span>(<span class="number">10</span>));</span><br><span class="line">                                &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="type">ClientHttpConnector</span> <span class="variable">connector</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReactorClientHttpConnector</span>(resourceFactory(), mapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> WebClient.builder().clientConnector(connector).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3、参考">3、参考</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueWlpYmFpLmNvbS9qc291cC9qc291cC1xdWljay1zdGFydC5odG1s">JSoup快速入门 - JSoup教程™ (yiibai.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ3Jhc3AvcC8xMjE3OTkwNi5odG1s">Spring的WebClient基本使用 - xuanm - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合知识点整理</title>
    <url>/posts/58728.html</url>
    <content><![CDATA[<p>本文整理了，Java集合相关的知识点和面试题。</p>
<span id="more"></span>
<h3 id="概述">概述</h3>
<h4 id="什么是集合？">什么是集合？</h4>
<p>用于存储数据的容器</p>
<h4 id="和数组的区别？">和数组的区别？</h4>
<ul>
<li>长度：数组固定，集合可变长度。</li>
<li>存储：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存 储引用数据类型。</li>
</ul>
<h4 id="集合的优势">集合的优势</h4>
<ul>
<li>容量自增长</li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量</li>
<li>允许不同 API 之间的互操作，API之间可以来回传递集合</li>
<li>可以方便地扩展或改写集合，提高代码复用性和可操作性</li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本</li>
</ul>
<h4 id="分类">分类</h4>
<p>Map接口和Collection接口</p>
<p>Map接口实现类：HashMap、TreeMap、Hashtable、 ConcurrentHashMap以及 Properties等。</p>
<p>Collection接口子接口：List、Set和Queue</p>
<p>List接口实现类：ArrayList、LinkedList、Vector和Stack</p>
<p>Queue接口实现类：LinkedList</p>
<p>Set接口实现类：HashSet、TreeSet、LinkedHashSet等</p>
<h4 id="数据结构">数据结构</h4>
<p><strong>List</strong></p>
<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
<p><strong>Set</strong></p>
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现 的。有点类似于我们之前说的LinkedHashMap 其内部是基 于 Hashmap 实现一样，不过还是有一 点点区别的。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。) Ma</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主 体，链表则是主要 为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转 化为红黑树， 以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是 基于拉链式散列结 构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面 结构的基础上，增加了一条双向 链表，使得上面的结构可以保持键值对的插入顺序。 同时通过对链表进行相应的操作，实现了访问 顺序相关逻辑。</li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为 了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h4 id="哪些集合是线程安全的？">哪些集合是线程安全的？</h4>
<ul>
<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已 经不太建议使用。 在web应用中，特别是前台页面，往往效率（页面响应速度）是优 先考虑的。</li>
<li>statck：堆栈类，先进后出。</li>
<li>hashtable：就比hashmap多了个线程安全。</li>
<li>ConcurrentHashMap</li>
</ul>
<h4 id="集合的快速失败机制“fail-fast">集合的快速失败机制“fail-fast&quot;</h4>
<p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 failfast 机制。 例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中 的元素，在某个时候线 程2修改了集合A的结构（是结构上面的修改，而不是简 单的修改集合元素的内容），那么这个时候程序 就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount 的值。每当迭代器使用hashNext()/next()遍历下一 个元素之前，都会检测 modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出 异常，终止遍历。</p>
<p>解决办法：</p>
<ol>
<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>
<li>使用CopyOnWriteArrayList来替换ArrayList</li>
</ol>
<h3 id="Collection面试题">Collection面试题</h3>
<h4 id="List">List</h4>
<h5 id="ArrayList和Vector的区别？">ArrayList和Vector的区别？</h5>
<ul>
<li>ArrayList是List的主要实现类，底层使用Object[]数组存储，线程不安全；</li>
<li>Vector是List的古老实现类，底层使用Object[]存储，线程安全。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
<li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对 象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li>
<li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li>
</ul>
<h5 id="ArrayList和LinkedList的区别？">ArrayList和LinkedList的区别？</h5>
<ul>
<li>
<p>是否保证线程安全： ArrayList和LinkedList都是不同步的、线程不安全的。</p>
</li>
<li>
<p>底层实现： ArrayList底层使用Object[]数组实现，LinkedList底层使用双向链表实现。（jdk1.6之前是双向循环链表，1.6之后取消了循环）。</p>
</li>
<li>
<p>是否支持快速随机访问： ArrayList底层使用数组实现，支持快速访问。而LinkedList底层是链表实现，不支持快速访问。</p>
</li>
<li>
<p>空间内存占用：ArrayList的空间浪费主要体现在list列表结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素存储都需要比ArrayList消耗更多的空间（因为节点要放置前驱和后继）。</p>
</li>
</ul>
<h5 id="System-arraycopy-方法和Arrays-copyOf-方法的区别？">System.arraycopy()方法和Arrays.copyOf()方法的区别？</h5>
<ul>
<li>
<p>通过查看源码我们可以知道，Arrays.copyOf()方法内部调用了System.arraycopy()方法。</p>
</li>
<li>
<p>arraycopy()方法需要目标数组，将原数组拷贝到自定义的数组中或者是原数组，并且可以选择拷贝的起点以及放入新的数组中的位置。copyOf()时系统自动在内部新建一个数组，并返回该数组。</p>
</li>
</ul>
<p>拓展：ArrayList实现了RandomAccess接口，只是作为一个标识，说明ArrayList支持快速随机访问功能。</p>
<h5 id="ensureCapacity-方法的作用？">ensureCapacity()方法的作用？</h5>
<p>ensureCapacity()方法并不是在ArrayList内部调用的，而是提供给用户来使用的，在向ArrayList里面添加大量元素之前最好先使用ensureCapacity方法，以减少增量重新分配的次数，提高效率。</p>
<h5 id="ArrayList是如何扩容的？">ArrayList是如何扩容的？</h5>
<p>当使用无参构造方法直接创建ArrayList集合时，初始化的数组是一个空的数组，只有在add第一个元素时，数组的大小才会初始化为10，直到添加第11个元素时，ArrayList才会进行扩容操作。</p>
<h5 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？">快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h5>
<ul>
<li>
<p>快速失败（fail-fast）<br>
在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改），则会抛出Concurrent Modification Exception.<br>
原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>
注意：这里异常的抛出条件是检测到modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。<br>
场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
</li>
<li>
<p>安全失败（fail-safe）<br>
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>
原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。<br>
缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception,但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的<br>
场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
</li>
</ul>
<h5 id="什么是modCount？它是干啥的？什么时候发生变化？">什么是modCount？它是干啥的？什么时候发生变化？</h5>
<ul>
<li>什么还是modCount
<ul>
<li>modCount这个字段位于java.util.AbstractList抽象类中。</li>
<li>modCount的注释中提到了&quot;fail-fast&quot;机制。</li>
<li>如果子类希望提供&quot;fail-fast&quot;机制，需要在add(int,E)方法和remove(int)方法中对这个字段进行处理。</li>
<li>从第三点我们知道了，在提供了&quot;fail-fast&quot;机制的容器中（比如ArrayList），除了文中示例的remove(Obj)方法会导致ConcurrentModificationException异常，add及其相关方法也会导致异常。</li>
</ul>
</li>
<li>modCount作用？
<ul>
<li>在提供了&quot;fail-fast&quot;机制（不允许并发修改）的集合中，modCount的作用是记录了该集合在使用过程中被修改的次数</li>
</ul>
</li>
<li>什么使用发生变化？
<ul>
<li>拿ArrayList来说，当调用add相关和remove相关方法时，会触发modCount++操作，从而被修改。</li>
</ul>
</li>
</ul>
<h5 id="什么是expectedModCount？它是干啥的？什么时候发生变化？">什么是expectedModCount？它是干啥的？什么时候发生变化？</h5>
<ul>
<li>什么是expectedModCount?
<ul>
<li>expectedModCount是ArrayList中一个名叫Itr内部类的成员变量。</li>
</ul>
</li>
<li>作用？
<ul>
<li>它代表的含义是在这个迭代器中，预期的修改次数</li>
</ul>
</li>
<li>什么时候发生变化？
<ul>
<li>情况一：Itr初始化的时候，会对expectedModCount字段赋初始值，其值等于modCount。</li>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211051153074.jpeg" alt="img"></li>
<li>情况二：调用Itr的remove方法后会再次把modCount的值赋给expectedModCount。
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211051153049.jpeg" alt="img"></li>
</ul>
</li>
<li>换句话说就是：调用迭代器的remove会维护expectedModCount=modCount。<strong>（这句话很关键！！！）</strong></li>
</ul>
</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGhpc2lzd2h5L3AvMTIwNjcwOTMuaHRtbA==">【原创】这道Java基础题真的有坑！我求求你，认真思考后再回答。 - why技术 - 博客园 (cnblogs.com)<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="Set">Set</h4>
<h5 id="HashSet集合特点？">HashSet集合特点？</h5>
<ul>
<li>底层实现的就是HashMap，所以是根据HashCode来判断是否是重复元素。（下面有hashCode的解释）</li>
<li>因为TreeSet要是额外使用红黑树来保证元素的有序性，所以性能相对来说是hashSet的性能是要比TreeSet的性能要好。</li>
<li>初始化容量是：16, 这是因为底层实现的是HashMap。加载因子是0.75</li>
<li>HashSet是无序的，也就是说插入的顺序和取出的顺序是不一样的。</li>
<li>因为HashSet不能根据索引去数据，所以不能用普通的for循环来取出数据，应该用增强for循环。这也进一步说明了HashSet的查询性能肯定是，没有ArrayList的性能高的。</li>
</ul>
<h5 id="TreeSet集合特点？">TreeSet集合特点？</h5>
<ul>
<li>底层是实现的TreeMap。</li>
<li>元素不能够重复，可以有一个null值，并且这个null值一直在第一个位置上。</li>
<li>默认容量：16，加载因子是0.75</li>
<li>TreeMap是有序的，这个有序不是存入的和取出的顺序是一样的，而是根据自然规律拍的序。</li>
</ul>
<h5 id="Set集合如何去重的？">Set集合如何去重的？</h5>
<p>这是因为用到了HashCode()和equals()。这两个方法决定的。</p>
<p>步骤：</p>
<ul>
<li>首先获得该元素的hash值，然后在hash表中找此值下面有没有元素，如果没有则表示不是重复元素可以添加，反之不可以添加。</li>
<li>如果重复则还要用equals()比下是否一样，如果和在hash值下面的所有元素都比较后，发现没有一样的，则可以添加，反之不可以添加。</li>
<li>也就是说Hash值一样的元素，不一定相等，但是equals相同的元素Hash值一定相等。</li>
</ul>
<h3 id="Map面试题">Map面试题</h3>
<h4 id="HashMap">HashMap</h4>
<h5 id="特性？">特性？</h5>
<ul>
<li>HashMap存储键值对实现快速存取，允许为null。key值不可重复，若key值重复则覆盖</li>
<li>非同步，线程不安全。</li>
<li>底层是hash表，不保证有序(比如插入的顺序)</li>
</ul>
<h5 id="版本区别">版本区别</h5>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK1.7</th>
<th>JDK1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组+链表</td>
<td>数组+链表+红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：inflateTable()</td>
<td>直接集成到了扩容函数resize()中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理=9次扰动=4次位运算+5次异或运算</td>
<td>扰动处理=2次扰动=1次位运算+1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>无冲突时，存放数组；冲突&amp;链表长度&lt;8:存放单链表；冲突&amp;链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1后，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法</td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzM4MjkxNjI=">图解：什么是红黑树？ - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="谈一下HashMap中put是如何实现的？">谈一下HashMap中put是如何实现的？</h5>
<ul>
<li>根据key经过Hash算法得到值，做为key的hash值</li>
<li>判断数组是否为空，如果为空则进行resize()扩容</li>
<li>根据key的hash值计算数组的索引值</li>
<li>判断该索引下的数组中是否有值
<ul>
<li>如果为null，则创建Node对象</li>
<li>如果有值：
<ul>
<li>判断equals后内容是否相同：
<ul>
<li>如果相同则替换旧值</li>
<li>如果不同，则判断是否为红黑树
<ul>
<li>是，则直接在树种插入键值</li>
<li>否，则遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
</ul>
</li>
</ul>
</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了 大容量threshold，如果超过，进行扩容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="谈一下HashMap中get是如何实现的？">谈一下HashMap中get是如何实现的？</h5>
<ul>
<li>1.对key的hashCode()做hash运算，计算index;</li>
<li>2.如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；</li>
<li>3.如果有冲突，先判断是否树化
<ul>
<li>若已经树化，则调用红黑树的getTreeNode()进行查找，O(logn)。</li>
<li>若没有树化，则从前往后遍历链表，找到了则返回节点，找不到则返回null，O(n)。</li>
</ul>
</li>
</ul>
<h5 id="谈一下HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？">谈一下HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</h5>
<ul>
<li>
<p>对key的hashCode做hash操作，与高16位做异或运算</p>
</li>
<li>
<p>还有平方取中法，除留余数法，伪随机数法</p>
</li>
</ul>
<h5 id="为什么不直接将key作为哈希值而是与高16位做异或运算？">为什么不直接将key作为哈希值而是与高16位做异或运算？</h5>
<ul>
<li>
<p>因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&amp;运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。</p>
</li>
<li>
<p>HashMap默认初始化长度为16，并且每次自动扩展或者是手动初始化容量时，必须是2的幂。</p>
</li>
</ul>
<h5 id="为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？">为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？</h5>
<ul>
<li>为了数据的均匀分布，减少哈希碰撞。因为确定数组位置是用的位运算，若数据不是2的次幂则会增加哈希碰撞的次数和浪费数组空间。(PS:其实若不考虑效率，求余也可以就不用位运算了也不用长度必需为2的幂次)</li>
<li>输入数据若不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字</li>
</ul>
<h4 id="ConcurrentHashMap">ConcurrentHashMap</h4>
<h5 id="与HashMap区别">与HashMap区别</h5>
<ul>
<li>HashMap不支持并发操作，没有同步方法，ConcurrentHashMap支持并发操作，通过继承 ReentrantLock（JDK1.7重入锁）/CAS和synchronized(JDK1.8内置锁)来进行加锁（分段锁），每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</li>
<li>JDK1.8之前HashMap的结构为数组+链表，JDK1.8之后HashMap的结构为数组+链表+红黑树；JDK1.8之前ConcurrentHashMap的结构为segment数组+数组+链表，JDK1.8之后ConcurrentHashMap的结构为数组+链表+红黑树。</li>
</ul>
<h5 id="与HashTable区别">与HashTable区别</h5>
<ul>
<li>
<p>底层数据结构：</p>
<ul>
<li>JDK1.7 的 ConcurrentHashMap 底层采用 <code>分段数组+链表</code> 实现，而 JDK1.8 的 ConcurrentHashMap 实现跟 HashMap1.8 的数据结构一样，都是 <code>数组+链表/红黑二叉树</code>。</li>
<li>Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似，都是采用 <code>数组+链表</code> 的形式。数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在的；</li>
</ul>
</li>
<li>
<p>实现线程安全的方式：</p>
<ul>
<li>① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段( Segment )，每一把锁只锁<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L3RrZT9mcm9tPTEwNjgw">容器<i class="fa fa-external-link-alt"></i></span>其中的一部分数据，这样多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高了并发访问率。
<ul>
<li>到了 JDK1.8，摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，（JDK1.6 以后对 synchronized 锁做了很多的优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
</ul>
</li>
<li>② Hashtable (同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。一个线程访问同步方法时，当其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程就不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈，效率就越低。</li>
</ul>
</li>
</ul>
<h5 id="JDK8的ConcurrentHashMap和JDK7的ConcurrentHashMap有什么区别？">JDK8的ConcurrentHashMap和JDK7的ConcurrentHashMap有什么区别？</h5>
<ul>
<li>JDK8中新增了红黑树</li>
<li>JDK7中使用的是头插法，JDK8中使用的是尾插法</li>
<li>JDK7中使用了分段锁，而JDK8中使用 synchronized 和 CAS 来进行并发控制</li>
<li>JDK7中使用了ReentrantLock，JDK8中没有使用ReentrantLock了，而使用了Synchronized</li>
<li>JDK7中的扩容是每个Segment内部进行扩容，不会影响其他Segment，而JDK8中的扩容和HashMap的扩容类似，只不过支持了多线程扩容，并且保证了线程安全</li>
</ul>
<h5 id="ConcurrentHashMap是如何保证并发安全的？">ConcurrentHashMap是如何保证并发安全的？</h5>
<p>JDK7中ConcurrentHashMap是通过ReentrantLock+CAS+分段思想来保证的并发安全的，ConcurrentHashMap的put方法会通过CAS的方式，把一个Segment对象存到Segment数组中，一个Segment内部存在一个HashEntry数组，相当于分段的HashMap，Segment继承了ReentrantLock，每段put开始会加锁。</p>
<p>在JDK7的ConcurrentHashMap中，首先有一个Segment数组，存的是Segment对象，Segment相当于一个小HashMap，Segment内部有一个HashEntry的数组，也有扩容的阈值，同时Segment继承了ReentrantLock类，同时在Segment中还提供了put，get等方法，比如Segment的put方法在一开始就会去加锁，加到锁之后才会把key,value存到Segment中去，然后释放锁。同时在ConcurrentHashMap的put方法中，会通过CAS的方式把一个Segment对象存到Segment数组的某个位置中。同时因为一个Segment内部存在一个HashEntry数组，所以和HashMap对比来看，相当于分段了，每段里面是一个小的HashMap，每段公用一把锁，同时在ConcurrentHashMap的构造方法中是可以设置分段的数量的，叫做并发级别concurrencyLevel.</p>
<p>JDK8中ConcurrentHashMap是通过synchronized+cas来实现了。在JDK8中只有一个数组，就是Node数组，Node就是key，value，hashcode封装出来的对象，和HashMap中的Entry一样，在JDK8中通过对Node数组的某个index位置的元素进行同步，达到该index位置的并发安全。同时内部也利用了CAS对数组的某个位置进行并发安全的赋值。</p>
<h5 id="JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？">JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？</h5>
<p>JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p>
<p>想比于JDK7中使用ReentrantLock来加锁，因为JDK7中使用了分段锁，所以对于一个ConcurrentHashMap对象而言，分了几段就得有几个ReentrantLock对象，表示得有对应的几把锁。</p>
<p>而JDK8中使用synchronized关键字来加锁就会更节省内存，并且jdk也已经对synchronized的底层工作机制进行了优化，效率更好。</p>
<h5 id="JDK7中的ConcurrentHashMap是如何扩容的？">JDK7中的ConcurrentHashMap是如何扩容的？</h5>
<p>JDK7中的ConcurrentHashMap和JDK7的HashMap的扩容是不太一样的，首先JDK7中也是支持多线程扩容的，原因是，JDK7中的ConcurrentHashMap分段了，每一段叫做Segment对象，每个Segment对象相当于一个HashMap，分段之后，对于ConcurrentHashMap而言，能同时支持多个线程进行操作，前提是这些操作的是不同的Segment，而ConcurrentHashMap中的扩容是仅限于本Segment，也就是对应的小型HashMap进行扩容，所以是可以多线程扩容的。</p>
<p>每个Segment内部的扩容逻辑和HashMap中一样。</p>
<h5 id="JDK8中的ConcurrentHashMap是如何扩容的？">JDK8中的ConcurrentHashMap是如何扩容的？</h5>
<p>首先，JDK8中是支持多线程扩容的，JDK8中的ConcurrentHashMap不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在put，那么这个put线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的Node信息去生成一个新的Node的，也就是原数组上的Node不会消失，因为在扩容的过程中，如果有其他线程在get也是可以的。</p>
<h5 id="JDK8中的ConcurrentHashMap有一个CounterCell，你是如何理解的？">JDK8中的ConcurrentHashMap有一个CounterCell，你是如何理解的？</h5>
<p>CounterCell是JDK8中用来统计ConcurrentHashMap中所有元素个数的，在统计ConcurentHashMap时，不能直接对ConcurrentHashMap对象进行加锁然后再去统计，因为这样会影响ConcurrentHashMap的put等操作的效率，在JDK8的实现中使用了CounterCell+baseCount来辅助进行统计，baseCount是ConcurrentHashMap中的一个属性，某个线程在调用ConcurrentHashMap对象的put操作时，会先通过CAS去修改baseCount的值，如果CAS修改成功，就计数成功，如果CAS修改失败，则会从CounterCell数组中随机选出一个CounterCell对象，然后利用CAS去修改CounterCell对象中的值，因为存在CounterCell数组，所以，当某个线程想要计数时，先尝试通过CAS去修改baseCount的值，如果没有修改成功，则从CounterCell数组中随机取出来一个CounterCell对象进行CAS计数，这样在计数时提高了效率。</p>
<p>所以ConcurrentHashMap在统计元素个数时，就是baseCount加上所有CountCeller中的value值，所得的和就是所有的元素个数。</p>
<h4 id="HashTable">HashTable</h4>
<h5 id="HashTable与HashMap对比">HashTable与HashMap对比</h5>
<p>（1）线程安全：HashMap是线程不安全的类，多线程下会造成并发冲突，但单线程下运行效率较高；HashTable是线程安全的类，很多方法都是用synchronized修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；</p>
<p>（2）插入null：HashMap允许有一个键为null，允许多个值为null；但HashTable不允许键或值为null；</p>
<p>（3）容量：HashMap底层数组长度必须为2的幂，这样做是为了hash准备，默认为16；而HashTable底层数组长度可以为任意值，这就造成了hash算法散射不均匀，容易造成hash冲突，默认为11；</p>
<p>（4）Hash映射：HashMap的hash算法通过非常规设计，将底层table长度设计为2的幂，使用位与运算代替取模运算，减少运算消耗；而HashTable的hash算法首先使得hash值小于整型数最大值，再通过取模进行散射运算；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下标index运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (table.length - <span class="number">1</span>) &amp; hash(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashTable</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure>
<p>（5）扩容机制：HashMap创建一个为原先2倍的数组，然后对原数组进行遍历以及rehash；HashTable扩容将创建一个原长度2倍的数组，再使用头插法将链表进行反序；</p>
<p>（6）结构区别：HashMap是由数组+链表形成，在JDK1.8之后链表长度大于8时转化为红黑树；而HashTable一直都是数组+链表；</p>
<p>（7）继承关系：HashTable继承自Dictionary类；而HashMap继承自AbstractMap类；</p>
<p>（8）迭代器：HashMap是fail-fast（查看之前HashMap相关文章）；而HashTable不是。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/posts/5303.html</url>
    <content><![CDATA[<p>——摘录自《MySQL是怎样运行的》</p>
<span id="more"></span>
<h3 id="1、字符集和比较规则">1、字符集和比较规则</h3>
<h4 id="1-1、字符集简介">1.1、字符集简介</h4>
<p>字符集是人们抽象出来一个字符集的概念来描述某个字符范围的编码规则，简单的来说就是在某个范围的字符建立与二进制数据的映射关系（编码规则）。</p>
<h4 id="1-2、比较规则简介">1.2、比较规则简介</h4>
<p>对某个字符集中比较大小的规则。比如字符’a‘的编码为0x01,字符’b‘的编码为0x02，所以’a’小于’b’。这种简单的比较规则也可以称为二进制比较规则。但在很多场合下，英文字符都是不区分大小写额，也就是’a’和‘A’是相等的。此时就不可以简单粗暴地使用二进制比较规则，此时可以这样指定比较规则：</p>
<ul>
<li>将两个大小写不同的字符都转为大写或者小写。</li>
<li>再比较这两个字符对应的二进制数据。</li>
</ul>
<h4 id="1-3、常见的字符集">1.3、常见的字符集</h4>
<ul>
<li>ASCII字符集（1字节）：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于该字符集总共才128个字符，所以可以使用一个字节来进行编码。
<ul>
<li>‘L’ -&gt;01001100(十六进制0x4C，十进制76)</li>
<li>‘M’ -&gt;01001101(十六进制0x4D，十进制77)</li>
</ul>
</li>
<li>ISO 8859-1字符集：共收录256个字符，它在ASCII字符集的基础上又扩充了128个西欧常用字符（包括德法两国的字母）。ISO 8859-1字符集也可以使用一个字节来进行编码。</li>
<li>GB2312字符集（1-2字节）：共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时，GB 2312收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。整个字符集分成94个区，每区有94个位。这种字符集兼容ASCII字符集，在编码方式有些特别之处：如果字符在ASCII字符集中，则采用一字节编码；否则采用两字节编码
<ul>
<li>GB2312，又称为GB0，由中国国家标准总局发布，1981年5月1日实施</li>
<li>GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个</li>
<li>GB2312是一种区位码。分为94个区(01-94)，每区94个字符(01-94)</li>
<li>01-09区为特殊符号</li>
<li>10-15区没有编码</li>
<li>16-55区为一级汉字，按拼音排序，共3755个</li>
<li>56-87区为二级汉字，按部首／笔画排序，共3008个</li>
<li>88-94区没有编码</li>
<li>GB2312只是编码表，在计算机中通常都是用&quot;EUC-CN&quot;表示法，即在每个区位加上0xA0来表示。区和位分别占用一个字节。</li>
</ul>
</li>
<li>GBK字符集：在收录的字符范围上对GB2312字符集进行了扩充，编码方式兼容GB2312字符集。</li>
<li>UTF-8字符集：编码规则：
<ul>
<li>一个US-ASCIl字符只需1字节编码（Unicode范围由U+0000~U+007F）。</li>
<li>带有变音符号的拉丁文、希腊文、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQTUlQkYlRTklODclOEMlRTUlQjAlOTQlRTUlQUQlOTclRTYlQUYlOEQvMTEwNTg0MDY=">西里尔字母<i class="fa fa-external-link-alt"></i></span>、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文等字母则需要2字节编码（Unicode范围由U+0080~U+07FF）。</li>
<li>其他语言的字符（包括中日韩文字、东南亚文字、中东文字等）包含了大部分常用字，使用3字节编码。</li>
<li>其他极少使用的语言字符使用4字节编码。</li>
</ul>
</li>
</ul>
<h4 id="1-4、MySQL中的utf8和utf8mb4">1.4、MySQL中的utf8和utf8mb4</h4>
<ul>
<li>utf8mb3：“阉割”过的utf-8字符集，使用1~3字节表示字符</li>
<li>utf8mb4：正宗的utf-8字符集，使用1~4字节表示字符</li>
</ul>
<p>在mysql中，utf8是utf8mb3的别名，如果需要存储特殊的字符，可以使用4字符编码的utf8mb4</p>
<h4 id="1-5、MySQL中的字符集和比较规则">1.5、MySQL中的字符集和比较规则</h4>
<h5 id="查看当前mysql支持的字符集">查看当前mysql支持的字符集</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> charset <span class="keyword">like</span> <span class="string">&#x27;utf8%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511172235587.png" alt="image-20220511172235587"></p>
<p>Charset:字符集名称<br>
Default_collation:默认的比较规则<br>
Maxlen:最大长度,utf8字符长度为1-3所以MaxLen为3 utf8mb4字符长度1-4所以Maxlen为4</p>
<h5 id="查看当前mysql中支持的比较规则">查看当前mysql中支持的比较规则</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">collation</span> <span class="keyword">like</span> <span class="string">&#x27;utf8%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511172428267.png" alt="image-20220511172428267"></p>
<p>Default:是否是当前字符集默认的比较规则<br>
Complied:是否将字符集编译到了server中<br>
Sortlen:与比较字符串在内存中需要的内存量有关</p>
<p>utf8_str1_str2<br>
str1代表着比较规则所使用的的语言,比如 utf8_polish_xx表示波兰语的比较规则<br>
str2代表着如何比较.<br>
通常情况下我们会使用的是utf8_general_ci与utf8_bin,前者代表着不区分大小写,后者代表着区分大小写</p>
<h5 id="字符集与比较规则的分类">字符集与比较规则的分类</h5>
<p>按照应用级别可以分为服务器级别 数据库级别 表级别 列级别</p>
<p><strong>服务器级别</strong></p>
<p>字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">默认: utf8</span><br></pre></td></tr></table></figure>
<p>比较规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_server&#x27;</span>;</span><br><span class="line">默认: utf8_general_ci</span><br></pre></td></tr></table></figure>
<p><strong>数据库级别</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">默认: utf8</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_database&#x27;</span>;</span><br><span class="line">默认:utf8_general_ci</span><br></pre></td></tr></table></figure>
<p>创建数据库时指定:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database xxx [<span class="type">character</span> <span class="keyword">set</span>  <span class="string">&#x27;字符集名&#x27;</span> <span class="keyword">collate</span> <span class="string">&#x27;比较规则名称&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>表级别</strong></p>
<p>表级别没有专门变量表示<br>
创建数据表时指定:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx (xxx) [<span class="type">character</span> <span class="keyword">set</span> 字符集名 <span class="keyword">collate</span> 比较规则名称]</span><br></pre></td></tr></table></figure>
<p><strong>列级别</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx (</span><br><span class="line">id <span class="type">int</span> [<span class="type">character</span> <span class="keyword">set</span> 字符集名称] [<span class="keyword">collate</span> 比较规则名称]</span><br><span class="line">) [<span class="type">character</span> <span class="keyword">set</span>  字符集名 <span class="keyword">collate</span> 比较规则名称]</span><br></pre></td></tr></table></figure>
<p>如果列级别没有设置字符集与比较规则,则使用表的,如果表没有设置,则使用数据库的,如果数据库没有设置则使用服务器的.</p>
<p><strong>mysql通信中的字符集与比较规则</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511173659500.png" alt="image-20220511173659500"><br>
<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511173739019.png" alt="image-20220511173739019"></p>
<p><strong>character_set_client(服务端收到请求)</strong></p>
<p>此变量session级<br>
当我们用客户端与服务端通信时,<code>character_set_client</code>指的是,服务端以什么字符集去理解客户端发送过来的请求,默认是当前操作系统字符集.在当前seesion中,此变量为<code>utf8</code>,如果设置成<code>gbk</code>,会导致<code>select '我'</code>会乱码,因为服务端会把从服务端收到的以utf8编码的’我’使用gbk解码,所以会乱码,.</p>
<p><strong>character_set_connection(服务端处理请求)</strong></p>
<p>此变量session级<br>
当服务器将’我’通过character_set_client正确解码后,会按照character_set_connection进行编码,然后按照collation_connection比较规则进行比较,但是如果查询中有列比如<code>select '我'=name from aaa</code>此时会优先采用name列的字符集与比较规则进行判断</p>
<p><strong>character_set_results(服务端响应请求)</strong></p>
<p>此变量session级<br>
服务器将要响应的数据以什么格式进行编码,比如<code>select name from aaa</code> name是以utf8编码的,character_set_results是gbk编码,那么会把查询的结果以gbk编码对客户端响应</p>
<p><strong>客户端接收请求</strong></p>
<p>客户端接收响应的请求后,会以什么编码的方式显示出来,默认就是当前系统的字符集</p>
<h3 id="2、InnoDB记录存储结构">2、InnoDB记录存储结构</h3>
<h4 id="2-1、InnoDB页简介">2.1、InnoDB页简介</h4>
<p>页是Innodb中磁盘和内存交互的基本单位，也是Innodb管理存储空间的基本单位，默认大小为16KB。</p>
<h4 id="2-2、InnoDB行格式">2.2、InnoDB行格式</h4>
<p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。InnoDB存储引擎设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式。</p>
<h4 id="2-3、行记录格式的分类和介绍">2.3、行记录格式的分类和介绍</h4>
<p>在早期的InnoDB版本中，由于文件格式只有一种，因此不需要为此文件格式命名。随着InnoDB引擎的发展，开发出了不兼容早期版本的新文件格式，用于支持新的功能。为了在升级和降级情况下帮助管理系统的兼容性，以及运行不同的MySQL版本，InnoDB开始使用命名的文件格式。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b2caf96f361aa29ff2cd1bb511c638a0.png" alt="MySQL怎么从二进制内容看InnoDB行格式"></p>
<p>在msyql 5.7.9及以后版本，默认行格式由innodb_default_row_format变量决定，它的默认值是dynamic</p>
<h4 id="2-4、行格式">2.4、行格式</h4>
<h5 id="COMPACT">COMPACT</h5>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b93590226e885d956bfd5a96887c3fd7.png" alt="MySQL怎么从二进制内容看InnoDB行格式"></p>
<p><strong>变长字段列表</strong></p>
<p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，我们也可以把拥有这些数据类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。如果该可变字段允许存储的最大字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节记录，否则使用1个字节记录。</p>
<p>问题一：那么为什么用128作为分界线呢？ 一个字节可以最多表示255，但是MySQL设计长度表示时，为了区分是否是一个字节表示长度，规定，如果最高位为1，那么就是两个字节表示长度，否则就是一个字节。例如，01111111，这个就代表长度为127，而如果长度是128，就需要两个字节，就是10000000 10000000，首个字节的最高位为1，那么这就是两个字节表示长度的开头，第二个字节可以用所有位表示长度，并且需要注意的是，MySQL采取Little Endian的计数方式，低位在前，高位在后，所以129就是10000001 10000000。同时，这种标识方式，最大长度就是 2^15-1=32767，也就是32KB。</p>
<p>问题二：如果两个字节也不够表示的长度，该怎么办？ innoDB页大小默认为16KB，对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。这个溢出页机制参考后面的数据溢出。</p>
<p><strong>NULL值列表</strong></p>
<p>表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表。每个允许存储NULL的列对应一个二进制位，二进制位的值为1时，代表该列的值为NULL。二进制位的值为0时，代表该列的值不为NULL。</p>
<p><strong>记录头信息</strong></p>
<p>用于描述记录的记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（bit）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在页的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0 表示普通记录，1 表示B+树非叶子节点记录，2 表示最小记录，3 表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<p><strong>隐藏列</strong></p>
<p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），包括：</p>
<ul>
<li>DB_ROW_ID(row_id)：非必须，6字节，表示行ID，唯一标识一条记录</li>
<li>DB_TRX_ID：必须，6字节，表示事务ID</li>
<li>DB_ROLL_PTR：必须，7字节，表示回滚指针</li>
</ul>
<p>InnoDB表对主键的生成策略是：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique 键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。</p>
<p>DB_TRX_ID（也可以称为trx_id） 和DB_ROLL_PTR（也可以称为roll_ptr） 这两个列是必有的，但是row_id是可选的（在没有自定义主键以及Unique 键的情况下才会添加该列）。</p>
<p>其他的行格式和Compact行格式差别不大。</p>
<h5 id="Redundant行格式">Redundant行格式</h5>
<p>Redundant行格式是MySQL5.0之前用的一种行格式，不予深究。</p>
<h5 id="Dynamic行格式">Dynamic行格式</h5>
<p>MySQL5.7的默认行格式就是Dynamic，Dynamic行格式和Compact行格式挺像，只不过在处理行溢出数据时有所不同。</p>
<h5 id="Compressed行格式">Compressed行格式</h5>
<p>Compressed行格式在Dynamic行格式的基础上会采用压缩算法对页面进行压缩，以节省空间。以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度数据能够进行有效的存储（减少40%，但对CPU要求更高）。</p>
<h5 id="数据溢出">数据溢出</h5>
<p>如果我们定义一个表，表中只有一个VARCHAR字段，如下：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">CREATE</span> <span class="variable">TABLE</span> <span class="function"><span class="title">test_varchar</span>( <span class="variable">c</span> <span class="title">VARCHAR</span>(<span class="number">60000</span>))</span></span><br></pre></td></tr></table></figure>
<p>然后往这个字段插入60000个字符，会发生什么？前边说过，MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的情况。</p>
<p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的该列的前768个字节的数据，然后把剩余的数据分散存储在几个其他的页中，记录的真实数据处用20个字节（768字节后20个字节）存储指向这些页的地址。这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。</p>
<p>Dynamic和Compressed行格式，不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p>
<h3 id="3、InnoDB的数据页">3、InnoDB的数据页</h3>
<h4 id="3-1-概念-分类">3.1 概念&amp;分类</h4>
<h5 id="概念"><strong>概念</strong></h5>
<p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB，查看命令如下（单位是字节）：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; show status like &#x27;innodb_page_size&#x27;;</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name    | Value |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Innodb_page_size | 16384 |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以把「页」理解为一个容器，这个容器是用来存储「记录」的。</p>
<h5 id="分类-2"><strong>分类</strong></h5>
<p>值得注意的是，InnoDB 中的「页」并非只有一种，比如有存放 Insert Buffer 的页、存放 undo log 的页、存放数据的页等等。其中我们最关注的还是存放我们表数据的页，又称「索引页」，或者数据页。</p>
<p>下面分析和介绍数据页。</p>
<h4 id="3-2-数据页结构">3.2 数据页结构</h4>
<h5 id="概述-2"><strong>概述</strong></h5>
<p>InnoDB 数据页的结构如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-c5c9a86badc7f63ef4aa8cbf737e18cb_720w.jpg" alt="img"></p>
<p>它由七部分构成，简介如下：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-62671ca47bbd785000cd4fbdfd5b52e8_720w.jpg" alt="img"></p>
<h5 id="记录插入过程"><strong>记录插入过程</strong></h5>
<p>在数据页中，当记录为空时，User Records 是不存在的。随着记录的一条条插入，会不断从 Free Space 开辟空间分配给记录，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-f0e154fa8e3f1b18d9d7650223735763_720w.jpg" alt="img"></p>
<h5 id="页结构分析"><strong>页结构分析</strong></h5>
<p><strong>记录头信息</strong></p>
<p>为便于描述记录是如何在页中存储的，这里先贴一下前文提到的记录头信息：</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-dab1c35a4ec043e0528b7f965ba58e39_720w.jpg" alt="img"></p>
<p>它们的各个部分说明如下：</p>
<ul>
<li>
<p>前两个预留位：暂无用处（各占 1 位）</p>
</li>
<li>
<p>delete_mask：1 位，标记该条记录是否被删除</p>
</li>
<li>
<p>min_rec_mask：1位，B+树每层非叶子节点中的最小记录都会添加该标记</p>
</li>
<li>
<p>n_owned：4 位，当前记录拥有的记录数</p>
</li>
<li>
<p>heap_no：13 位，当前记录在记录堆的位置</p>
</li>
<li>
<p>record_type：3 位，记录的类型</p>
</li>
<li>
<p>0：普通记录•  1：B+ 树非叶子节点（后文再介绍，暂时略过）•  2：最小记录•  3：最大记录</p>
</li>
<li>
<p>next_record：16 位，保存下一条记录的相对位置</p>
</li>
<li>
<p>Infimum + Supremum</p>
</li>
</ul>
<p>这部分存储的是固定的两条记录，分别为数据页中的「最小记录」和「最大记录」，如图所示：</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-14d15dc7eee612a0c2ade452a443dd99_720w.jpg" alt="img"></p>
<p>PS: 由于这两条记录不是我们自定义的，因此不存储在 User Records 空间。</p>
<p><strong>Free Space</strong></p>
<p>空闲空间，数据页中尚未使用的部分。</p>
<p><strong>User Records</strong></p>
<p>用户记录，这里就是存储我们记录的地方。</p>
<p>上面的「最小记录」和「最大记录」是如何跟我们的记录关联起来的呢？</p>
<p>这时候 next_record 的作用就体现出来了。这两条记录和我们自定义的记录之间是通过 next_record 关联起来的，自定义的记录之间也是通过 next_record 关联起来的，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-4ab3fd1b95109efb9b32f838e3570b26_720w.jpg" alt="img"></p>
<p>即，「最小记录」的 next_record 指向第一条数据记录，最后一条数据记录的 next_record 指向「最大记录」。数据记录之间是按照主键的顺序从小到大排序的。</p>
<p>PS: 此处的 (1,100,‘aaaa’), (2,200,‘bbbb’) 等几条内容是自定义的数据。<br>
记录中的蓝色部分为额外信息，橙色部分为记录数据。</p>
<p><strong>Page Directory</strong></p>
<p>上面是以 4 条记录举例的，如果要查找其中一条，即使遍历也不会很耗时。但是，如果记录数量一直增加，比如到一千条、一万条甚至更多（假设一个数据页能存的下），我们如何去查找其中的一条记录呢？这样再去遍历岂不是很笨？</p>
<p>就像我们从一本书里找某些内容，当只有几页的时候很容易就能找到；但如果有好几百页，总不能一页一页去翻吧？</p>
<p>我们通常是先查找目录，找到在哪一页，然后直接翻到那一页。页目录的作用跟书的目录差不多。</p>
<p>由于记录之间是按主键排序的，可以把它们从小到大分成一个个的「组」，每组包含很少的几条记录，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-5c5f873aa349954a66f580866d184b40_720w.jpg" alt="img"></p>
<p>分组规则大致如下：</p>
<ul>
<li>「最小记录」自成一组</li>
<li>包含「最大记录」的组一般为 1~8 条记录</li>
<li>其它记录一般是 4~8 条分为一组</li>
</ul>
<p>分组之后，把每组中最大的那条记录的地址偏移量提出来，按顺序存储起来，这些地址偏移量称为槽（Slot），而这些槽就组成了页目录（Page Directory）。就像是给一本书做了目录。</p>
<p>目录有了，怎么使用呢？</p>
<p>此时如果要查找一条记录，步骤大致如下：</p>
<p>1、由于页目录中的槽是有序的，因此可以用「二分法」快速定位到一个槽；</p>
<p>2、找到该槽所在分组中主键值最小的记录；</p>
<p>3、通过 next_record 遍历组中的记录。</p>
<p>这样就比遍历所有的记录快得多了吧！</p>
<p><strong>Page Header</strong></p>
<p>页头部，主要记录数据页的一些信息，比如本页存了多少条记录、页目录中有多少个槽等等。</p>
<p><strong>File Header</strong></p>
<p>页头部存的是一个数据页的概要信息，是一个页专有的，而文件头存的是各种页通用的信息，比如页的类型是什么、页的编号是多少、上一页的页号是多少、下一页的页号是多少等等。</p>
<p>既然有上一页、下一页的定义，说明页与页之间其实是互相连接的，它们之间就像一个双向链表（比如 Java 的 LinkedList）那样，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-983d6442b506e0c37e397115158071c6_720w.jpg" alt="img"></p>
<p><strong>File Trailer</strong></p>
<p>文件尾，主要用于校验一个页是不是完整的。</p>
<h3 id="4、B-树索引">4、B+树索引</h3>
<p>InnoDB存储引擎的是一颗B+树，完整的用户记录都存储在B+树第0层的叶子节点；其他层次的 节点都属于内节点，内节点中存储的是目录项记录。</p>
<p>InnoDB的索引分为两种。</p>
<ul>
<li>聚簇索引：以主键值的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列。</li>
<li>二级索引：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列+主键。</li>
</ul>
<p>InnoDB存储引擎的B+树根节点自创建之日就不再移动。</p>
<p>在二级索引的B+树内节点中，目录项记录由索引列的值，主键值和页号组成。</p>
<p>一个数据页至少可以容纳2条记录。</p>
<p>MyISAM存储引擎的数据和索引分开存储，这种存储引擎的索引全部都是二级索引，在叶子节点处存储的是列+行号。</p>
<h3 id="5、B-树索引的使用">5、B+树索引的使用</h3>
<p><a href='http://t.csdn.cn/VkLnf '>MySQL中B+树索引的应用场景大全</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC入门</title>
    <url>/posts/41575.html</url>
    <content><![CDATA[<p>在 gRPC 中，客户端应用程序可以直接调用另一台计算机上的服务器应用程序上的方法，就好像它是本地对象一样，从而使您可以更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以使用其参数和返回类型远程调用的方法。在服务器端，服务器实现此接口并运行 gRPC 服务器来处理客户端调用。在客户端，客户端有一个存根，该存根提供与服务器相同的方法。</p>
<span id="more"></span>
<h3 id="一、简介">一、简介</h3>
<p>在 gRPC 中，客户端应用程序可以直接调用另一台计算机上的服务器应用程序上的方法，就好像它是本地对象一样，从而使您可以更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以使用其参数和返回类型远程调用的方法。在服务器端，服务器实现此接口并运行 gRPC 服务器来处理客户端调用。在客户端，客户端有一个存根，该存根提供与服务器相同的方法。</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:800px; height:500px;" src="https://www.processon.com/embed/62f620f1e0b34d075574d809"></iframe>
<h3 id="二、特性">二、特性</h3>
<h4 id="1、基于HTTP-2">1、基于HTTP/2</h4>
<p>HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。</p>
<h4 id="2、IDL使用ProtoBuf">2、IDL使用ProtoBuf</h4>
<p>gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。</p>
<h4 id="3、多语言支持">3、多语言支持</h4>
<p>gRPC支持多种语言（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java），并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。</p>
<h4 id="4、gRPC优缺点">4、gRPC优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>protobuf二进制消息，性能好/效率高（空间和时间效率都很不错）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>支持多种语言（可以把proto文件看做IDL文件）</li>
<li>Netty等一些框架集成</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>GRPC尚未提供连接池，需要自行实现</li>
<li>尚未提供“服务发现”、“负载均衡”机制</li>
<li>因为基于HTTP2，绝大部多数HTTP Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持）</li>
<li>Protobuf二进制可读性差（貌似提供了Text_Fromat功能）<br>
默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h3 id="二、Protocol-Buffers">二、Protocol Buffers</h3>
<p>protobuf 是 Google 公司内部的混合语言数据标准，默认情况下，grpc使用的就是protobuf。你可以理解Protocol Buffers是一种更加灵活、高效的数据格式，与XML、JSON类似，在一些高性能且对响应速度有要求的数据传输场景非常适用。</p>
<blockquote>
<p>目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <strong>RPC 数据交换格式</strong>。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API（即时通讯网注：Protobuf官方工程主页上显示的已支持的开发语言多达10种，分别有：C++、Java、Python、Objective-C、C#、JavaNano、JavaScript、Ruby、Go、PHP，基本上主流的语言都已支持，详见工程主页：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9naXRodWIuY29tLzUyaW0vcHJvdG9idWY=">https://github.com/52im/protobuf<i class="fa fa-external-link-alt"></i></span>）。</p>
</blockquote>
<p><strong>在RPC框架中的作用：</strong></p>
<ul>
<li>定义数据结构</li>
<li>定义服务接口</li>
<li>通过序列化和反序列化，提升传输效率</li>
</ul>
<h4 id="1、如何使用它">1、如何使用它</h4>
<ul>
<li>
<p>在后缀为.proto文件中定义数据结构（被远程调用服务的接口文档）</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//使用的版本号</span><br><span class="line"><span class="attribute">syntax</span> <span class="operator">=</span> <span class="string">&quot;proto3&quot;</span><span class="comment">;</span></span><br><span class="line">option go_package <span class="operator">=</span> <span class="string">&quot;../proto;client&quot;</span><span class="comment">;</span></span><br><span class="line">option java_multiple_files <span class="operator">=</span> true<span class="comment">;</span></span><br><span class="line">option java_package<span class="operator">=</span><span class="string">&quot;com.example.grpcexample.helloworld&quot;</span><span class="comment">;</span></span><br><span class="line">//请求</span><br><span class="line">message Request &#123;</span><br><span class="line">    double num1 <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    double num2 <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    OperateType opType <span class="operator">=</span> <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">//枚举类</span><br><span class="line">enum OperateType &#123;</span><br><span class="line">    Addition <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    Division <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    Multiplication <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    Subtraction <span class="operator">=</span> <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">//响应</span><br><span class="line">message Response &#123;</span><br><span class="line">    double result <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义服务</span><br><span class="line">service Operate &#123;</span><br><span class="line">	//一元RPC</span><br><span class="line">    rpc Calculate (Request) returns (Response)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    //服务器流式 RPC</span><br><span class="line">    rpc Calculate (Request) returns (stream Response)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    //客户端流式RPC</span><br><span class="line">    rpc Calculate (stream Request) returns (Response)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    //双向流式RPC</span><br><span class="line">    rpc Calculate (stream Request) returns (Response)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>四种服务类型介绍(消息传输)</p>
<ul>
<li>一元RPC（请求响应式）：其中客户端向服务器发送单个请求并获取单个响应，就像普通的函数调用一样。</li>
<li>服务器流式处理 RPC：其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息。gRPC 保证单个 RPC 调用中的消息排序。</li>
<li>客户端流式处理 RPC：其中客户端写入一系列消息并将其发送到服务器，再次使用提供的流。客户端完成写入消息后，它将等待服务器读取这些消息并返回其响应。同样，gRPC 保证单个 RPC 调用中的消息排序。</li>
<li>双向流式处理 RPC：其中双方都使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照它们喜欢的任何顺序进行读取和写入：例如，服务器可以等待接收所有客户端消息，然后再写入其响应，或者它可以交替读取消息然后写入消息，或者其他一些读取和写入的组合。将保留每个流中消息的顺序。</li>
</ul>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:800px; height:800px;" src="https://www.processon.com/embed/62f64a287d9c08072f9d6743"></iframe>
</li>
</ul>
</li>
<li>
<p>第二步，根据服务端（服务提供者）和客户端（服务调用者）语言类型，生成相应的代码，然后再实现/调用方法。</p>
</li>
</ul>
<h3 id="三、案例-一元rpc">三、案例(一元rpc)</h3>
<h4 id="1、用Java写客户端，Go写服务端">1、用Java写客户端，Go写服务端</h4>
<p><strong>编写protobuf文件</strong></p>
<p>helloworld.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;../proto;helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.example.grpc_study.proto&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span>&#123;</span><br><span class="line">	<span class="type">string</span> source=<span class="number">1</span>;</span><br><span class="line">	<span class="type">string</span> language=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">	<span class="type">string</span> source=<span class="number">1</span>;</span><br><span class="line">	<span class="type">string</span> language=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">service </span><span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> TestRpc(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写Go服务端</strong></p>
<ul>
<li>
<p>安装grpc：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> -u google.golang.org/grpc</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装编译proto文件的插件</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/golang/protobuf/proto</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在proto文件目录中执行命令，生成代码</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">protoc -I . <span class="attribute">--go_out</span>=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;grpc_study/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server)</span></span> TestRpc(ctx context.Context,req *helloworld.Request)(*helloworld.Response,<span class="type">error</span>)&#123;</span><br><span class="line">	source:=req.Source</span><br><span class="line">	language:=req.Language</span><br><span class="line">	fmt.Printf(<span class="string">&quot;接收到来自%s%s的请求&quot;</span>,language,source)</span><br><span class="line">	<span class="keyword">return</span> &amp;helloworld.Response&#123;Source:<span class="string">&quot;服务端&quot;</span>,Language:<span class="string">&quot;Go&quot;</span>&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	helloworld.RegisterHelloWorldServer(s,&amp;server&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动服务端：go run server.go</p>
</li>
</ul>
<p><strong>编写Java客户端</strong></p>
<ul>
<li>
<p>创建SpringBoot项目</p>
</li>
<li>
<p>配置maven</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!--    GRPC    --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-server-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--    插件    --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:$</span><span class="template-variable">&#123;os.detected.classifier&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.20.0:exe:$</span><span class="template-variable">&#123;os.detected.classifier&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.sourceDirectory&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--设置是否在生成java文件之前清空outputDirectory的文件，默认值为true，设置为false时也会覆盖同名文件--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">clearOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">clearOutputDirectory</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--更多配置信息可以查看https://www.xolstice.org/protobuf-maven-plugin/compile-mojo.html--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在java的同级目录创建proto文件夹，并将其标记为Sources Root</p>
</li>
<li>
<p>在proto目录中创建helloworld.proto，内容go服务端内容一样</p>
</li>
<li>
<p>执行：mvn clean install，生成代码</p>
</li>
<li>
<p>创建Client类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HelloWorldGrpc.HelloWorldBlockingStub blockingStub;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Client</span><span class="params">(ManagedChannel channel)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.channel = channel;</span><br><span class="line">		blockingStub = HelloWorldGrpc.newBlockingStub(channel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Client</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">				.usePlaintext()</span><br><span class="line">				.build());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Client</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9090</span>);</span><br><span class="line">			Request request=Request.newBuilder().setLanguage(<span class="string">&quot;Java&quot;</span>).setSource(<span class="string">&quot;客户端&quot;</span>).build();</span><br><span class="line">			<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> service.blockingStub.testRpc(request);</span><br><span class="line">			System.out.println(<span class="string">&quot;服务调用成功，接收到来自&quot;</span>+response.getLanguage()+response.getSource()+<span class="string">&quot;的响应&quot;</span>);</span><br><span class="line">			service.shutdown();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>启动服务端，再启动客户端</strong></p>
<h4 id="2、用Go写客户端，Java写服务端">2、用Go写客户端，Java写服务端</h4>
<p><strong>编写服务端</strong></p>
<p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GrpcService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">extends</span> <span class="title class_">HelloWorldGrpc</span>.HelloWorldImplBase &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRpc</span><span class="params">(Request request, StreamObserver&lt;Response&gt; streamObserver)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;接收到来自&quot;</span>+request.getLanguage()+request.getSource()+<span class="string">&quot;的请求&quot;</span>);</span><br><span class="line">		streamObserver.onNext(Response.newBuilder().setLanguage(<span class="string">&quot;Java&quot;</span>).setSource(<span class="string">&quot;服务端&quot;</span>).build());</span><br><span class="line">		streamObserver.onCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动SpringBoot应用，grpc服务默认启动的是9090端口</p>
<p><strong>编写客户端</strong></p>
<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;grpc_study/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:9090&quot;</span>, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;grpc Dial error&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client := helloworld.NewHelloWorldClient(conn)</span><br><span class="line">    rep, err := client.TestRpc(context.TODO(), &amp;helloworld.Request&#123;Source:<span class="string">&quot;客户端&quot;</span>,Language:<span class="string">&quot;Go&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;服务调用成功,收到来自：%s%s的响应&quot;</span>, rep.Language,rep.Source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启动服务端，再启动客户端</strong></p>
<h3 id="四、protobuf文件语法">四、protobuf文件语法</h3>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用的版本号</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">//生成go代码的位置，及包名</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;../proto;helloworld&quot;</span>;</span><br><span class="line"><span class="comment">//生成java代码，是否选择多文件</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//生成java代码的路径</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.example.grpc_study.proto&quot;</span>;</span><br><span class="line"><span class="comment">//消息体，1，2为字段标签，用于序列化</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span>&#123;</span><br><span class="line">	<span class="type">string</span> source=<span class="number">1</span>;</span><br><span class="line">	<span class="type">string</span> language=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">	<span class="type">string</span> source=<span class="number">1</span>;</span><br><span class="line">	<span class="type">string</span> language=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务名</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="comment">//TestRpc服务端提供的方法名</span></span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> TestRpc(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1、import">1、import</h4>
<p>用来引入其他文件的内容</p>
<p>格式：import “/xxx路径”，路径是从protoc这个命令的当前目录开始算起</p>
<h4 id="2、message">2、message</h4>
<blockquote>
<p>在protobuf中用来定义消息类型的关键字</p>
</blockquote>
<p><strong>格式</strong></p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">message 参数名称&#123;</span><br><span class="line">	修饰符 数据类型 字段名<span class="built_in">=</span>标签;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符：</p>
<ul>
<li>Required: 表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值，对于接收方，必须能够识别该字段的意思。发送之前没有设置required字段或者无法识别required字段都会引发编解码异常，导致消息被丢弃。</li>
<li>Optional：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。—因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。</li>
<li>Repeated：表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值。</li>
</ul>
<p>数据类型：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202208131444544.png" alt="在这里插入图片描述"></p>
<ul>
<li>
<p>默认值</p>
<ul>
<li><code>string</code>类型,默认值是空字符串,注意不是null</li>
<li><code>bytes</code>类型,默认值是空bytes</li>
<li><code>bool</code>类型，默认值是false</li>
<li><code>数字</code>类型,默认值是0</li>
<li><code>枚举</code>类型,默认值是第一个枚举值,即0</li>
<li><code>repeated</code>修饰的属性，默认值是空（在相对应的编程语言中通常是一个空的list）.</li>
</ul>
</li>
<li>
<p>Any类型，类似于Java的Object</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">如果使用any类型，需要导入：google/protobuf/any.proto</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;google/protobuf/any.proto&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">	string msg <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">	int32 code <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">	google.protobuf.Any data <span class="operator">=</span> <span class="number">3</span><span class="comment">; //可以理解成Object</span></span><br><span class="line">	repeated google.protobuf.Any datas <span class="operator">=</span> <span class="number">4</span><span class="comment">; //可以理解成泛型 List&lt;T&gt; datas;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>标签：</p>
<ul>
<li>该标签的取值范围为 1~2^32（4294967296），其中 1~15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低（相对于1-15），当然一般情况下相邻的2个值编码效率的是相同的，除非2个值恰好实在4字节，12字节，20字节等的临界区。比如15和16。1900~2000编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用。</li>
<li>当两个字段标签一致时，其修饰符和数据类型也必须相同</li>
<li>消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值。</li>
<li>建议：项目投入运营以后涉及到版本升级时的新增消息字段全部使用optional或者repeated，尽量不使用required。如果使用了required，需要全网统一升级，如果使用optional或者repeated可以平滑升级。</li>
</ul>
<p><strong>用法</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//普通的消息类型</span><br><span class="line">message Person &#123;</span><br><span class="line">	string name<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">//嵌套消息，无层级限制</span><br><span class="line">message Person &#123;</span><br><span class="line">	string name<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">	message Man&#123;</span><br><span class="line">		string name <span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	repeated Man man<span class="operator">=</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">message Student&#123;</span><br><span class="line">	Person.Man man<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、enum">3、enum</h4>
<p><strong>格式</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">enum 标识符 &#123;</span><br><span class="line">	字段名<span class="operator">=</span><span class="number">0</span><span class="comment">;</span></span><br><span class="line">	字段名<span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、service">4、service</h4>
<p><strong>格式</strong></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">service 服务名 &#123;</span><br><span class="line"> <span class="function"><span class="keyword">rpc</span> 方法名(请求消息) <span class="keyword">returns</span> (响应消息)</span>;</span><br><span class="line"> <span class="function"><span class="keyword">rpc</span> 方法名(stream 请求消息) <span class="keyword">returns</span> (响应消息)</span>;</span><br><span class="line"> <span class="function"><span class="keyword">rpc</span> 方法名(请求消息) <span class="keyword">returns</span> (stream 响应消息)</span>;</span><br><span class="line"> <span class="function"><span class="keyword">rpc</span> 方法名(stream 请求消息) <span class="keyword">returns</span> (stream 响应消息)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、讨论">五、讨论</h3>
<h4 id="1、和其他RPC框架相比，gRPC的优势？">1、和其他RPC框架相比，gRPC的优势？</h4>
<ul>
<li>跨语言，且自动生成代码</li>
<li>性能高，比如protobuf性能高过json, 比如http2.0性能高过http1.1</li>
<li>生态好</li>
<li>流式处理（基于http2.0）：支持客户端流式，服务端流式，双向流式</li>
</ul>
<h4 id="2、还有其他的跨语言的RPC吗，gRPC在跨语言RPC框架中是最好的吗？">2、还有其他的跨语言的RPC吗，gRPC在跨语言RPC框架中是最好的吗？</h4>
<ul>
<li>Thrift是一种可伸缩的跨语言服务的RPC软件框架。它结合了功能强大的软件堆栈的代码生成引擎，以建设服务，高效、无缝地在多种语言间结合使用</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞定前后端项目部署</title>
    <url>/posts/30975.html</url>
    <content><![CDATA[<h3 id="Linux常用命令：">Linux常用命令：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lsof -i:<span class="number">8090</span> <span class="comment">//查看端口是否被占用</span></span><br><span class="line">kill -s <span class="number">9</span> pid <span class="comment">//杀死进程</span></span><br><span class="line">jps <span class="comment">//查看启动的java应用进程</span></span><br><span class="line">scp -P <span class="number">22</span>（服务器端口号） smpe-system-<span class="number">1.0</span><span class="number">.0</span>-RELEASE.jar  root<span class="meta">@ip</span>地址:/data/nginx/www/cloudsafe/cloudsafe_server（服务器中文件夹的绝对路径） </span><br><span class="line"><span class="comment">//远程复制，将本地的xx.jar， 上传到服务器的xxxx/cloudsafe_server文件夹，注：（）为解释，执行时自行删除，此命令是在jar的所在目录下执行的。</span></span><br><span class="line"></span><br><span class="line">docker exec -it a4f598cc4268（容器id） mysqldump -uroot -p*********（数据库密码） --opt research_keyuan（数据库名称） &gt; /root/mysql_file_backup/mysqlbakup_research_keyuan.sql  （用来保存sql文件的路径及文件名）</span><br><span class="line"><span class="comment">//此命令用来备份docker中的mysql数据库sql文件</span></span><br><span class="line"></span><br><span class="line">docker exec -i a4f598cc4268（容器id） mysql -uroot -p*****（数据库密码） research_keyuan &lt; /root/mysql_file_backup/xxxx.sql</span><br><span class="line"><span class="comment">//此命令是用来将sql文件导入到docker中的mysql容器的mysql的指定数据库</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="环境准备">环境准备</h3>
<p>下面的环境只适用于Centos 7.x</p>
<h4 id="Docker">Docker</h4>
<p>添加yum源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum update <span class="comment">//检查更新</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y <span class="comment">//添加yum的软件仓库</span></span><br></pre></td></tr></table></figure>
<p>安装docker</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> docker-io -y</span><br></pre></td></tr></table></figure>
<p>运行docker</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>
<p>检查安装结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>停止docker</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<p>docker的常用命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull xxx <span class="comment">//拉取应用镜,如拉取nginx镜像：docker pull nginx</span></span><br><span class="line">docker images <span class="comment">//查看已有镜像</span></span><br><span class="line">docker rmi 镜像id <span class="comment">//删除镜像</span></span><br><span class="line">docker ps <span class="comment">//查看启动的容器</span></span><br><span class="line">docker ps -a <span class="comment">//查看容器，包含了未启动的容器</span></span><br><span class="line">docker stop 容器id <span class="comment">//停止容器</span></span><br><span class="line">docker rm 容器id <span class="comment">//删除容器，需要停止容器</span></span><br><span class="line">docker exec -it 容器id/名称 bash <span class="comment">//进入容器内部</span></span><br><span class="line">docker inspect 容器id/名称 | grep Mounts -A <span class="number">20</span> <span class="comment">//查看容器与服务器的映射目录</span></span><br><span class="line">docker inspect 容器id/名称 | grep IPAddress <span class="comment">//查看容器的ip地址</span></span><br></pre></td></tr></table></figure>
<p>下面需要安装一些公共服务如：mysql ,redis, nginx</p>
<p>两种方案：在docker中安装，在服务器中直接安装，两种方式都可，建议选择一种，仁者见仁吧，根据方式不一样，后端的部署也会有些细微变动。</p>
<h4 id="一、Docker安装各种服务">一、Docker安装各种服务</h4>
<h5 id="Docker-安装mysql">Docker 安装mysql</h5>
<p>安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker pull mysql <span class="regexp">//</span>后面不加版本号，默认最高版本</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -itd --name mysql-test -p <span class="number">3307</span>:<span class="number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> mysql</span><br></pre></td></tr></table></figure>
<ul>
<li>参数说明：
<ul>
<li>*<em>-p 3306:3307</em> ：映射容器的 3306端口到宿主机的 3307 端口，外部主机可以直接通过 <strong>宿主机ip:3307</strong> 访问到 MySQL 的服务。</li>
<li><strong>MYSQL_ROOT_PASSWORD=123456</strong>：设置 MySQL 服务 root 用户的密码。</li>
<li>注：启动后，如果需要远程访问，需要开启服务器的相应端口号</li>
</ul>
</li>
</ul>
<p>检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker ps <span class="comment">//查看是否安装成功</span></span><br></pre></td></tr></table></figure>
<h5 id="Docker-安装Redis">Docker 安装Redis</h5>
<p>安装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p <span class="number">6379</span>:<span class="number">6379</span> -d --restart=always redis redis-server --appendonly yes --requirepass <span class="string">&quot;这是密码&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数说明
<ul>
<li>-p 6379:6379 端口映射：前表示服务器的端口，：后表示容器的端口。</li>
<li>–name myredis  指定该容器名称，查看和进行操作都比较方便。</li>
<li>-d redis 表示后台启动redis</li>
<li>appendonly yes 开启redis 持久化</li>
</ul>
</li>
</ul>
<h5 id="Docker-安装nginx">Docker 安装nginx</h5>
<p>由于内容有点多，都记录到此篇博客中<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDkzMjQ4Ny9hcnRpY2xlL2RldGFpbHMvMTE3MTkzMTkxP29wc19yZXF1ZXN0X21pc2M9JTdCJTIycmVxdWVzdCU1RmlkJTIyJTNBJTIyMTYzNjI4MzEwODE2NzgwMjY1NDYyMjk1JTIyJTJDJTIyc2NtJTIyJTNBJTIyMjAxNDA3MTMuMTMwMTAyMzM0LnBjJTVGYmxvZy4lMjIlN0QmcmVxdWVzdF9pZD0xNjM2MjgzMTA4MTY3ODAyNjU0NjIyOTUmYml6X2lkPTAmdXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3NlYXJjaF9yZXN1bHQubm9uZS10YXNrLWJsb2ctMn5ibG9nfmZpcnN0X3JhbmtfdjJ+cmFua192MjktMS0xMTcxOTMxOTEucGNfdjJfcmFua19ibG9nX2RlZmF1bHQmdXRtX3Rlcm09ZG9ja2VyJnNwbT0xMDE4LjIyMjYuMzAwMS40NDUw">基于Docker使用Nginx<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="二、服务器安装各种服务">二、服务器安装各种服务</h4>
<p>服务器中，我是采用yum源来安装各种服务，这种方式比较简单（强烈推荐）</p>
<h5 id="yum安装Mysql">yum安装Mysql</h5>
<p>1、检查系统是否安装有mysql</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum list installed mysql*</span><br><span class="line">rpm -qa | grep mysql*</span><br></pre></td></tr></table></figure>
<p>2、安装客户端</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mysql</span><br></pre></td></tr></table></figure>
<p>3、安装服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line">注：可能提示为安装失败</span><br><span class="line">原因：CentOS7自带有MariaDB而不是MySQL，MariaDB和MySQL一样也是开元的数据库</span><br><span class="line">解决方案：如果必须要安装MySQL，首先必须添加mysql社区repo通过输入命令：</span><br><span class="line">sudo rpm -Uvh http:<span class="comment">//dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br><span class="line"><span class="comment">//执行后， 继续执行</span></span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<p>4、执行</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mysql-devel</span><br></pre></td></tr></table></figure>
<p>5、配置数据库</p>
<p>vim /etc/my.cnf</p>
<p>在配置文件中加入默认字符集：</p>
<p>default-character-set=uft-8</p>
<p>6、启动或关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> ~]#service mysqld start      --启动mysql[root<span class="meta">@localhost</span> ~]#service mysqld stop       --关闭mysql</span><br><span class="line">[root<span class="meta">@localhost</span> ~]#lsof -i:<span class="number">3306</span>              --数据库端口是否开启</span><br></pre></td></tr></table></figure>
<p>7、设置开机启动mysql服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">chkconfig --<span class="built_in">add</span> mysqld</span><br></pre></td></tr></table></figure>
<p>8、创建root管理员</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysqladmin</span> -u root password 密码</span><br></pre></td></tr></table></figure>
<p>9、进入mysql设置远程访问</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">//依次执行</span><br><span class="line">mysql -u root -p</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="symbol">`Host`</span> = <span class="string">&#x27;%&#x27;</span> <span class="keyword">WHERE</span> <span class="symbol">`User`</span> = <span class="string">&#x27;root&#x27;</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>10、在服务器的控制台中防火墙，将数据库端口打开（安全组规则中添加3306端口）</p>
<h5 id="yum安装redis">yum安装redis</h5>
<p>1、yum install redis</p>
<p>2、yum isntall epel-release</p>
<p>3、启动服务</p>
<p>systemctl start redis</p>
<p>4、查看状态</p>
<p>systemctl status redis</p>
<p>5、停止服务</p>
<p>systemctl stop redis</p>
<p>6、重启服务</p>
<p>systemctl restart redis</p>
<p>7、查看redis进程</p>
<p>ps -ef | grep redis</p>
<p>8、设置开机自启动</p>
<p>systemctl enable redis</p>
<p>9、设置远程连接</p>
<p>进入配置文件</p>
<p>vi /etc/redis.conf</p>
<p>注释bind 127.0.0.1</p>
<p>设置protected-mode no</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071933559.png" alt="img"></p>
<p>修改密码为111111</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071934861.png" alt="img"></p>
<p>10、保存并退出编辑重启redis</p>
<p>systemctl restart redis</p>
<p>11、在服务器的控制台的安全组规则，开放redis端口号6379</p>
<h5 id="yum-安装git">yum 安装git</h5>
<p>1、安装</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure>
<p>2、配置</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置用户名称和登录邮箱</span></span><br><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.name</span> <span class="string">&#x27;用户名&#x27;</span></span><br><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.email</span> <span class="string">&#x27;邮箱&#x27;</span></span><br></pre></td></tr></table></figure>
<p>3、生成密钥，方便拉取远程仓库代码</p>
<p>建议在服务器根目录执行，**cd / **  可以切换到根目录</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;登录邮箱&#x27;</span><br></pre></td></tr></table></figure>
<p>执行之后，不建议输入密码，直接一直Enter跳过</p>
<p>完成后，一般会在**/root/.ssh/<strong>文件夹中生成两个文件，大家</strong>id-rsa.pub**文件的内容，全部复制，找到github个人账户设置，在ssh key 中的菜单中新增ssh key,将内容粘贴进去即可。</p>
<h3 id="配置Nginx代理">配置Nginx代理</h3>
<p>此方案基于Docker容器中的Nginx</p>
<p>1、查看Nginx挂载目录</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">inspect</span> nginx | <span class="keyword">grep</span> Mounts -A <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081611709.png" alt="image-20211108161137330"></p>
<p>Source对应服务器的文件夹，Destination对应nginx_config文件夹</p>
<p>注：如果你看的我博客进行配置的，会看到有五个挂载目录，有两个目录，很重要，其他是配置文件和日志的。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081628511.png" alt="image-20211108162847392"></p>
<p>2、在conf.d文件夹加入项目的nginx配置</p>
<p>文件名：xxx.conf（xxx自己随意命名）</p>
<p>详细的解释，请仔细看注释</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver&#123;</span><br><span class="line">    <span class="comment">#172.17.0.6是项目所在容器的ip地址，8000为项目的端口，请根据实际情况修改；如果项目是在服务器裸奔的，可以直接用127.0.0.1:端口</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.17.0.6:8000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    <span class="comment">#监听的端口</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment">#域名，根据实际情况修改，（没域名，可以直接写成ip地址）</span></span><br><span class="line">    <span class="attribute">server_name</span> kygl.ruanzhuinfo.com;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">500m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/host.access.log main;</span><br><span class="line">	<span class="comment">#后台</span></span><br><span class="line">    <span class="section">location</span> /admin &#123;</span><br><span class="line">        <span class="comment">#root 后面路径在服务器的路径为：/data/nginx/www/kygl_v2/dist_web</span></span><br><span class="line">        <span class="comment">#因为nginx需要代替(代理)你访问文件，nginx是在一个docker容器中和服务器不是在一个环境下，</span></span><br><span class="line">        <span class="comment">#所以需要路径改成在容器中的路径，dist_web为前端的打包的文件夹，要保证dist_web中有index.html</span></span><br><span class="line">        <span class="attribute">root</span>   /nginx_config/www/kygl_v2/dist_web/;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html?s=<span class="variable">$uri</span>&amp;<span class="variable">$args</span>;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#前台，如果有前台，可以配置，同上，因为root只能存在一个，所以下面用的alias来配置另一个虚拟目录</span></span><br><span class="line">    <span class="comment">#location /front &#123;</span></span><br><span class="line">    <span class="comment">#   alias   /nginx_config/www/kygl_v2/dist_front/;</span></span><br><span class="line">    <span class="comment">#   try_files $uri $uri/ /index.html?s=$uri&amp;$args;</span></span><br><span class="line">    <span class="comment">#   index index.html index.htm index.php;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#后端</span></span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /auth &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#下面是配置访问swagger</span></span><br><span class="line">    <span class="section">location</span> /swagger-ui.html &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /webjars &#123;</span><br><span class="line">	   <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /swagger-resources &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /v2 &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、记得每次修改nginx的相关配置，都需要重新加载下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>进入nginx容器</span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="regexp">//</span>测试，看下配置文件是否有问题</span><br><span class="line">nginx -t</span><br><span class="line"><span class="regexp">//</span>重新加载</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081722262.png" alt="image-20211108172223927"></p>
<p>如果遇到修改配置后，没有生效，请执行下面的命令</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">nginx -s reopen</span><br><span class="line">nginx -s <span class="built_in">stop</span> <span class="comment">//此命令执行后，会退出容器，重新进入即可</span></span><br><span class="line">nginx -<span class="built_in">reload</span></span><br></pre></td></tr></table></figure>
<h3 id="部署后端（SpringBoot项目）">部署后端（SpringBoot项目）</h3>
<p>如果你是把各种服务放到了docker中，请选择<strong>方案一</strong>；如果你把各种服务安装到了服务器中，请选择<strong>方案二</strong>；</p>
<p>下面的所有步骤将以我的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pnbGdpdGh1Yngvb3VyY2hhdC5naXQ=">github项目<i class="fa fa-external-link-alt"></i></span>为例</p>
<p>克隆项目</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/zglgithubx/</span>ourchat.git</span><br></pre></td></tr></table></figure>
<p>切换到分支develop</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git checkout develop</span></span><br></pre></td></tr></table></figure>
<h4 id="方案一">方案一</h4>
<p><span class="exturl" data-url="aHR0cDovL3huLS1kZW1vLWs4NGZ0aWI4NGVzNWE1OXVlcjFkOXFhMTRtcXZldTA3ZGM3MWJsbjJjLnNo">这个方案用到了一个脚本文件demo.sh<i class="fa fa-external-link-alt"></i></span>，一个Dockerfile文件，说下demo.sh脚本都做了哪些工作：执行Dockerfile文件构建CentoS镜像，在镜像中安装了vim 、git、jdk 、maven—&gt;根据centos镜像启动了一个容器----&gt;在centos容器中拉取项目—&gt;将项目打包成jar包—&gt;启动项目jar包</p>
<p>1、准备文件</p>
<p>下面是脚本文件demo.sh和Dockerfile，部署时请将这两文件放到后端的根目录下</p>
<p>注：如果部署自己的项目需将<strong>SERVER_NAME 、JAR_PATH、Root_File_Name</strong>参数修改</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像名字</span></span><br><span class="line">IMAGE_NAME=centos7_mvn_git_java8</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 容器名字或者jar名字，这里都命名为这个（*必填）</span></span><br><span class="line">SERVER_NAME=ourchat</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的JAR_PATH为jar包所在位置，这路径是jar相对于脚本文件的路径。（*必填）</span></span><br><span class="line">JAR_PATH=./target/demo-0.0.1-RELEASE.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目根目录文件夹名称（*必填）</span></span><br><span class="line">Root_File_Name=ourchat</span><br><span class="line"></span><br><span class="line">profile=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"><span class="comment">#Xms=$4</span></span><br><span class="line"><span class="comment">#Xmx=$5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [init|start|stop|restart|status|pull] [profile] [port]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化——构建镜像和容器(在宿主机执行)</span></span><br><span class="line"><span class="function"><span class="title">init</span></span>()&#123;</span><br><span class="line">  <span class="comment">#容器id</span></span><br><span class="line">  CID=$(docker ps | grep <span class="string">&quot;<span class="variable">$SERVER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">  <span class="comment">#镜像id</span></span><br><span class="line">  IID=$(docker images | grep <span class="string">&quot;<span class="variable">$IMAGE_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">	<span class="comment"># 构建docker镜像</span></span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$SERVER_NAME</span> image，IID=<span class="variable">$IID</span>&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;NOT exit <span class="variable">$SERVER_NAME</span> image，start build image...&quot;</span></span><br><span class="line">		<span class="comment"># 根据项目个路径下的Dockerfile文件，构建镜像</span></span><br><span class="line">		docker build -t <span class="variable">$IMAGE_NAME</span> .</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span> image has been builded&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$SERVER_NAME</span> container，CID=<span class="variable">$CID</span>.   ---Remove container&quot;</span></span><br><span class="line">			docker stop <span class="variable">$SERVER_NAME</span>   <span class="comment"># 停止运行中的容器</span></span><br><span class="line">			docker <span class="built_in">rm</span> <span class="variable">$SERVER_NAME</span>     <span class="comment">##删除原来的容器</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 构建容器</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span> container,start build...&quot;</span></span><br><span class="line">	<span class="comment"># 运行容器</span></span><br><span class="line">	 <span class="comment"># --name 容器的名字</span></span><br><span class="line">	 <span class="comment">#   -d   容器后台运行</span></span><br><span class="line">	 <span class="comment">#   -p   指定容器映射的端口和主机对应的端口</span></span><br><span class="line">	 <span class="comment">#   -v   将主机的目录挂载到容器的目录中（不可少）</span></span><br><span class="line">	docker run -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -<span class="built_in">id</span> -m 512M --memory-swap=1G --name <span class="variable">$SERVER_NAME</span> -v <span class="variable">$PWD</span>/../:/project/<span class="variable">$Root_File_Name</span> <span class="variable">$IMAGE_NAME</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span> container build end&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查程序是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist</span></span>()&#123;</span><br><span class="line">  pid=`ps -ef|grep <span class="variable">$JAR_PATH</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动方法</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SERVER_NAME&#125;</span> is already running. pid=<span class="variable">$&#123;pid&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> --------Starting application --------</span><br><span class="line">    <span class="built_in">nohup</span> java -server -XX:-DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -jar <span class="variable">$JAR_PATH</span> --spring.profiles.active=<span class="variable">$&#123;profile:-dev&#125;</span> --server.port=<span class="variable">$&#123;port:-8000&#125;</span> &gt; start.log 2&gt;&amp;1 &amp;</span><br><span class="line">    <span class="built_in">echo</span> --------------Started!---------------</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止方法</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">    <span class="built_in">echo</span> -----------Application Stopped------------</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出运行状态</span></span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is running. Pid is <span class="variable">$&#123;pid&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#mvn</span></span><br><span class="line"><span class="function"><span class="title">pull</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：find status---------&quot;</span></span><br><span class="line">  git status</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：pull new coads---------&quot;</span></span><br><span class="line">  git pull origin develop</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------mvn clean package -Dmaven.test.skip=true---------&quot;</span></span><br><span class="line">  mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------Preparing start application ---------&quot;</span></span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    restart</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    start</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;init&quot;</span>)</span><br><span class="line">    init</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>)</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;pull&quot;</span>)</span><br><span class="line">    pull</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">RUN yum -y update \</span><br><span class="line">    &amp;&amp; yum -y install vim \</span><br><span class="line">    &amp;&amp; yum -y install git \</span><br><span class="line">    &amp;&amp; yum -y install java-1.8.0-openjdk-devel.x86_64 \</span><br><span class="line">    &amp;&amp; yum install -y maven \</span><br><span class="line">    &amp;&amp; mkdir ~/.m2</span><br><span class="line">RUN echo &#x27;<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span><span class="tag">&lt;<span class="name">mirror</span>&gt;</span><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span><span class="tag">&lt;/<span class="name">settings</span>&gt;</span>&#x27; &gt; ~/.m2/settings.xml</span><br></pre></td></tr></table></figure>
<p>2、初始化、构建镜像</p>
<p>切换到后端项目根目录</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd xxxx<span class="regexp">/ourchat_api/</span></span><br></pre></td></tr></table></figure>
<p>执行初始化命令</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh </span>demo.<span class="keyword">sh </span>init</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081113533.png" alt="image-20211108111350473"></p>
<p>完成后，会有成功的提示</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081111622.png" alt="image-20211108111147161"></p>
<p>3、查看容器是否启动</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081115646.png" alt="image-20211108111526577"></p>
<p>status为up 即为启动成功</p>
<p>4、进入容器</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> ourchat bash</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081116779.png" alt="image-20211108111634691"></p>
<p>5、切换到容器中的项目后端目录</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">project</span><span class="regexp">/ourchat/</span>ourchat_api/</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081118447.png" alt="image-20211108111846333"></p>
<p>6、脚本命令介绍</p>
<p>到这一步骤，环境基本都搭建完毕了，下面介绍脚本的命令</p>
<p>上面的初始化命令只需要执行一次，之后代码更新，只需要执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">注：下面的命令需要用ssh的方式和远程仓库建立连接，即配置centos容器中git,生成ssh key，将id.res_pub文件内容的key添加到github或coding服务器的个人账户中</span><br><span class="line"><span class="comment">#拉取新代码，重新打包项目，并重新启动</span></span><br><span class="line">sh demo.sh pull</span><br></pre></td></tr></table></figure>
<p>下面的命令是脚本的其他命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看项目启动状态</span></span><br><span class="line">sh demo.sh status</span><br><span class="line"><span class="comment">#启动项目，后面的参数是选填的,dev：环境，8000：项目端口号</span></span><br><span class="line">sh demo.sh start dev 8000</span><br><span class="line"><span class="comment">#停止项目</span></span><br><span class="line">sh demo.sh stop</span><br><span class="line"><span class="comment">#重新启动项目</span></span><br><span class="line">sh demo.sh restart</span><br></pre></td></tr></table></figure>
<h4 id="方案二">方案二</h4>
<p>方案一的好处有很多，项目交付时，服务器可能会发生迁移，新服务器不用再手动安装一些环境，只需要安装docker ,剩下的环境，执行Dockerfile就可以了。</p>
<p>方案二适合在个人服务器部署个人项目，不需要考虑服务器的迁移，可以把所有环境都装到服务器，节省空间</p>
<p>你如果选择了方案二，默认你已经把mysql、redis、及git都已经安装完毕</p>
<p>为了能够启动后端项目，还需要安装maven、jdk</p>
<p>1、安装maven</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> maven</span><br></pre></td></tr></table></figure>
<p>2、安装jdk1.8</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yum</span> install java-<span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure>
<p>3、准备脚本文件</p>
<p>其实这文件是根据demo.sh修改的，也是只需要把这个文件放到后端项目的根目录，如果自己使用只需要更改<strong>SERVER_NAME、JAR_PATH</strong>这两个参数</p>
<p><span class="exturl" data-url="aHR0cDovL291cmNoYXQuc2g=">ourchat.sh<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 容器名字或者jar名字，这里都命名为这个</span></span><br><span class="line">SERVER_NAME=ourchat</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的JAR_PATH为jar包所在位置</span></span><br><span class="line">JAR_PATH=./target/demo-0.0.1-RELEASE.jar</span><br><span class="line"></span><br><span class="line">profile=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [build|start|stop|restart|status|pull] [profile] [port]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">build</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------mvn clean package -Dmaven.test.skip=true---------&quot;</span></span><br><span class="line">  mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------Preparing start application ---------&quot;</span></span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    restart</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    start</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查程序是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist</span></span>()&#123;</span><br><span class="line">  pid=`ps -ef|grep <span class="variable">$JAR_PATH</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动方法</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SERVER_NAME&#125;</span> is already running. pid=<span class="variable">$&#123;pid&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> --------Starting application --------</span><br><span class="line">    <span class="built_in">nohup</span> java -server -Xms512m -Xmx512m -XX:SurvivorRatio=4 -Xss256k -XX:PermSize=256m -XX:MaxPermSize=512m -XX:-DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -jar <span class="variable">$JAR_PATH</span> --spring.profiles.active=<span class="variable">$&#123;profile:-prod&#125;</span> --server.port=<span class="variable">$&#123;port:-8000&#125;</span>&gt; start.log 2&gt;&amp;1 &amp;</span><br><span class="line">    <span class="built_in">echo</span> --------------Started!---------------</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止方法</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">    <span class="built_in">echo</span> -----------Application Stopped------------</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出运行状态</span></span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is running. Pid is <span class="variable">$&#123;pid&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#mvn</span></span><br><span class="line"><span class="function"><span class="title">pull</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：find status---------&quot;</span></span><br><span class="line">  git status</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：pull new coads---------&quot;</span></span><br><span class="line">  git pull origin develop</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------mvn clean package -Dmaven.test.skip=true---------&quot;</span></span><br><span class="line">  mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------Preparing start application ---------&quot;</span></span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    restart</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    start</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;build&quot;</span>)</span><br><span class="line">    build</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>)</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;pull&quot;</span>)</span><br><span class="line">    pull</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>4、在项目后端根目录执行build命令</p>
<p>这个命令会将项目打包并运行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh </span>ourchat.<span class="keyword">sh </span><span class="keyword">build</span></span><br></pre></td></tr></table></figure>
<p>其他命令同方案一中介绍的命令一样</p>
<p>项目代码更新后，重新部署时，只需要执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh ourchat.sh pull</span><br></pre></td></tr></table></figure>
<h3 id="部署前端（Vue项目）">部署前端（Vue项目）</h3>
<p>前端的部署，不外乎将打包好的dist文件夹上传到服务器，可能有的人直接在服务器安装webpack,然后再安装一系列的前端需要的配置，使用git将项目拉取到服务器，然后在服务器运行打包命令。我感觉前端的部署不应该那么复杂，有人可能要说了，直接把dist包每次在本地打包，然后复制到服务器的指定目录不就好了，这都2021年了，其实也不需要那么步骤。下面我介绍一款前端部署插件，可以用来简化这些步骤。</p>
<h4 id="安装fe-deploy-cli">安装fe-deploy-cli</h4>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>此为全局安装，一次安装受益终身</span><br><span class="line">npm i fe-deloy-cli -g</span><br></pre></td></tr></table></figure>
<p>安装之后，在前端项目根目录打开命令行</p>
<p>执行：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">deploy <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>执行完之后，在项目根目录会生成：deploy文件夹</p>
<p>文件deploy.config.js大概是这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">privateKey</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">//（选填） 本地私钥地址，位置一般在C:/Users/xxx/.ssh/id_rsa，非必填，有私钥则配置</span></span><br><span class="line">  <span class="attr">passphrase</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// （选填）本地私钥密码，非必填，有私钥则配置</span></span><br><span class="line">  <span class="attr">projectName</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 项目名称</span></span><br><span class="line">  <span class="comment">// 根据需要进行配置，如只需部署prod线上环境，请删除dev测试环境配置，反之亦然，支持多环境部署</span></span><br><span class="line">  <span class="attr">dev</span>: &#123; <span class="comment">// 开发环境</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;开发环境&#x27;</span>,</span><br><span class="line">    <span class="attr">script</span>: <span class="string">&quot;npm run build&quot;</span>, <span class="comment">// 测试环境打包脚本</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 测试服务器地址</span></span><br><span class="line">    <span class="attr">port</span>: xx, <span class="comment">// ssh port，一般默认22</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 登录服务器用户名</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xxxxx&#x27;</span>, <span class="comment">// 登录服务器密码</span></span><br><span class="line">    <span class="attr">distPath</span>: <span class="string">&#x27;dist&#x27;</span>,  <span class="comment">// 本地打包dist目录</span></span><br><span class="line">    <span class="attr">webDir</span>: <span class="string">&#x27;/MyProject/docker/nginx/html&#x27;</span>,  <span class="comment">// // 测试环境服务器地址</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">prod</span>: &#123;  <span class="comment">// 线上环境</span></span><br><span class="line">    同上</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再还有多余的环境按照这个格式写即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面变量都有注释，可以只配置一个环境，只需要把prod的内容删除，如果prod环境你没有配执行时会有报错。</p>
<p>配置完，在项目根目录执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deploy dev <span class="comment">//这代表打包开发环境</span></span><br></pre></td></tr></table></figure>
<p>执行之后，需要你确认下，输入yes就行，执行过程为：打包前端项目–&gt;压缩打包文件–&gt;压缩包上传到指定服务器的文件夹–&gt;解压—&gt;部署成功</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>微信服务平台快速开发小程序</title>
    <url>/posts/29622.html</url>
    <content><![CDATA[<h2 id="需求-3">需求</h2>
<p>根据一个小程序，发布一个和其一模一样的小程序。（可能不只一个）</p>
<p>如果按常规的做法每个小程序都需要经历这样的步骤：在公众平台申请appid——&gt;拉代码到自己的仓库——&gt;打开编译器绑定自己的appId——&gt;上传代码到公众平台——&gt;再提交审核——&gt;在公众平台调整开发设置。</p>
<p>如果用微信开放平台的服务平台开发的步骤：在微信开放平台申请第三方服务平台——&gt;上传小程序模板（只有第一次有）——&gt;调接口上传小程序代码</p>
<p>——&gt;调接口提交审核——&gt;调接口发布小程序。</p>
<p>上传小程序模板的步骤：在公众平台申请appid——&gt;在微信开放平台的第三方服务平台中添加开发小程序——&gt;上传小程序代码（此时会直接上传到了开放平台的草稿箱）——&gt;将草稿箱的代码作为普通模板</p>
<p>这就是服务平台开发平台的便捷，只需上传一次小程序代码，就可以快速的发布小程序。</p>
<span id="more"></span>
<h2 id="实现-3">实现</h2>
<h3 id="步骤：获取component-verify-ticket——-获取component-access-token——-获取authorizer-access-token——-调接口发布小程序">步骤：获取component_verify_ticket——&gt;获取component_access_token——&gt;获取authorizer_access_token——&gt;调接口发布小程序</h3>
<h3 id="1、获取component-verify-ticket">1、获取component_verify_ticket</h3>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9UaGlyZFBhcnR5L3Rva2VuL2NvbXBvbmVudF92ZXJpZnlfdGlja2V0Lmh0bWw=">验证票据 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></p>
<h3 id=""></h3>
<p>因为这个验证票据是微信官方主动推送的，所以需要在第三方平台配置一波</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202201271429448.png" alt="image-20220127142943253"></p>
<h4 id="controller">controller</h4>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ApiOperation</span>(value = <span class="string">&quot;微信开放平台：授权事件接收URL,验证票据&quot;</span>, notes = <span class="string">&quot;zhuguangliang&quot;</span>)</span><br><span class="line"><span class="variable">@AnonymousPostMapping</span>(<span class="string">&quot;/pushTicket&quot;</span>)</span><br><span class="line">public String wechatPlatformEvent(<span class="variable">@RequestParam</span>(<span class="string">&quot;timestamp&quot;</span>) String timestamp,</span><br><span class="line">                          <span class="variable">@RequestParam</span>(<span class="string">&quot;nonce&quot;</span>) String nonce,</span><br><span class="line">                          <span class="variable">@RequestParam</span>(<span class="string">&quot;msg_signature&quot;</span>) String msgSignature,</span><br><span class="line">                          <span class="variable">@RequestBody</span> String postData) &#123;</span><br><span class="line">   <span class="selector-tag">return</span> <span class="selector-tag">openPlatformUtil</span><span class="selector-class">.parseRequest</span>(timestamp, nonce, msgSignature, postData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现类">实现类</h4>
<p>关于存储component_verify_ticket方案，我这里是mysql和redis各存一份。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">parseRequest</span><span class="params">(String timeStamp, String nonce, String msgSignature, String postData)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (redisUtils.hasKey(CacheKey.OPEN_PLATFORM_TICKET)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//这个类是微信官网提供的解密类,需要用到消息校验Token 消息加密Key和服务平台appid</span></span><br><span class="line">			<span class="type">WXBizMsgCrypt</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WXBizMsgCrypt</span>(Token, Key, APPID);</span><br><span class="line">			<span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> pc.decryptMsg(msgSignature, timeStamp, nonce, postData);</span><br><span class="line">			Map&lt;String, String&gt; result = WXXmlToMapUtil.xmlToMap(xml);<span class="comment">// 将xml转为map</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">componentVerifyTicket</span> <span class="operator">=</span> result.get(<span class="string">&quot;ComponentVerifyTicket&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.isNotEmpty(componentVerifyTicket)) &#123;</span><br><span class="line">				<span class="comment">// 存储平台授权票据,保存ticket</span></span><br><span class="line">				<span class="type">SpiritOpenPlatform</span> <span class="variable">spiritOpenPlatform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpiritOpenPlatform</span>();</span><br><span class="line">				<span class="keyword">if</span> (platformMapper.selectByAppId(APPID) == <span class="number">0</span>) &#123;</span><br><span class="line">					spiritOpenPlatform.setAppid(APPID);</span><br><span class="line">					spiritOpenPlatform.setAppSecret(AppSecret);</span><br><span class="line">					spiritOpenPlatform.setPlatformKey(Key);</span><br><span class="line">					spiritOpenPlatform.setToken(Token);</span><br><span class="line">					spiritOpenPlatform.setComponentVerifyTicket(componentVerifyTicket);</span><br><span class="line">					platformMapper.insert(spiritOpenPlatform);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					spiritOpenPlatform.setComponentVerifyTicket(componentVerifyTicket);</span><br><span class="line">					LambdaUpdateWrapper&lt;SpiritOpenPlatform&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">					updateWrapper.eq(SpiritOpenPlatform::getAppid, APPID);</span><br><span class="line">					platformMapper.update(spiritOpenPlatform, updateWrapper);</span><br><span class="line">				&#125;</span><br><span class="line">				redisUtils.set(CacheKey.OPEN_PLATFORM_TICKET, componentVerifyTicket, <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>);</span><br><span class="line">				log.info(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】成功&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.error(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】失败&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (AesException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】失败,异常信息：&quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>官方提供的解密类：WXBizMsgCrypt.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.InputSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供接收和推送给公众平台消息的加解密接口(UTF8编码的字符串).</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;  * &lt;li&gt;第三方回复加密消息给公众平台&lt;/li&gt;  * &lt;li&gt;第三方收到公众平台发送的消息，验证消息的安全性，并对消息进行解密。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * 说明：异常java.security.InvalidKeyException:illegal Key Size的解决方案</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;在官方网站下载JCE无限制权限策略文件（JDK7的下载地址：  *</span></span><br><span class="line"><span class="comment"> * http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;如果安装了JRE，将两个jar文件放到%JRE_HOME%\lib\security目录下覆盖原来的文件&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;如果安装了JDK，将两个jar文件放到%JDK_HOME%\jre\lib\security目录下覆盖原来文件&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXBizMsgCrypt</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">	<span class="type">Base64</span> <span class="variable">base64</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base64</span>();</span><br><span class="line">	<span class="type">byte</span>[] aesKey;</span><br><span class="line">	String token;</span><br><span class="line">	String appId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造函数</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> token          公众平台上，开发者设置的token</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encodingAesKey 公众平台上，开发者设置的EncodingAESKey</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> appId          公众平台appid</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException 执行失败，请查看该异常的错误码和具体的错误信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WXBizMsgCrypt</span><span class="params">(String token, String encodingAesKey, String appId)</span> <span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		<span class="keyword">if</span> (encodingAesKey.length() != <span class="number">43</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.IllegalAesKey);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.token = token;</span><br><span class="line">		<span class="built_in">this</span>.appId = appId;</span><br><span class="line">		aesKey = Base64.decodeBase64(encodingAesKey + <span class="string">&quot;=&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还原4个字节的网络字节序</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">recoverNetworkBytesOrder</span><span class="params">(<span class="type">byte</span>[] orderBytes)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sourceNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			sourceNumber &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">			sourceNumber |= orderBytes[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sourceNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对密文进行解密.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> text 需要解密的密文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 解密得到的明文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException aes解密失败</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String <span class="title function_">decrypt</span><span class="params">(String text)</span> <span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		<span class="type">byte</span>[] original;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 设置解密模式为AES的CBC模式</span></span><br><span class="line">			<span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/NoPadding&quot;</span>);</span><br><span class="line">			<span class="type">SecretKeySpec</span> <span class="variable">key_spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(aesKey, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">			<span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(Arrays.copyOfRange(aesKey, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">			cipher.init(Cipher.DECRYPT_MODE, key_spec, iv);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用BASE64对密文进行解码</span></span><br><span class="line">			<span class="type">byte</span>[] encrypted = Base64.decodeBase64(text);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 解密</span></span><br><span class="line">			original = cipher.doFinal(encrypted);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.DecryptAESError);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String xmlContent, from_appid;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 去除补位字符</span></span><br><span class="line">			<span class="type">byte</span>[] bytes = PKCS7Encoder.decode(original);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 分离16位随机字符串,网络字节序和AppId</span></span><br><span class="line">			<span class="type">byte</span>[] networkOrder = Arrays.copyOfRange(bytes, <span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> <span class="variable">xmlLength</span> <span class="operator">=</span> recoverNetworkBytesOrder(networkOrder);</span><br><span class="line"></span><br><span class="line">			xmlContent = <span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(bytes, <span class="number">20</span>, <span class="number">20</span> + xmlLength), CHARSET);</span><br><span class="line">			from_appid =</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(bytes, <span class="number">20</span> + xmlLength, bytes.length), CHARSET);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.IllegalBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// appid不相同的情况</span></span><br><span class="line">		<span class="keyword">if</span> (!from_appid.equals(appId)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ValidateSignatureError);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> xmlContent;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * * 检验消息的真实性，并且获取解密后的明文.</span></span><br><span class="line"><span class="comment">	 * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;利用收到的密文生成安全签名，进行签名验证&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;若验证通过，则提取xml中的加密消息&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;对消息进行解密&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> msgSignature 签名串，对应URL参数的msg_signature</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timeStamp    时间戳，对应URL参数的timestamp</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nonce        随机串，对应URL参数的nonce</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> postData     密文，对应POST请求的数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 解密后的原文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException 执行失败，请查看该异常的错误码和具体的错误信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">decryptMsg</span><span class="params">(String msgSignature, String timeStamp, String nonce, String postData)</span></span><br><span class="line">			<span class="keyword">throws</span> AesException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 密钥，公众账号的app secret</span></span><br><span class="line">		<span class="comment">// 提取密文</span></span><br><span class="line">		Object[] encrypt = extract(postData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 验证安全签名</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> getSHA1(token, timeStamp, nonce, encrypt[<span class="number">1</span>].toString());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 和URL中的签名比较是否相等</span></span><br><span class="line">		<span class="comment">// System.out.println(&quot;第三方收到URL中的签名：&quot; + msg_sign);</span></span><br><span class="line">		<span class="comment">// System.out.println(&quot;第三方校验签名：&quot; + signature);</span></span><br><span class="line">		<span class="keyword">if</span> (!signature.equals(msgSignature)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ValidateSignatureError);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解密</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> decrypt(encrypt[<span class="number">1</span>].toString());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提取出xml数据包中的加密消息</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xmltext 待提取的xml字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 提取出的加密消息字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Object[] extract(String xmltext) <span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		Object[] result = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">			dbf.setXIncludeAware(<span class="literal">false</span>);</span><br><span class="line">			dbf.setExpandEntityReferences(<span class="literal">false</span>);</span><br><span class="line">			<span class="type">DocumentBuilder</span> <span class="variable">db</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line">			<span class="type">StringReader</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(xmltext);</span><br><span class="line">			<span class="type">InputSource</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(sr);</span><br><span class="line">			<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> db.parse(is);</span><br><span class="line"></span><br><span class="line">			<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getDocumentElement();</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nodelist1</span> <span class="operator">=</span> root.getElementsByTagName(<span class="string">&quot;Encrypt&quot;</span>);</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nodelist2</span> <span class="operator">=</span> root.getElementsByTagName(<span class="string">&quot;ToUserName&quot;</span>);</span><br><span class="line">			result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			result[<span class="number">1</span>] = nodelist1.item(<span class="number">0</span>).getTextContent();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//注意这里,获取ticket中的xml里面没有ToUserName这个元素,官网原示例代码在这里会报空</span></span><br><span class="line">			<span class="comment">//空指针,所以需要处理一下</span></span><br><span class="line">			<span class="keyword">if</span> (nodelist2 != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nodelist2.item(<span class="number">0</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">					result[<span class="number">2</span>] = nodelist2.item(<span class="number">0</span>).getTextContent();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ParseXmlError);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用SHA1算法生成安全签名</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> token     票据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timestamp 时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nonce     随机字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encrypt   密文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 安全签名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSHA1</span><span class="params">(String token, String timestamp, String nonce, String encrypt)</span></span><br><span class="line">			<span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;token, timestamp, nonce, encrypt&#125;;</span><br><span class="line">			<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">			<span class="comment">// 字符串排序</span></span><br><span class="line">			Arrays.sort(array);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">				sb.append(array[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">			<span class="comment">// SHA1签名生成</span></span><br><span class="line">			<span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">			md.update(str.getBytes());</span><br><span class="line">			<span class="type">byte</span>[] digest = md.digest();</span><br><span class="line"></span><br><span class="line">			<span class="type">StringBuffer</span> <span class="variable">hexstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">			<span class="type">String</span> <span class="variable">shaHex</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digest.length; i++) &#123;</span><br><span class="line">				shaHex = Integer.toHexString(digest[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">				<span class="keyword">if</span> (shaHex.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">					hexstr.append(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				hexstr.append(shaHex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> hexstr.toString();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ComputeSignatureError);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PKCS7Encode.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供基于PKCS7算法的加解密接口.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PKCS7Encoder</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">BLOCK_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得对明文进行补位填充的字节.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> count 需要进行填充补位操作的明文字节个数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 补齐用的字节数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">byte</span>[] encode(<span class="type">int</span> count) &#123;</span><br><span class="line">		<span class="comment">// 计算需要填充的位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">amountToPad</span> <span class="operator">=</span> BLOCK_SIZE - (count % BLOCK_SIZE);</span><br><span class="line">		<span class="keyword">if</span> (amountToPad == <span class="number">0</span>) &#123;</span><br><span class="line">			amountToPad = BLOCK_SIZE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获得补位所用的字符</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">padChr</span> <span class="operator">=</span> chr(amountToPad);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; amountToPad; index++) &#123;</span><br><span class="line">			tmp += padChr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp.getBytes(CHARSET);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除解密后明文的补位字符</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> decrypted 解密后的明文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 删除补位字符后的明文</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">byte</span>[] decode(<span class="type">byte</span>[] decrypted) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pad</span> <span class="operator">=</span> (<span class="type">int</span>) decrypted[decrypted.length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (pad &lt; <span class="number">1</span> || pad &gt; <span class="number">32</span>) &#123;</span><br><span class="line">			pad = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOfRange(decrypted, <span class="number">0</span>, decrypted.length - pad);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将数字转化成ASCII码对应的字符，用于对明文进行补码</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a 需要转化的数字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 转化得到的字符</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span> <span class="title function_">chr</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">target</span> <span class="operator">=</span> (<span class="type">byte</span>) (a &amp; <span class="number">0xFF</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">char</span>) target;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXXmlToMapUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentHelper;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.OutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.XMLWriter;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.OutputKeys;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Transformer;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.dom.DOMSource;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.stream.StreamResult;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXXmlToMapUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(WXXmlToMapUtil.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * XML格式字符串转换为Map</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xml XML字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> XML数据转换后的Map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">xmlToMap</span><span class="params">(String xml)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			<span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">			<span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(xml.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">			org.w3c.dom.<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> documentBuilder.parse(stream);</span><br><span class="line">			doc.getDocumentElement().normalize();</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nodeList</span> <span class="operator">=</span> doc.getDocumentElement().getChildNodes();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; nodeList.getLength(); ++idx) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeList.item(idx);</span><br><span class="line">				<span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">					org.w3c.dom.<span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> (org.w3c.dom.Element) node;</span><br><span class="line">					data.put(element.getNodeName(), element.getTextContent());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			stream.close();</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将Map转换为XML格式的字符串</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data Map类型数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> XML格式的字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">mapToXml</span><span class="params">(Map&lt;String, String&gt; data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">			<span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">			org.w3c.dom.<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.newDocument();</span><br><span class="line">			org.w3c.dom.<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;xml&quot;</span>);</span><br><span class="line">			document.appendChild(root);</span><br><span class="line">			<span class="keyword">for</span> (String key : data.keySet()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> data.get(key);</span><br><span class="line">				<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">					value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				value = value.trim();</span><br><span class="line">				org.w3c.dom.<span class="type">Element</span> <span class="variable">filed</span> <span class="operator">=</span> document.createElement(key);</span><br><span class="line">				filed.appendChild(document.createTextNode(value));</span><br><span class="line">				root.appendChild(filed);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();</span><br><span class="line">			<span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> tf.newTransformer();</span><br><span class="line">			<span class="type">DOMSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DOMSource</span>(document);</span><br><span class="line">			transformer.setOutputProperty(OutputKeys.ENCODING, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			transformer.setOutputProperty(OutputKeys.INDENT, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">			<span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">			<span class="type">StreamResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamResult</span>(writer);</span><br><span class="line">			transformer.transform(source, result);</span><br><span class="line">			<span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> writer.getBuffer().toString(); <span class="comment">//.replaceAll(&quot;\n|\r&quot;, &quot;&quot;);</span></span><br><span class="line">			writer.close();</span><br><span class="line">			<span class="keyword">return</span> output;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (多层)xml格式字符串转换为map</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xml xml字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 第一个为Root节点，Root节点之后为Root的元素，如果为多层，可以通过key获取下一层Map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">multilayerXmlToMap</span><span class="params">(String xml)</span> &#123;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doc = DocumentHelper.parseText(xml);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">			logger.error(<span class="string">&quot;xml字符串解析，失败 --&gt; &#123;&#125;&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> == doc) &#123;</span><br><span class="line">			<span class="keyword">return</span> map;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取根元素</span></span><br><span class="line">		<span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> doc.getRootElement();</span><br><span class="line">		recursionXmlToMap(rootElement, map);</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * multilayerXmlToMap核心方法，递归调用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element 节点元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> outmap  用于存储xml数据的map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursionXmlToMap</span><span class="params">(Element element, Map&lt;String, Object&gt; outmap)</span> &#123;</span><br><span class="line">		<span class="comment">// 得到根元素下的子元素列表</span></span><br><span class="line">		List&lt;Element&gt; list = element.elements();</span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">		<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果没有子元素,则将其存储进map中</span></span><br><span class="line">			outmap.put(element.getName(), element.getTextTrim());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// innermap用于存储子元素的属性名和属性值</span></span><br><span class="line">			Map&lt;String, Object&gt; innermap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			<span class="comment">// 遍历子元素</span></span><br><span class="line">			list.forEach(childElement -&gt; recursionXmlToMap(childElement, innermap));</span><br><span class="line">			outmap.put(element.getName(), innermap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (多层)map转换为xml格式字符串</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map     需要转换为xml的map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> isCDATA 是否加入CDATA标识符 true:加入 false:不加入</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> xml字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">multilayerMapToXml</span><span class="params">(Map&lt;String, Object&gt; map, <span class="type">boolean</span> isCDATA)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">parentName</span> <span class="operator">=</span> <span class="string">&quot;xml&quot;</span>;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> DocumentHelper.createDocument();</span><br><span class="line">		doc.addElement(parentName);</span><br><span class="line">		<span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> recursionMapToXml(doc.getRootElement(), parentName, map, isCDATA);</span><br><span class="line">		<span class="keyword">return</span> formatXML(xml);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * multilayerMapToXml核心方法，递归调用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element    节点元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentName 根元素属性名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map        需要转换为xml的map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> isCDATA    是否加入CDATA标识符 true:加入 false:不加入</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> xml字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">recursionMapToXml</span><span class="params">(Element element, String parentName, Map&lt;String, Object&gt; map, <span class="type">boolean</span> isCDATA)</span> &#123;</span><br><span class="line">		<span class="type">Element</span> <span class="variable">xmlElement</span> <span class="operator">=</span> element.addElement(parentName);</span><br><span class="line">		map.keySet().forEach(key -&gt; &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">				recursionMapToXml(xmlElement, key, (Map&lt;String, Object&gt;) obj, isCDATA);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> obj == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : obj.toString();</span><br><span class="line">				<span class="keyword">if</span> (isCDATA) &#123;</span><br><span class="line">					xmlElement.addElement(key).addCDATA(value);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					xmlElement.addElement(key).addText(value);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> xmlElement.asXML();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 格式化xml,显示为容易看的XML格式</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xml 需要格式化的xml字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">formatXML</span><span class="params">(String xml)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">requestXML</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 拿取解析器</span></span><br><span class="line">			<span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">			<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(<span class="keyword">new</span> <span class="title class_">StringReader</span>(xml));</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">null</span> != document) &#123;</span><br><span class="line">				<span class="type">StringWriter</span> <span class="variable">stringWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">				<span class="comment">// 格式化,每一级前的空格</span></span><br><span class="line">				<span class="type">OutputFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputFormat</span>(<span class="string">&quot;    &quot;</span>, <span class="literal">true</span>);</span><br><span class="line">				<span class="comment">// xml声明与内容是否添加空行</span></span><br><span class="line">				format.setNewLineAfterDeclaration(<span class="literal">false</span>);</span><br><span class="line">				<span class="comment">// 是否设置xml声明头部</span></span><br><span class="line">				format.setSuppressDeclaration(<span class="literal">false</span>);</span><br><span class="line">				<span class="comment">// 是否分行</span></span><br><span class="line">				format.setNewlines(<span class="literal">true</span>);</span><br><span class="line">				<span class="type">XMLWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLWriter</span>(stringWriter, format);</span><br><span class="line">				writer.write(document);</span><br><span class="line">				writer.flush();</span><br><span class="line">				writer.close();</span><br><span class="line">				requestXML = stringWriter.getBuffer().toString();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> requestXML;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.error(<span class="string">&quot;格式化xml，失败 --&gt; &#123;&#125;&quot;</span>, e);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AesException.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AesException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">OK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ValidateSignatureError</span> <span class="operator">=</span> -<span class="number">40001</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ParseXmlError</span> <span class="operator">=</span> -<span class="number">40002</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ComputeSignatureError</span> <span class="operator">=</span> -<span class="number">40003</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">IllegalAesKey</span> <span class="operator">=</span> -<span class="number">40004</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ValidateCorpidError</span> <span class="operator">=</span> -<span class="number">40005</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">EncryptAESError</span> <span class="operator">=</span> -<span class="number">40006</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DecryptAESError</span> <span class="operator">=</span> -<span class="number">40007</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">IllegalBuffer</span> <span class="operator">=</span> -<span class="number">40008</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">			<span class="keyword">case</span> ValidateSignatureError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;签名验证错误&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> ParseXmlError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;xml解析失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> ComputeSignatureError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;sha加密生成签名失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> IllegalAesKey:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;SymmetricKey非法&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> ValidateCorpidError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;corpid校验失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> EncryptAESError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;aes加密失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> DecryptAESError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;aes解密失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> IllegalBuffer:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;解密后得到的buffer非法&quot;</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// cannot be</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AesException(<span class="type">int</span> code) &#123;</span><br><span class="line">		<span class="built_in">super</span>(getMessage(code));</span><br><span class="line">		<span class="built_in">this</span>.code = code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、获取component-access-token">2、获取component_access_token</h3>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9UaGlyZFBhcnR5L3Rva2VuL2NvbXBvbmVudF9hY2Nlc3NfdG9rZW4uaHRtbA==">令牌 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="实现类-2">实现类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getComponentAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">componentAccessTokenUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_component_token&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(CacheKey.COMPONENT_ACCESS_TOKEN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisUtils.getExpire(CacheKey.COMPONENT_ACCESS_TOKEN) &gt; <span class="number">10</span> * <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    <span class="comment">//第三方平台的appid、appsecret</span></span><br><span class="line">    params.put(<span class="string">&quot;component_appid&quot;</span>, APPID);</span><br><span class="line">    params.put(<span class="string">&quot;component_appsecret&quot;</span>, AppSecret);</span><br><span class="line">    String component_verify_ticket;</span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(CacheKey.OPEN_PLATFORM_TICKET)) &#123;</span><br><span class="line">        component_verify_ticket = (String) redisUtils.get(CacheKey.OPEN_PLATFORM_TICKET);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//查询数据库中的component_verify_ticket</span></span><br><span class="line">        component_verify_ticket = platformMapper.selectTicket();</span><br><span class="line">        redisUtils.set(CacheKey.OPEN_PLATFORM_TICKET, component_verify_ticket, <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(component_verify_ticket)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    params.put(<span class="string">&quot;component_verify_ticket&quot;</span>, component_verify_ticket);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.post(componentAccessTokenUrl, JSON.toJSONString(params)));</span><br><span class="line">    <span class="keyword">if</span> (data.containsKey(<span class="string">&quot;component_access_token&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">componentAccessToken</span> <span class="operator">=</span> data.getString(<span class="string">&quot;component_access_token&quot;</span>);</span><br><span class="line">        <span class="comment">//将component_access_token存入redis中，并设置2个小时的过期时间</span></span><br><span class="line">        redisUtils.set(CacheKey.COMPONENT_ACCESS_TOKEN, componentAccessToken, <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    redisUtils.del(CacheKey.COMPONENT_ACCESS_TOKEN);</span><br><span class="line">    redisUtils.del(CacheKey.OPEN_PLATFORM_TICKET);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;获取component_access_token失败,请重试,接口返回信息：&quot;</span> + data.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、获取authorizer-access-token">3、获取authorizer_access_token</h3>
<h4 id="步骤：">步骤：</h4>
<h4 id="获取预授权码pre-auth-code——-微信公众平台管理员授权——-获取authorizer-access-token-authorizer-refresh-token">获取预授权码pre_auth_code——&gt;微信公众平台管理员授权——&gt;获取authorizer_access_token&amp;authorizer_refresh_token</h4>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9CZWZvcmVfRGV2ZWxvcC9BdXRob3JpemF0aW9uX1Byb2Nlc3NfVGVjaG5pY2FsX0Rlc2NyaXB0aW9uLmh0bWw=">https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Authorization_Process_Technical_Description.html<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="①获取预授权码pre-auth-code">①获取预授权码pre_auth_code</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPreAuthCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先判断component_access_token是否过期，如果过期重新获取</span></span><br><span class="line">    getComponentAccessToken();</span><br><span class="line">    <span class="type">String</span> <span class="variable">preAuthCodeUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_create_preauthcode?component_access_token=&quot;</span> + redisUtils.get(CacheKey.COMPONENT_ACCESS_TOKEN);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    params.put(<span class="string">&quot;component_appid&quot;</span>, APPID);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.post(preAuthCodeUrl, JSON.toJSONString(params)));</span><br><span class="line">    <span class="keyword">if</span> (data.containsKey(<span class="string">&quot;pre_auth_code&quot;</span>)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> data.getString(<span class="string">&quot;pre_auth_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;获取预授权失败,接口返回信息：&quot;</span> + data.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="②微信公众平台管理员授权">②微信公众平台管理员授权</h4>
<p>生成授权链接，可以在前端用a标签填入这个接口地址，点击a标签打开新标签页，管理员进行扫码授权</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toAuthorization</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">authUrl</span> <span class="operator">=</span> <span class="string">&quot;https://mp.weixin.qq.com/cgi-bin/componentloginpagecomponent_appid=%s&amp;pre_auth_code=%s&amp;redirect_uri=%s&amp;auth_type=1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> <span class="string">&quot;https://服务端地址/callback&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">preAuthCode</span> <span class="operator">=</span> getPreAuthCode();</span><br><span class="line">    response.setStatus(<span class="number">301</span>);</span><br><span class="line">    response.sendRedirect(String.format(authUrl, APPID, preAuthCode, redirectUrl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>授权之后，会回调：“<span class="exturl" data-url="aHR0cHM6Ly94bi0temZyeTlobmI3MzJoZ294L2NhbGxiYWNr">https://服务端地址/callback<i class="fa fa-external-link-alt"></i></span>”，并将授权码auth_code携带到这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;微信开放平台：用户授权后，回调地址&quot;, notes = &quot;zhuguangliang&quot;)</span></span><br><span class="line">	<span class="meta">@AnonymousGetMapping(&quot;/callback&quot;)</span></span><br><span class="line">	<span class="meta">@Notice(&quot;2393194918@qq.com&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(String auth_code)</span> &#123;</span><br><span class="line"><span class="comment">//		openPlatformService.getAuthorizationInfo(auth_code);</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="③获取authorizer-access-token-authorizer-refresh-token">③获取authorizer_access_token&amp;authorizer_refresh_token</h4>
<p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9UaGlyZFBhcnR5L3Rva2VuL2F1dGhvcml6YXRpb25faW5mby5odG1s">https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/authorization_info.html<i class="fa fa-external-link-alt"></i></span></p>
<p>说明：authorization_code就是授权之后，返回的授权码</p>
<p>如果你使用微信的第三方平台管理工具，可以在数据库中直接获取authorizer_refresh_token，然后根据：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9UaGlyZFBhcnR5L3Rva2VuL2FwaV9hdXRob3JpemVyX3Rva2VuLmh0bWw=">获取/刷新接口调用令牌 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span>这个接口进行刷新authorizer_access_token，下面是实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//authorizerAppId为授权的appid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAuthorizationInfo</span><span class="params">(String authorizerAppId)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CacheKey.AUTH_ACCESS_TOKEN + authorizerAppId;</span><br><span class="line">    <span class="comment">//这一步是为如果发现这个token快过期，则刷新</span></span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(key) &amp;&amp; redisUtils.getExpire(key) &gt; <span class="number">5</span> * <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getComponentAccessToken();</span><br><span class="line">    <span class="type">String</span> <span class="variable">refreshTokenUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_authorizer_token?component_access_token=&quot;</span> + redisUtils.get(CacheKey.COMPONENT_ACCESS_TOKEN);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    param.put(<span class="string">&quot;component_appid&quot;</span>, APPID);</span><br><span class="line">    param.put(<span class="string">&quot;authorizer_appid&quot;</span>, authorizerAppId);</span><br><span class="line">    String refreshToken;</span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(CacheKey.AUTH_REFRESH_TOKEN + authorizerAppId)) &#123;</span><br><span class="line">        refreshToken = (String) redisUtils.get(CacheKey.AUTH_REFRESH_TOKEN + authorizerAppId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从微信第三方管理工具的数据库中查询出authorizer_refresh_token</span></span><br><span class="line">        refreshToken = platformMapper.selectRefreshTokenByAppId(authorizerAppId);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(refreshToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;小程序管理员未授权，请让小程序管理员重新授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算刷新令牌的过期时间</span></span><br><span class="line">         <span class="comment">//从微信第三方管理工具的数据库中查询出authorizer_refresh_token的过期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">authTime</span> <span class="operator">=</span> platformMapper.selectAuthTimeByAppId(authorizerAppId).toLocalDateTime();</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(authTime, LocalDateTime.now());</span><br><span class="line">        redisUtils.set(CacheKey.AUTH_REFRESH_TOKEN + authorizerAppId, refreshToken, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> - (duration.toMillis() / <span class="number">1000</span> + <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    param.put(<span class="string">&quot;authorizer_refresh_token&quot;</span>, refreshToken);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">tokenData</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.post(refreshTokenUrl, JSON.toJSONString(param)));</span><br><span class="line">    <span class="keyword">if</span> (tokenData.containsKey(<span class="string">&quot;authorizer_access_token&quot;</span>)) &#123;</span><br><span class="line">        redisUtils.set(CacheKey.AUTH_ACCESS_TOKEN + authorizerAppId, tokenData.getString(<span class="string">&quot;authorizer_access_token&quot;</span>), <span class="number">2</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        LambdaUpdateWrapper&lt;SpiritOpenPlatform&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        updateWrapper.eq(SpiritOpenPlatform::getAppid, authorizerAppId);</span><br><span class="line">        <span class="type">SpiritOpenPlatform</span> <span class="variable">openPlatform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpiritOpenPlatform</span>();</span><br><span class="line">        openPlatform.setAuthorizerRefreshToken(refreshToken);</span><br><span class="line">        openPlatform.setAuthorizerAccessToken(tokenData.getString(<span class="string">&quot;authorizer_access_token&quot;</span>));</span><br><span class="line">        platformMapper.update(openPlatform, updateWrapper);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;获取authorizer_access_token失败,接口返回信息：&quot;</span> + tokenData.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，微信第三方平台开发中的关键token，authorizer_access_token已经成功获取</p>
<h3 id="4、调接口发布小程序">4、调接口发布小程序</h3>
<h4 id="提交代码接口：上传小程序代码并生成体验版-微信开放文档-qq-com">提交代码接口：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9jb2RlL2NvbW1pdC5odG1s">上传小程序代码并生成体验版 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></h4>
<h4 id="设置用户隐私接口：配置小程序用户隐私保护指引-微信开放文档-qq-com">设置用户隐私接口：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9wcml2YWN5X2NvbmZpZy9zZXRfcHJpdmFjeV9zZXR0aW5nLmh0bWw=">配置小程序用户隐私保护指引 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></h4>
<h4 id="提交审核接口：提交审核-微信开放文档-qq-com">提交审核接口：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9jb2RlL3N1Ym1pdF9hdWRpdC5odG1s">提交审核 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></h4>
<h4 id="查询审核结果接口：查询最新一次提交的审核状态-微信开放文档-qq-com">查询审核结果接口：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29wbGF0Zm9ybS9UaGlyZC1wYXJ0eV9QbGF0Zm9ybXMvMi4wL2FwaS9jb2RlL2dldF9sYXRlc3RfYXVkaXRzdGF0dXMuaHRtbA==">查询最新一次提交的审核状态 | 微信开放文档 (qq.com)<i class="fa fa-external-link-alt"></i></span></h4>
<ul>
<li>项目中可以采用定时任务的策略调用该接口</li>
</ul>
<h2 id="最后-3">最后</h2>
<p>总结：微信第三方平台开发的流程，涉及的接口有点多，微信的文档其实也写的很详细了，但是在开发过程中，免不了遇见莫名其妙的问题，这个时候可以在微信开放社区里找找或者搜下博客。</p>
]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>第三方平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring启动流程</title>
    <url>/posts/7938.html</url>
    <content><![CDATA[<p>本文将以XMl定义bean的方式，从创建应用上下文对象剖析Spring的容器初始化，以及对单实例非懒加载 Bean 完成创建和Bean 属性的赋值注入和初始化，以及消息派发器的创建和启动过程消息的触发。</p>
<span id="more"></span>
<h3 id="准备">准备</h3>
<h4 id="spring-xml">spring.xml</h4>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;bean id<span class="operator">=</span><span class="string">&quot;person&quot;</span> class<span class="operator">=</span><span class="string">&quot;xxxx.Person&quot;</span>&gt;</span><br><span class="line">	&lt;property name<span class="operator">=</span><span class="string">&quot;id&quot;</span> value<span class="operator">=</span><span class="string">&quot;1&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name<span class="operator">=</span><span class="string">&quot;name&quot;</span> value<span class="operator">=</span><span class="string">&quot;zhangsan&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="创建对象">创建对象</h4>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析bean配置文件</span></span><br><span class="line">ApplicationContext ac=<span class="keyword">new</span> <span class="type">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="开始探究">开始探究</h3>
<ul>
<li>
<p>进入ClassPathXmlApplicationContext：构造方法</p>
<ul>
<li>
<p>方法：super(parent)—&gt;进入父类AbstractApplicaitonContext：调用父类构造方法，进行相关对象的创建等操作</p>
<ul>
<li>进入AbstractXmlApplicationContext: 构造方法
<ul>
<li>…
<ul>
<li>AbstactApplicationContext类
<ul>
<li>进入构造方法
<ul>
<li>this.resourcePatternResolver=getResourcePatternResolver();//创建资源模式处理器，创建容器id值等。</li>
</ul>
</li>
<li>进入getResourcePatternResolver()方法
<ul>
<li>进入pathmathcingResourcePatternResolver类
<ul>
<li>属性：pathMatcher()new AntPathMatcher();//路径匹配</li>
</ul>
</li>
</ul>
</li>
<li>进入重载的构造方法(@Nullable ApplicationContext parent)
<ul>
<li>进入方法：setParent(parent)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性: validating=true//设置xml文件的验证标志，默认开启验证</li>
</ul>
</li>
<li>
<p>方法：setConfigLocations(configLocations)</p>
<ul>
<li>进入类AbstractRefreshConfigApplicationContext
<ul>
<li>setConfigLocations(@Nullable String… locations)
<ul>
<li>this.configLocations[i]=resolvePathlocations[i]).trim()</li>
</ul>
</li>
<li>进入resolvePath(String path)
<ul>
<li>getEnvironment().resolveRequiredPlaceholders(path)//
<ul>
<li>getEnvironment()：获取系统环境变量</li>
<li>resolveRequiredPlaceholders(path)//处理占位符（路径上的，比如：spring-${username}.xml）</li>
</ul>
</li>
</ul>
</li>
<li>属性：String[] configLocations：定义配置路径，默认是字符串数组</li>
</ul>
</li>
</ul>
</li>
<li>
<p>方法（核心）：refresh()</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 1. 前期，做容器刷新前的准备工作</span></span><br><span class="line">prepare<span class="constructor">Refresh()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 2. 读取并解析XML文件、创建BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtain<span class="constructor">FreshBeanFactory()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 3. 预处理BeanFactory，给工厂设置属性值</span></span><br><span class="line">prepare<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">// 4. BeanFactory初始化后，进行后置处理工作</span></span><br><span class="line">post<span class="constructor">ProcessBeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 5. 执行 BeanFactoryPostProcessors</span></span><br><span class="line">invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 6. 注册 Bean 后置处理器  [intercept bean creation.]</span></span><br><span class="line">register<span class="constructor">BeanPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">// 7. 初始化MessageSource组件（做国际化功能，消息绑定，消息解析）</span></span><br><span class="line">init<span class="constructor">MessageSource()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">// 8. 初始化事件派发器</span></span><br><span class="line">init<span class="constructor">ApplicationEventMulticaster()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">// 9. 留给子容器（子类）</span></span><br><span class="line">on<span class="constructor">Refresh()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">// 10. 给容器中将所有的项目中的 ApplicationListener 注册进来</span></span><br><span class="line">register<span class="constructor">Listeners()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">// 11. 初始化所有的非懒加载单例Bean</span></span><br><span class="line">finish<span class="constructor">BeanFactoryInitialization(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">// 12. 执行Spring容器的声明周期（启动）和发布事件</span></span><br><span class="line">finish<span class="constructor">Refresh()</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="细说refresh">细说refresh()</h3>
<blockquote>
<p>功能分类</p>
<p>1 为准备环境</p>
<p>2 3 4 5 6 为准备 BeanFactory</p>
<p>7 8 9 10 12 为准备 ApplicationContext</p>
<p>11 为初始化 BeanFactory 中非延迟单例 bean</p>
</blockquote>
<h4 id="1、prepareRefresh-刷新前的预处理工作">1、prepareRefresh() 刷新前的预处理工作</h4>
<p>该方法其主要的作用是对上下文环境的初始化准备工作如对系统环境或者系统属性变量的准备验证过程,这个变量的设置可能会影响着系统的正确性,我们可以通过重写initPropertySources方法就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> * 设置容器的启动时间</span></span><br><span class="line"><span class="comment"> * 设置活跃状态为true</span></span><br><span class="line"><span class="comment"> * 设置关闭状态为false</span></span><br><span class="line"><span class="comment"> * 获取Environment对象，并加载系统的属性值到Environment对象中（初始化 context environment 中占位符.）</span></span><br><span class="line"><span class="comment"> * 当前环境的一些校验等.</span></span><br><span class="line"><span class="comment"> * 准备监听器和需要发布事件的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> void prepareRefresh() &#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="comment">//设置启动时间</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//设置当前上下文(Context)的状态</span></span><br><span class="line">    <span class="keyword">this</span>.closed.<span class="keyword">set</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.<span class="keyword">set</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    <span class="comment">// 初始化context environment（上下文环境）中的占位符属性来源</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    <span class="comment">//验证当前上下文需要的属性是否放入环境中</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">    <span class="comment">//判断刷新前的应用程序监听器集合是否为空，如果为空，则将监听器添加到此集合中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">        <span class="comment">//如果不等于空，则清空集合元素对象</span></span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在Spring MVC 中对 <code>initPropertySources</code> 方法做了实现，将 Servlet 容器相关的信息放到了 environment 中，实现如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initPropertySources</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(<span class="built_in">this</span>.servletContext, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、obtainFreshBeanFactory-刷新BeanFactory">2、obtainFreshBeanFactory() 刷新BeanFactory</h4>
<p>该方法的作用是解析XML文件中的bean，包装成 BeanDefinition，并放入 BeanFactory 中的 beanDefinitionMap 集合</p>
<blockquote>
<p>BeanDefinition对象</p>
<ul>
<li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等。</li>
<li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//初始化BeanFactory，并进行XML文件读取，并将得到BeanFactory记录在当前实体的属性中</span></span><br><span class="line">		refreshBeanFactory();</span><br><span class="line">		<span class="comment">//返回当前实体的beanfactory属性</span></span><br><span class="line">		<span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">↓</span><br><span class="line">AbstractRefreshableApplicationContext.java</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	* This implementation performs an actual refresh of this context&#x27;s underlying</span></span><br><span class="line"><span class="comment"> 	* bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> 	* initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span></span><br><span class="line"><span class="comment"> 	* 首先是对当前容器的判断,如果已存在beanFactory则将其移除该beanFactory创建的bean和移除自身</span></span><br><span class="line"><span class="comment">    * 接着是调用#createBeanFactory()方法来创建beanFactory实例</span></span><br><span class="line"><span class="comment">    * 给beanfactory设置序列化id</span></span><br><span class="line"><span class="comment">    * 加载beanDefinition</span></span><br><span class="line"><span class="comment">    * 将创建好的 bean 工厂的引用交给的 context 来管理</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">//如果存在beanFactory,则销毁beanFactory</span></span><br><span class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建DefaultListableBeanFactory对象</span></span><br><span class="line">			<span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">			<span class="comment">//为了序列化指定id，可以从id反序化到beanFactory对象</span></span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			<span class="comment">//定制beanFactory，设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖</span></span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			<span class="comment">//序列化documentReader,并进行XML文件读取及解析</span></span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			<span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3、prepareBeanFactory-beanFactory-给beanFactory设置各种各样的功能">3、prepareBeanFactory(beanFactory)  给beanFactory设置各种各样的功能</h4>
<p>这一步会进一步完善 BeanFactory，为它的各项成员变量赋值</p>
<ul>
<li>
<p>beanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver</p>
</li>
<li>
<p>propertyEditorRegistrars 会注册类型转换器</p>
<p>它在这里使用了 ResourceEditorRegistrar 实现类</p>
</li>
<li>
<p>并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</p>
</li>
<li>
<p>registerResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入</p>
</li>
<li>
<p>beanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：</p>
</li>
<li>
<p>ApplicationContextAwareProcessor 用来解析 Aware 接口</p>
</li>
<li>
<p>ApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean</p>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory&#x27;s standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context&#x27;s ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * @param beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected void prepare<span class="constructor">BeanFactory(ConfigurableListableBeanFactory <span class="params">beanFactory</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">    <span class="comment">//设置beanFactory的classLoader为当前上下文的classLoader</span></span><br><span class="line">    beanFactory.set<span class="constructor">BeanClassLoader(<span class="params">getClassLoader</span>()</span>);</span><br><span class="line">    <span class="comment">//设置beanFactory的表达式语言处理器</span></span><br><span class="line">    <span class="comment">//默认可以使用#&#123;bean.xxx&#125;的形式来调用相关属性值</span></span><br><span class="line">    beanFactory.set<span class="constructor">BeanExpressionResolver(<span class="params">new</span> StandardBeanExpressionResolver(<span class="params">beanFactory</span>.<span class="params">getBeanClassLoader</span>()</span>));</span><br><span class="line">    <span class="comment">//为beanFactory增加一个默认的PropertyEditor,主要是针对bean的属性等设置管理统一的一个tool</span></span><br><span class="line">    beanFactory.add<span class="constructor">PropertyEditorRegistrar(<span class="params">new</span> ResourceEditorRegistrar(<span class="params">this</span>, <span class="params">getEnvironment</span>()</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    <span class="comment">//添加beanPostProcessor</span></span><br><span class="line">    beanFactory.add<span class="constructor">BeanPostProcessor(<span class="params">new</span> ApplicationContextAwareProcessor(<span class="params">this</span>)</span>);</span><br><span class="line">    <span class="comment">//设置几个忽略自动装配的接口</span></span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(EnvironmentAware.<span class="params">class</span>)</span>;</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(EmbeddedValueResolverAware.<span class="params">class</span>)</span>;</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(ResourceLoaderAware.<span class="params">class</span>)</span>;</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(ApplicationEventPublisherAware.<span class="params">class</span>)</span>;</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(MessageSourceAware.<span class="params">class</span>)</span>;</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(ApplicationContextAware.<span class="params">class</span>)</span>;</span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    <span class="comment">//设置几个自动装配的特殊规则</span></span><br><span class="line">    beanFactory.register<span class="constructor">ResolvableDependency(BeanFactory.<span class="params">class</span>, <span class="params">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.register<span class="constructor">ResolvableDependency(ResourceLoader.<span class="params">class</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    beanFactory.register<span class="constructor">ResolvableDependency(ApplicationEventPublisher.<span class="params">class</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    beanFactory.register<span class="constructor">ResolvableDependency(ApplicationContext.<span class="params">class</span>, <span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.add<span class="constructor">BeanPostProcessor(<span class="params">new</span> ApplicationListenerDetector(<span class="params">this</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="comment">//增加对AspectJ的支持</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.contains<span class="constructor">Bean(LOAD_TIME_WEAVER_BEAN_NAME)</span>) &#123;</span><br><span class="line">        beanFactory.add<span class="constructor">BeanPostProcessor(<span class="params">new</span> LoadTimeWeaverAwareProcessor(<span class="params">beanFactory</span>)</span>);</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.set<span class="constructor">TempClassLoader(<span class="params">new</span> ContextTypeMatchClassLoader(<span class="params">beanFactory</span>.<span class="params">getBeanClassLoader</span>()</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="comment">// 注册默认的系统环境bean</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.contains<span class="constructor">LocalBean(ENVIRONMENT_BEAN_NAME)</span>) &#123;</span><br><span class="line">        beanFactory.register<span class="constructor">Singleton(ENVIRONMENT_BEAN_NAME, <span class="params">getEnvironment</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.contains<span class="constructor">LocalBean(SYSTEM_PROPERTIES_BEAN_NAME)</span>) &#123;</span><br><span class="line">        beanFactory.register<span class="constructor">Singleton(SYSTEM_PROPERTIES_BEAN_NAME, <span class="params">getEnvironment</span>()</span>.get<span class="constructor">SystemProperties()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.contains<span class="constructor">LocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)</span>) &#123;</span><br><span class="line">        beanFactory.register<span class="constructor">Singleton(SYSTEM_ENVIRONMENT_BEAN_NAME, <span class="params">getEnvironment</span>()</span>.get<span class="constructor">SystemEnvironment()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、postProcessBeanFactory-beanFactory-给子类做扩展实现">4、postProcessBeanFactory(beanFactory) 给子类做扩展实现</h4>
<p>允许在子类中对beanFactory进行扩展处理。比如添加ware相关接口自动装配设置，添加后置处理器等，是子类扩展prepareBeanFactory(beanFactory)的方法。</p>
<blockquote>
<p>例如：在spring-web中可以找到AbstractRefreshableWebApplicationContext.java</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected void post<span class="constructor">ProcessBeanFactory(ConfigurableListableBeanFactory <span class="params">beanFactory</span>)</span> &#123;</span><br><span class="line">    beanFactory.add<span class="constructor">BeanPostProcessor(<span class="params">new</span> ServletContextAwareProcessor(<span class="params">this</span>.<span class="params">servletContext</span>, <span class="params">this</span>.<span class="params">servletConfig</span>)</span>);</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(ServletContextAware.<span class="params">class</span>)</span>;</span><br><span class="line">    beanFactory.ignore<span class="constructor">DependencyInterface(ServletConfigAware.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">WebApplicationContextUtils</span>.</span></span>register<span class="constructor">WebApplicationScopes(<span class="params">beanFactory</span>, <span class="params">this</span>.<span class="params">servletContext</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">WebApplicationContextUtils</span>.</span></span>register<span class="constructor">EnvironmentBeans(<span class="params">beanFactory</span>, <span class="params">this</span>.<span class="params">servletContext</span>, <span class="params">this</span>.<span class="params">servletConfig</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程：</p>
<ul>
<li>首先是添加ServletContextAwareProcessor到我们的beanFactory容器中,其中processor 实现 BeanPostProcessor 接口,主要用于将ServletContext 传递给实现了 ServletContextAware 接口的 bean.</li>
<li>忽略一些装配接口ServletContextAware和ServletConfigAware等.</li>
<li>注册 WEB 应用特定的域(scope)到 beanFactory 中，方便WebApplicationContext 可以使用它们,常见的有: request   session response application等.</li>
<li>注册 WEB 应用特定的 Environment bean 到 beanFactory 中,以便WebApplicationContext 可以使用它们,常见的有:contextAttributes等.</li>
</ul>
<h4 id="5、invokeBeanFactoryPostProcessors-beanFactory-执行-BeanFactory-后置处理器">5、invokeBeanFactoryPostProcessors(beanFactory) 执行 BeanFactory 后置处理器</h4>
<p>此方法主要的作用是调用BeanFactory后置处理器（后置处理器充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition），并扫描加载完毕所有的BeanDefinition，然后执行所有postProcessBeanDefinitionRegistry方法和postProcessBeanFactory方法。</p>
<blockquote>
<p>常见的BeanFactory处理器有：</p>
<ul>
<li>ConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等</li>
</ul>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有的  BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment"> * 先执行实现了 PriorityOrdered 优先级接口BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment"> * 再执行实现了 Ordered 顺序接口的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment"> * 最后一步执行没有实现优先级接口或者顺序的接口的 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment"> * 获取所有的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> * 执行实现了 PriorityOrdered 优先级接口的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> * 执行实现了 Ordered 顺序接口的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> * 执行没有实现优先级接口或者顺序的接口的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;<span class="type">String</span>&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 如果BeanFactory刚好也是BeanDefinitionRegistry,则先执行BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 用于执行BeanFactoryPostProcessor.postProcessBeanFactory</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用于执行BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果postProcessor是BeanDefinitionRegistryPostProcessor则先执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                registryProcessor.<span class="built_in">postProcessBeanDefinitionRegistry</span>(registry);</span><br><span class="line">                registryProcessors.<span class="built_in">add</span>(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                regularPostProcessors.<span class="built_in">add</span>(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照不同排序优先级区分开不同的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行实现PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="comment">// 从Bean工厂中获取所有BeanDefinitionRegistryPostProcessor的Bean名称(未初始化的)</span></span><br><span class="line">        <span class="type">String</span>[] postProcessorNames =</span><br><span class="line">                beanFactory.<span class="built_in">getBeanNamesForType</span>(BeanDefinitionRegistryPostProcessor.<span class="keyword">class</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">String</span> ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory.<span class="built_in">isTypeMatch</span>(ppName, PriorityOrdered.<span class="keyword">class</span>)) &#123;</span><br><span class="line">                currentRegistryProcessors.<span class="built_in">add</span>(beanFactory.<span class="built_in">getBean</span>(ppName, BeanDefinitionRegistryPostProcessor.<span class="keyword">class</span>));</span><br><span class="line">                <span class="comment">// 执行过的会加入到这里面中进行重复验证防止重复执行</span></span><br><span class="line">                processedBeans.<span class="built_in">add</span>(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序PriorityOrdered.class,越小越大</span></span><br><span class="line">        <span class="built_in">sortPostProcessors</span>(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 和从上下文传进来的默认Processor合并</span></span><br><span class="line">        registryProcessors.<span class="built_in">addAll</span>(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 执行这些BeanPostProcessor,在这步之前BeanFactory中还只是有几个一开始初始化添加进去的系统Bean.这步会将所有定义的BeanDefinition扫描注册到BeanFactory中.这里会执行一个系统级的ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法.来将所有BeanDefinition扫描到容器中.可打断点查看</span></span><br><span class="line">        <span class="built_in">invokeBeanDefinitionRegistryPostProcessors</span>(currentRegistryProcessors, registry, beanFactory.<span class="built_in">getApplicationStartup</span>());</span><br><span class="line">        currentRegistryProcessors.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行实现Orderd优先级接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        postProcessorNames = beanFactory.<span class="built_in">getBeanNamesForType</span>(BeanDefinitionRegistryPostProcessor.<span class="keyword">class</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">String</span> ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.<span class="built_in">contains</span>(ppName) &amp;&amp; beanFactory.<span class="built_in">isTypeMatch</span>(ppName, Ordered.<span class="keyword">class</span>)) &#123;</span><br><span class="line">                currentRegistryProcessors.<span class="built_in">add</span>(beanFactory.<span class="built_in">getBean</span>(ppName, BeanDefinitionRegistryPostProcessor.<span class="keyword">class</span>));</span><br><span class="line">                processedBeans.<span class="built_in">add</span>(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和上面一样,排序、合并、执行</span></span><br><span class="line">        <span class="built_in">sortPostProcessors</span>(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.<span class="built_in">addAll</span>(currentRegistryProcessors);</span><br><span class="line">        <span class="built_in">invokeBeanDefinitionRegistryPostProcessors</span>(currentRegistryProcessors, registry, beanFactory.<span class="built_in">getApplicationStartup</span>());</span><br><span class="line">        currentRegistryProcessors.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后执行其他无要求的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="type">boolean</span> reiterate = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.<span class="built_in">getBeanNamesForType</span>(BeanDefinitionRegistryPostProcessor.<span class="keyword">class</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">String</span> ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.<span class="built_in">contains</span>(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.<span class="built_in">add</span>(beanFactory.<span class="built_in">getBean</span>(ppName, BeanDefinitionRegistryPostProcessor.<span class="keyword">class</span>));</span><br><span class="line">                    processedBeans.<span class="built_in">add</span>(ppName);</span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sortPostProcessors</span>(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.<span class="built_in">addAll</span>(currentRegistryProcessors);</span><br><span class="line">            <span class="built_in">invokeBeanDefinitionRegistryPostProcessors</span>(currentRegistryProcessors, registry, beanFactory.<span class="built_in">getApplicationStartup</span>());</span><br><span class="line">            currentRegistryProcessors.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后执行所有的BeanPostProcessor(BeanDefinitionRegistryPostProcessor实现了BeanFactoryPostProcessor接口)</span></span><br><span class="line">        <span class="built_in">invokeBeanFactoryPostProcessors</span>(registryProcessors, beanFactory);</span><br><span class="line">        <span class="built_in">invokeBeanFactoryPostProcessors</span>(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 只执行默认的BeanFactoryPostProcessor</span></span><br><span class="line">        <span class="built_in">invokeBeanFactoryPostProcessors</span>(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行剩下的未加载为Bean的BeanFactoryProstProcessors.(自定义的)</span></span><br><span class="line">    <span class="type">String</span>[] postProcessorNames =</span><br><span class="line">            beanFactory.<span class="built_in">getBeanNamesForType</span>(BeanFactoryPostProcessor.<span class="keyword">class</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和上面按照优先级分段执行方式如出一辙,但是更加直观清晰</span></span><br><span class="line">    <span class="comment">// 先执行PriorityOrdered优先级的,再执行Ordered优先级的,最后执行无优先级的</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;<span class="type">String</span>&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;<span class="type">String</span>&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">String</span> ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.<span class="built_in">contains</span>(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.<span class="built_in">isTypeMatch</span>(ppName, PriorityOrdered.<span class="keyword">class</span>)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.<span class="built_in">add</span>(beanFactory.<span class="built_in">getBean</span>(ppName, BeanFactoryPostProcessor.<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.<span class="built_in">isTypeMatch</span>(ppName, Ordered.<span class="keyword">class</span>)) &#123;</span><br><span class="line">            orderedPostProcessorNames.<span class="built_in">add</span>(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.<span class="built_in">add</span>(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="built_in">sortPostProcessors</span>(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="built_in">invokeBeanFactoryPostProcessors</span>(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">String</span> postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.<span class="built_in">add</span>(beanFactory.<span class="built_in">getBean</span>(postProcessorName, BeanFactoryPostProcessor.<span class="keyword">class</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sortPostProcessors</span>(orderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="built_in">invokeBeanFactoryPostProcessors</span>(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">String</span> postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.<span class="built_in">add</span>(beanFactory.<span class="built_in">getBean</span>(postProcessorName, BeanFactoryPostProcessor.<span class="keyword">class</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">invokeBeanFactoryPostProcessors</span>(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.<span class="built_in">clearMetadataCache</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、registerBeanPostProcessors-beanFactory">6、registerBeanPostProcessors(beanFactory);</h4>
<p>本方法会注册所有的 BeanPostProcessor，将所有实现了 BeanPostProcessor 接口的类加载到 BeanFactory 中。</p>
<p>BeanPostProcessor 接口是 Spring 初始化 bean 时对外暴露的扩展点，Spring IoC 容器允许 BeanPostProcessor 在容器初始化 bean 的前后，添加自己的逻辑处理。在 registerBeanPostProcessors 方法只是注册到 BeanFactory 中，具体调用是在 bean 初始化的时候。</p>
<p>具体的：在所有 bean 实例化时，执行初始化方法前会调用所有 BeanPostProcessor 的 postProcessBeforeInitialization 方法，在执行初始化方法后会调用所有 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected void register<span class="constructor">BeanPostProcessors(ConfigurableListableBeanFactory <span class="params">beanFactory</span>)</span> &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">PostProcessorRegistrationDelegate</span>.</span></span>register<span class="constructor">BeanPostProcessors(<span class="params">beanFactory</span>, <span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往下点</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有BeanPostProcessor的beanName</span></span><br><span class="line">    <span class="comment">//此时的bean是未进行初始化操作,但已经加载到容器中</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.<span class="keyword">class</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//记录所有beanPostProcessor的数量</span></span><br><span class="line">    <span class="built_in">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    <span class="comment">//注册BeanPostProcessorChecker,其主要的作用是在bean的实例化期间进行日志的记录</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过PriorityOrdered来保证顺序</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//有顺序</span></span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//没有顺序</span></span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.<span class="keyword">class</span>)) &#123;</span><br><span class="line">            <span class="comment">//获取BeanPostProcessor实例</span></span><br><span class="line">            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.<span class="keyword">class</span>);</span><br><span class="line">            priorityOrderedPostProcessors.<span class="keyword">add</span>(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.<span class="keyword">add</span>(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存到有序的orderedPostProcessorNames缓存中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.<span class="keyword">class</span>)) &#123;</span><br><span class="line">            orderedPostProcessorNames.<span class="keyword">add</span>(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存到无序的缓存中</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.<span class="keyword">add</span>(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步，注册所有实现了 PriorityOrdered 的 BeanPostProcessor</span></span><br><span class="line">    <span class="comment">//首先是排序</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">//接着是注册</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    <span class="comment">//第二步,注册所有实现Ordered接口的BeanPostProcessor</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.<span class="keyword">class</span>);</span><br><span class="line">        orderedPostProcessors.<span class="keyword">add</span>(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.<span class="keyword">add</span>(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还是先排序</span></span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">//接着是注册</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">//第三步,注册所有没有排序的BeanPostProcessor</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.<span class="keyword">class</span>);</span><br><span class="line">        nonOrderedPostProcessors.<span class="keyword">add</span>(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.<span class="keyword">add</span>(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册,这里不需要排序</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    <span class="comment">//加入ApplicationListenerDetector(探测器)</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更具体的详解，参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MzQ3NDM3MA==">Spring IoC：registerBeanPostProcessors 详解 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="7、initMessageSource">7、initMessageSource()</h4>
<p>该方法主要是为上下文环境初始化MessageSource,即不同语言的消息体,国际化处理操作。</p>
<p>ApplicationContext 添加 messageSource 成员，实现国际化功能去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> void initMessageSource() &#123;</span><br><span class="line">    <span class="comment">//获取并初始化beanFactory</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="comment">//如果在beanFactory包含messageSource的bean</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">//直接获取通过getBean(...)方法</span></span><br><span class="line">        <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">        <span class="comment">//如果有父类并且是HierarchicalMessageSource类型的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource instanceof HierarchicalMessageSource) &#123;</span><br><span class="line">            <span class="comment">//强转为HierarchicalMessageSource</span></span><br><span class="line">            HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">            <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">                <span class="comment">// registered already.</span></span><br><span class="line">                <span class="comment">//如果没有注册父 MessageSource,则设置为父类上下文的的 MessageSource</span></span><br><span class="line">                hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是beanFactory不包含messageSource该bean</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">        <span class="comment">//使用空的MessageSource去接受message</span></span><br><span class="line">        DelegatingMessageSource dms = new DelegatingMessageSource();</span><br><span class="line">        dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">        <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8、initApplicationEventMulticaster-初始化事件广播器">8、initApplicationEventMulticaster() 初始化事件广播器</h4>
<p>它的作用是发布事件给监听器去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件。</p>
<blockquote>
<p>事件广播器用于Spring事件通知机制,监听器通过指定监听事件,当广播器广播该事件时会执行对应监听器方法.<br>
该方法表示如果有自定义广播器则使用自定义广播器没有则创建一个SimpleApplicationEventMulticaster.可自定义拓展让广播器监听事件异步执行<br>
保存事件和对应监听器列表映射,发布事件后会找到该事件的所有监听器.如果由线程池则异步执行.没有则同步执行</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected void init<span class="constructor">ApplicationEventMulticaster()</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 获取 BeanFactory</span></span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = get<span class="constructor">BeanFactory()</span>;</span><br><span class="line">	<span class="comment">// 2. 从 BeanFactory 中获取 applicationEventMulticaster 的 applicationEventMulticaster</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.contains<span class="constructor">LocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)</span>) &#123;</span><br><span class="line">		this.applicationEventMulticaster =</span><br><span class="line">				beanFactory.get<span class="constructor">Bean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.<span class="params">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.is<span class="constructor">TraceEnabled()</span>) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + this.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 3. 如果上一步没有配置：创建一个 SimpleApplicationEventMulticaster</span></span><br><span class="line">		this.applicationEventMulticaster = <span class="keyword">new</span> <span class="constructor">SimpleApplicationEventMulticaster(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">		<span class="comment">// 4. 将创建的 ApplicationEventMulticaster 添加到 BeanFactory 中，以后其他组件直接自动注入即可</span></span><br><span class="line">		beanFactory.register<span class="constructor">Singleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="params">this</span>.<span class="params">applicationEventMulticaster</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.is<span class="constructor">TraceEnabled()</span>) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">					<span class="string">&quot;[&quot;</span> + this.applicationEventMulticaster.get<span class="constructor">Class()</span>.get<span class="constructor">SimpleName()</span> + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9、onRefresh-预留方法，用于自定义实现重写实现特殊-Bean-的处理">9、onRefresh() 预留方法，用于自定义实现重写实现特殊 Bean 的处理</h4>
<p>该方法主要是留给子类拓展方法,用来完成其他bean的上下文刷新操作</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span><br><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、registerListeners-注册监听器">10、registerListeners() 注册监听器</h4>
<p>该方法其主要的作用是为当前上下文注册一个事件监听器，至于监听器从何而来,是在所有的bean中去找，并添加至 applicationEventMulticaster</p>
<blockquote>
<p>事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源</p>
<ul>
<li>事先编程添加的</li>
<li>来自容器中的 bean</li>
<li>来自于 @EventListener 的解析</li>
<li>要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可</li>
</ul>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn&#x27;t affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected void register<span class="constructor">Listeners()</span> &#123;</span><br><span class="line">    <span class="comment">// 首先是注册静态监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : get<span class="constructor">ApplicationListeners()</span>) &#123;</span><br><span class="line">        get<span class="constructor">ApplicationEventMulticaster()</span>.add<span class="constructor">ApplicationListener(<span class="params">listener</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">    String<span class="literal">[]</span> listenerBeanNames = get<span class="constructor">BeanNamesForType(ApplicationListener.<span class="params">class</span>, <span class="params">true</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">        get<span class="constructor">ApplicationEventMulticaster()</span>.add<span class="constructor">ApplicationListenerBean(<span class="params">listenerBeanName</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">    <span class="comment">//至此,已经完成将监听器注册到ApplicationEventMulticaster中,下面将发布前期的事件给监听器</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">    this.earlyApplicationEvents = null;</span><br><span class="line">    <span class="keyword">if</span> (earlyEventsToProcess != null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">            get<span class="constructor">ApplicationEventMulticaster()</span>.multicast<span class="constructor">Event(<span class="params">earlyEvent</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、finishBeanFactoryInitialization-beanFactory-实例化所有剩余的（非懒加载）单例">11、finishBeanFactoryInitialization(beanFactory)  实例化所有剩余的（非懒加载）单例</h4>
<p>该方法作用将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean。</p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZlaXlpbmcwY2FuZ2xhbmcvYXJ0aWNsZS9kZXRhaWxzLzEyMDQ2ODI2MQ==">Spring–延迟加载(@Lazy注解等)–使用/原理_IT利刃出鞘的博客-CSDN博客_springboot延迟加载<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>单例模式中的非延迟加载：不管什么时候要使用，先提前创建实例。</p>
<ol>
<li>public class Singleton {</li>
<li>private static final Singleton instance = new Singleton();</li>
<li>private Singleton() {</li>
<li>}</li>
<li>public static Singleton getInstance() {</li>
<li>​    return instance;</li>
<li>}</li>
<li>}</li>
</ol>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给当前上下文初始化转换器服务</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.<span class="built_in">containsBean</span>(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.<span class="built_in">isTypeMatch</span>(CONVERSION_SERVICE_BEAN_NAME, ConversionService.<span class="keyword">class</span>)) &#123;</span><br><span class="line">        beanFactory.<span class="built_in">setConversionService</span>(</span><br><span class="line">                beanFactory.<span class="built_in">getBean</span>(CONVERSION_SERVICE_BEAN_NAME, ConversionService.<span class="keyword">class</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="comment">//如果之前没有注册 bean 后置处理器（例如PropertyPlaceholderConfigurer）,则注册默认的解析器</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.<span class="built_in">hasEmbeddedValueResolver</span>()) &#123;</span><br><span class="line">        beanFactory.<span class="built_in">addEmbeddedValueResolver</span>(strVal -&gt; <span class="built_in">getEnvironment</span>().<span class="built_in">resolvePlaceholders</span>(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽早初始化LoadTimeWeaverAware bean以允许尽早注册其变换器</span></span><br><span class="line">    <span class="type">String</span>[] weaverAwareNames = beanFactory.<span class="built_in">getBeanNamesForType</span>(LoadTimeWeaverAware.<span class="keyword">class</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">String</span> weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        <span class="built_in">getBean</span>(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止使用临时的 ClassLoader</span></span><br><span class="line">    beanFactory.<span class="built_in">setTempClassLoader</span>(null);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许缓存所有bean定义元数据</span></span><br><span class="line">    beanFactory.<span class="built_in">freezeConfiguration</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有剩余的单例(非延迟的).</span></span><br><span class="line">    beanFactory.<span class="built_in">preInstantiateSingletons</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12、finishRefresh-完成刷新-发布上下文刷新完毕事件">12、finishRefresh() 完成刷新,发布上下文刷新完毕事件</h4>
<p>该方法作用为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean</p>
<p>如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载LifecycleProcessor.执行其刷新方法.会将实现了SmartLifecycle接口的Bean加入Application生命周期,启动时执行start方法,关闭时执行stop方法,可以启动一些监控组件之类的东西.</span></span><br><span class="line"><span class="comment"> * 发布上下文刷新事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected void finish<span class="constructor">Refresh()</span> &#123;</span><br><span class="line">	<span class="comment">// 清除为上下文创建初始化准备的资源文件数据信息缓存.比如ASM的元数据信息</span></span><br><span class="line">	clear<span class="constructor">ResourceCaches()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一般是加载DefaultLifecycleProcessor</span></span><br><span class="line">	init<span class="constructor">LifecycleProcessor()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行生命周期处理器的onRefresh方法.会调用实现了SmartLifecycle接口的start方法启动对应Bean生命周期(随着Application启动启动,关闭而关闭)</span></span><br><span class="line">	get<span class="constructor">LifecycleProcessor()</span>.on<span class="constructor">Refresh()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发布上下文刷新完毕事件</span></span><br><span class="line">	publish<span class="constructor">Event(<span class="params">new</span> ContextRefreshedEvent(<span class="params">this</span>)</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置JMX则执行</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">NativeDetector</span>.</span></span><span class="keyword">in</span><span class="constructor">NativeImage()</span>) &#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">LiveBeansView</span>.</span></span>register<span class="constructor">ApplicationContext(<span class="params">this</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void init<span class="constructor">LifecycleProcessor()</span> &#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = get<span class="constructor">BeanFactory()</span>;</span><br><span class="line">	<span class="comment">// 我们自己没定义就一定是走下面默认的LifecycleProcssor上.我们自己定义的话最好也是继承下面那个默认的来定义,下面那个默认的是让Bean生命周期随上下文一致的保证.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.contains<span class="constructor">LocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)</span>) &#123;</span><br><span class="line">		this.lifecycleProcessor =</span><br><span class="line">				beanFactory.get<span class="constructor">Bean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.<span class="params">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.is<span class="constructor">TraceEnabled()</span>) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Using LifecycleProcessor [&quot;</span> + this.lifecycleProcessor + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> <span class="constructor">DefaultLifecycleProcessor()</span>;</span><br><span class="line">		defaultProcessor.set<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">		this.lifecycleProcessor = defaultProcessor;</span><br><span class="line">		beanFactory.register<span class="constructor">Singleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="params">this</span>.<span class="params">lifecycleProcessor</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.is<span class="constructor">TraceEnabled()</span>) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">					<span class="string">&quot;[&quot;</span> + this.lifecycleProcessor.get<span class="constructor">Class()</span>.get<span class="constructor">SimpleName()</span> + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMGE1MDg4YTY1MWQ=">spring高级容器ApplicationContext之refresh方法 - 简书 (jianshu.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk4MzM1NDY2NjY4NDQxNjA3">Spring 启动过程 - 掘金 (juejin.cn)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/posts/22654.html</url>
    <content><![CDATA[<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<span id="more"></span>
<p>[TOC]</p>
<p>参考视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTdhNHkxeDd6cQ==">https://www.bilibili.com/video/BV17a4y1x7zq<i class="fa fa-external-link-alt"></i></span></p>
<h1>ElasticSearch</h1>
<h2 id="聊聊Doug-Cutting">聊聊Doug Cutting</h2>
<p>1998年9月4日，Google公司在美国硅谷成立。正如大家所知，它是一家做搜索引擎起家的公司。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/75c99654de8d40f0934b31e7d811ad10.png" alt="在这里插入图片描述"></p>
<p>无独有偶，一位名叫<strong>Doug Cutting</strong>的美国工程师，也迷上了搜索引擎。他做了一个用于文本搜索的函数库（姑且理解为软件的功能组件），命名为<strong>Lucene</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9acb284104e24e8c9129eabb2c641887.png" alt="在这里插入图片描述"></p>
<p>Lucene是用JAVA写成的，目标是为各种中小型应用软件加入全文检索功能。因为好用而且开源（代码公开），非常受程序员们的欢迎。</p>
<p>早期的时候，这个项目被发布在Doug Cutting的个人网站和SourceForge（一个开源软件网站）。后来，2001年底，Lucene成为Apache软件基金会jakarta项目的一个子项目。</p>
<p><img data-src="https://img-blog.csdnimg.cn/e8b867eb08e04187955eb67500f1cfbb.png" alt="在这里插入图片描述"></p>
<p>2004年，Doug Cutting再接再励，在Lucene的基础上，和Apache开源伙伴Mike Cafarella合作，开发了一款可以代替当时的主流搜索的开源搜索引擎，命名为<strong>Nutch</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/78e9603f45ea412e8a7f34d04cbbe143.png" alt="在这里插入图片描述"></p>
<p>Nutch是一个建立在Lucene核心之上的网页搜索应用程序，可以下载下来直接使用。它在Lucene的基础上加了网络爬虫和一些网页相关的功能，目的就是从一个简单的站内检索推广到全球网络的搜索上，就像Google一样。</p>
<p>Nutch在业界的影响力比Lucene更大。</p>
<p>大批网站采用了Nutch平台，大大降低了技术门槛，使低成本的普通计算机取代高价的Web服务器成为可能。甚至有一段时间，在硅谷有了一股用Nutch低成本创业的潮流。（大数据！）</p>
<p>随着时间的推移，无论是Google还是Nutch，都面临搜索对象“体积”不断增大的问题。</p>
<p>尤其是Google，作为互联网搜索引擎，需要存储大量的网页，并不断优化自己的搜索算法，提升搜索效率。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/5d6a6fcb993e42c28b9c0731ec316754.png" alt="在这里插入图片描述"></p>
<p>在这个过程中，Google确实找到了不少好办法，并且无私地分享了出来。开源！</p>
<p>2003年，Google发表了一篇技术学术论文，公开介绍了自己的谷歌文件系统 <strong>GFS（Google File System）</strong>。这是Google公司为了存储海量搜索数据而设计的专用文件系统。</p>
<p>第二年，也就是2004年，Doug Cutting基于Google的GFS论文，实现了<strong>分布式文件存储系统</strong>，并将它命名为<strong>NDFS（Nutch Distributed File System）</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b4b2bec3cf7d4f5da174e6dcb4989e96.png" alt="在这里插入图片描述"></p>
<p>还是2004年，Google又发表了一篇技术学术论文，介绍自己的<strong>MapReduce编程模型</strong>。这个编程模型，用于大规模数据集（大于1TB）的并行分析运算。</p>
<p>第二年（2005年），Doug Cutting又基于MapReduce，在Nutch搜索引擎实现了该功能。</p>
<p><img data-src="https://img-blog.csdnimg.cn/e9ef4a81286b420abf38fb4aacd778d6.png" alt="在这里插入图片描述"></p>
<p>2006年，当时依然很厉害的<strong>Yahoo（雅虎）公司</strong>，招安了Doug Cutting。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/09db6bd51dbc4f26b53976bcd4de8204.png" alt="在这里插入图片描述"></p>
<p>这里要补充说明一下雅虎招安Doug的背景：2004年之前，作为互联网开拓者的雅虎，是使用Google搜索引擎作为自家搜索服务的。在2004年开始，雅虎放弃了Google，开始自己研发搜索引擎。所以。。。</p>
<p>加盟Yahoo之后，Doug Cutting将NDFS和MapReduce进行了升级改造，并重新命名为Hadoop（NDFS也改名为HDFS，Hadoop Distributed File System）。</p>
<p>这个，就是后来大名鼎鼎的大数据框架系统——Hadoop的由来。而Doug Cutting，则被人们称为Hadoop之父。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e5604e49d5664c5c86dfb83f9aea7ee6.png" alt="在这里插入图片描述"></p>
<p>Hadoop这个名字，实际上是Doug Cutting他儿子的黄色玩具大象的名字。所以，Hadoop的Logo，就是一只奔跑的黄色大象。</p>
<p><img data-src="https://img-blog.csdnimg.cn/a1dd755b734c4411bb96130a60268369.png" alt="在这里插入图片描述"></p>
<p>我们继续往下说。</p>
<p>还是2006年，Google又发论文了。</p>
<p>这次，它们介绍了自己的<strong>BigTable</strong>。这是一种分布式数据存储系统，一种用来处理海量数据的非关系型数据库。</p>
<p>Doug Cutting当然没有放过，在自己的hadoop系统里面，引入了BigTable，并命名为<strong>HBase</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/6f813d03dca6447eaa987f841934e4e1.png" alt="在这里插入图片描述"></p>
<p>好吧，反正就是紧跟Google时代步伐，你出什么，我学什么。</p>
<p>所以，Hadoop的核心部分，基本上都有Google的影子。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9fca1eefc8b9472ea705582dd7093a7a.png" alt="在这里插入图片描述"></p>
<p>2008年1月，Hadoop成功上位，正式成为Apache基金会的顶级项目。</p>
<p>同年2月，Yahoo宣布建成了一个拥有1万个内核的Hadoop集群，并将自己的搜索引擎产品部署在上面。</p>
<p>7月，Hadoop打破世界纪录，成为最快排序1TB数据的系统，用时209秒。</p>
<p><strong>回到主题</strong></p>
<p>在学习ElasticSearch之前，先简单了解一下Lucene：</p>
<ul>
<li>
<p>Doug Cutting开发</p>
</li>
<li>
<p>是apache软件基金会4 jakarta项目组的一个子项目</p>
</li>
<li>
<p>是一个开放源代码的全文检索引擎工具包</p>
</li>
<li>
<p>不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）</p>
</li>
<li>
<p>当前以及最近几年最受欢迎的免费Java信息检索程序库。</p>
</li>
</ul>
<p><strong>Lucene和ElasticSearch的关系：</strong></p>
<ul>
<li>ElasticSearch是基于Lucene 做了一下封装和增强</li>
</ul>
<h2 id="一、ElasticSearch概述">一、ElasticSearch概述</h2>
<p>Elaticsearch，简称为es，es是一个开源的高扩展的==分布式全文检索引擎==，它可以近乎==实时的存储、检索数据==;本身扩展性很好，可以扩展到上百台服务器，处理PB级别(大数据时代）的数据。es也使用java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是 通过简单的==RESTful API==来隐藏Lucene的复杂性，从而让全文搜索变得简单 。</p>
<p>据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月，ElasticSearch已超过Solr等，成为排名第一的搜索引擎类应用。</p>
<p><strong>历史</strong></p>
<p>多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。</p>
<p>直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便lava程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。</p>
<p>后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做==Elasticsearch==。</p>
<p>第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。</p>
<p>Shay的妻子依旧等待着她的食谱搜索……</p>
<p><strong>谁在使用：</strong></p>
<p>1、维基百科，类似百度百科，全文检索，高亮，搜索推荐/2（权重，百度！）</p>
<p>2、The Guardian (国外新闻网站) ，类似搜狐新闻，用户行为日志(点击，浏览，收藏，评论) +社交网络数据(对某某新闻的相关看法) ，数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈(好，坏，热门，垃圾，鄙视，崇拜)</p>
<p>3、Stack Overflow (国外的程序异常讨论论坛) ，，IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</p>
<p>4、GitHub (开源代码管理)，搜索 上千亿行代码</p>
<p>5、电商网站，检索商品</p>
<p>6、日志数据分析，logstash采集日志，ES进行复杂的数据分析，==ELK技术，elasticsearch+logstash+kibana==</p>
<p>7、商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</p>
<p>8、BI系统，商业智能， Business Intelligence。比如说有个大型商场集团，BI ，分析一下某某区域最近3年的用户消费 金额的趋势以及用户群体的组成构成，产出相关的数张报表， **区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘， Kibana进行数据可视化</p>
<p>9、国内:站内搜索(电商，招聘，门户，等等)，IT系统搜索(OA，CRM，ERP，等等)，数据分析(ES热门的一一个使用场景)</p>
<p>ES和 solr 的差别</p>
<h3 id="1、ElasticSearch简介">1、ElasticSearch简介</h3>
<p>Elasticsearch是一个实时分布式搜索和分析引擎。 它让你以前所未有的速度处理大数据成为可能。</p>
<p>它用于 <strong>全文搜索</strong>、<strong>结构化搜索</strong>、<strong>分析</strong>以及将这三者混合使用:</p>
<p>维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。</p>
<p>英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。</p>
<p>StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。</p>
<p>Github使用Elasticsearch检索1300亿行的代码。</p>
<p>但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。</p>
<p>Elasticsearch可以在你的笔记本上运行，也可以在数以百计的服务器上处理PB级别的数据。</p>
<p>Elasticsearch是一个基于Apache Lucene™的开源搜索引擎。无论在开源还是专有领域， Lucene可被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>
<p>但是， Lucene只是一个库。 想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是， Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p>
<p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h3 id="2、Solr简介">2、Solr简介</h3>
<p>Solr是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p>
<p>Solr可以独立运行，运行在letty. Tomcat等这些Selrvlet容器中 ， Solr 索引的实现方法很简单，==用POST方法向Solr服务器发送一个描述Field及其内容的XML文档， Solr根据xml文档添加、删除、更新索引==。Solr 搜索只需要发送HTTP GET请求，然后对Solr返回xml、==json==等格式的查询结果进行解析，组织页面布局。</p>
<p>Solr不提供构建UI的功能， Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。</p>
<p>solr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene.</p>
<p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交-定格式的文件，生成索引;也可以通过提出查找请求，并得到返回结果。</p>
<h3 id="3、Lucene简介">3、Lucene简介</h3>
<p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言)。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</p>
<p>Lucene是一个全文检索引擎的架构。那什么是全文搜索引擎?</p>
<p>全文搜索引擎是名副其实的搜索引擎，国外具代表性的有Google、Fast/AllTheWeb、AltaVista、Inktomi、Teoma、WiseNut等，国内著名的有百度(Baidu )。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主)而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。</p>
<p>从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序( Indexer )，俗称&quot;蜘蛛&quot; ( Spider )程序或&quot;机器人&quot; ( Robot )程序，并自建网页数据库，搜索结果直接从自身的数据库中调用，如上面提到的7家引擎;另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如Lycos引擎。</p>
<h3 id="4、ElasticSearch与Solr比较">4、ElasticSearch与Solr比较</h3>
<ol>
<li>当单纯的对已有数据进行搜索时，Solr更快</li>
</ol>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4ed7fbf84abc493a953c6aa904b22871.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>当实时建立索引时，Solr会产生io阻塞，查询性能较差，ElasticSearch具有明显的优势</li>
</ol>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/cd3535ed806a455690175d4f8448b70c.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li>随着数据量的增加，Solr的搜索效率会变得更低，而ElasticSearch却没有明显的变化</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/a19f9641e2a6465d880c97d87d87428e.png" alt="在这里插入图片描述"></p>
<ol start="4">
<li>转变我们的搜索基础设施后从Solr ElasticSearch，我们看见一个即时~ 50x提高搜索性能！</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/11f760cafd204a48a4a119014b4fee8a.png" alt="加粗样式"></p>
<p><strong>ElasticSearch vs Solr 总结</strong></p>
<p>1、es基本是开箱即用(解压就可以用!) ，非常简单。Solr安装略微复杂一丢丢!</p>
<p>2、Solr 利用Zookeeper进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能 。</p>
<p>3、Solr 支持更多格式的数据，比如JSON、XML、 CSV ，而Elasticsearch仅支持json文件格式。</p>
<p>4、Solr 官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</p>
<p>5、 Solr 查询快，但更新索引时慢(即插入删除慢) ，用于电商等查询多的应用;</p>
<ul>
<li>
<p>ES建立索引快(即查询慢) ，即实时性查询快，用于facebook新浪等搜索。</p>
</li>
<li>
<p>Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。</p>
</li>
</ul>
<p>6、Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。</p>
<h2 id="二、ElasticSearch安装">二、ElasticSearch安装</h2>
<p>官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9lbGFzdGljc2VhcmNoLw==">https://www.elastic.co/cn/elasticsearch/<i class="fa fa-external-link-alt"></i></span></p>
<p>JDK8，最低要求</p>
<p>使用Java开发，必须保证ElasticSearch的版本与Java的核心jar包版本对应！（Java环境保证没错）</p>
<p><img data-src="https://img-blog.csdnimg.cn/5ae25fde652d4503917683b50a1503f3.png" alt="在这里插入图片描述"></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/f7b41243553a4d47b64c60f1df01e8ad.png" alt="在这里插入图片描述"></p>
<p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9kb3dubG9hZHMvZWxhc3RpY3NlYXJjaA==">https://www.elastic.co/cn/downloads/elasticsearch<i class="fa fa-external-link-alt"></i></span></p>
<p>历史版本下载：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9kb3dubG9hZHMvcGFzdC1yZWxlYXNlcy8=">https://www.elastic.co/cn/downloads/past-releases/<i class="fa fa-external-link-alt"></i></span></p>
<p>官网下载巨慢，可以使用华为云镜像</p>
<ul>
<li>ElasticSearch: <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9lbGFzdGljc2VhcmNoLz9DPU4mTz1E">https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D<i class="fa fa-external-link-alt"></i></span></li>
<li>logstash: <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9sb2dzdGFzaC8/Qz1OJk89RA==">https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D<i class="fa fa-external-link-alt"></i></span></li>
<li>kibana: <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9raWJhbmEvP0M9TiZPPUQ=">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D<i class="fa fa-external-link-alt"></i></span></li>
<li>elasticsearch-analysis-ik: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lZGNsL2VsYXN0aWNzZWFyY2gtYW5hbHlzaXMtaWsvcmVsZWFzZXM=">https://github.com/medcl/elasticsearch-analysis-ik/releases<i class="fa fa-external-link-alt"></i></span></li>
<li>cerebro: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xtZW5lemVzL2NlcmVicm8vcmVsZWFzZXM=">https://github.com/lmenezes/cerebro/releases<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="2-1、Windows下安装">2.1、Windows下安装</h3>
<p>1、解压即可（尽量将ElasticSearch相关工具放在统一目录下）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4f4c3861f146402bbd62b4639813ec76.png" alt="在这里插入图片描述"></p>
<p>2、熟悉目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin	启动文件</span><br><span class="line">config 配置文件目录</span><br><span class="line">	1og4j2 日志配置文件</span><br><span class="line">	jvm.options java虚拟机相关的配置(默认启动占1g内存，内容不够需要自己调整)</span><br><span class="line">	elasticsearch.yml elasticsearch的配置文件! 默认9200端口!跨域!</span><br><span class="line">1ib  相关jar包</span><br><span class="line">modules 功能模块目录</span><br><span class="line">plugins 插件目录 ik分词器</span><br></pre></td></tr></table></figure>
<p>3、启动</p>
<blockquote>
<p>一定要检查自己的java环境是否配置好</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/80752baa4aa84e1e83f30409447b8cf1.png" alt="在这里插入图片描述"></p>
<p>双击启动</p>
<blockquote>
<p>注意：如果启动后闪退，可能是文件目录有中午或者空格造成的</p>
</blockquote>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/be1942c768854ec39a36715383d4f6df.png" alt="在这里插入图片描述"></p>
<p>访问 <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo5MjAwLw==">http://127.0.0.1:9200/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://img-blog.csdnimg.cn/2948347855074b89a0e34be5777f9a04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="2-2、安装可视化界面">2.2、安装可视化界面</h3>
<p>elasticsearch-head</p>
<p><strong>使用前提</strong>：需要安装nodejs</p>
<p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vYnovZWxhc3RpY3NlYXJjaC1oZWFk">https://github.com/mobz/elasticsearch-head<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b976add50915495a883b201b99596d62.png" alt="在这里插入图片描述"></p>
<p>安装依赖 <code>npm install</code></p>
<p>运行 <code>npm start</code></p>
<p>访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5MTAwLw==">http://localhost:9100/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/c73b892a47304fb49ded0d7fa4e5513e.png" alt="在这里插入图片描述"></p>
<p>发现存在跨域问题</p>
<p><strong>开启跨域（在elasticsearch解压目录config下elasticsearch.yml中添加）</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启跨域</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 所有人访问</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意配置文件中不要带注释，可能会闪退</p>
<p>重启elasticsearch</p>
<p><img data-src="https://img-blog.csdnimg.cn/31104ac0c70d485fb98563ccf7eef84a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>创建一个索引</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/ce525553a4984849972493e776963f2f.png" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/666cb2e8ccfe49cfa6bf20b2c9a0f6b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/8485dda55a73436aabcf62feba27c0c8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/9b86f0d4be42419191732c9e768d21ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>如何理解：</strong></p>
<ul>
<li>
<p>如果你是初学者</p>
<ul>
<li>索引 可以看做 “数据库”</li>
<li>类型 可以看做 “表”</li>
<li>文档 可以看做 “库中的数据（表中的行）”</li>
</ul>
</li>
</ul>
<p>这个head，我们只是把它当做可视化数据展示工具，之后所有的查询都在kibana中进行</p>
<ul>
<li>因为不支持json格式化，不方便</li>
</ul>
<h3 id="2-3、了解ELK">2.3、了解ELK</h3>
<p>ELK是Elasticsearch、Logstash、 Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。</p>
<p>其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。</p>
<p>像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大，市面上很多时候我们简称Elasticsearch为es。</p>
<p>Logstash是ELK的中央数据流引擎，用于从不同目标(文件/数据存储/MQ )收集的不同格式数据，经过过滤后支持输出到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。</p>
<p>Kibana可以将elasticsearch的数据通过友好的页面展示出来 ，提供实时分析的功能。</p>
<p>市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称 ，但实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</p>
<p>收集清洗数据(Logstash) ==&gt; 搜索、存储(ElasticSearch) ==&gt; 展示(Kibana)</p>
<p><img data-src="https://img-blog.csdnimg.cn/c60a6816e5cb4128bce48331063dc414.png" alt="在这里插入图片描述"></p>
<h3 id="2-4、安装kibana">2.4、安装kibana</h3>
<p>Kibana是一个针对ElasticSearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana ，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p>
<p>官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9raWJhbmEv">https://www.elastic.co/cn/kibana/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b3a7d05d0bb4448e957947e4c856ca8d.png" alt="在这里插入图片描述"></p>
<p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9kb3dubG9hZHMva2liYW5h">https://www.elastic.co/cn/downloads/kibana<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://img-blog.csdnimg.cn/fd0844bf68a347878b69fe0c1bf9b25c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>==版本需要与ElasticSearch版本对应==</p>
<p>华为云镜像： <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9raWJhbmEvP0M9TiZPPUQ=">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D<i class="fa fa-external-link-alt"></i></span></p>
<p>安装</p>
<p>解压即可（尽量将ElasticSearch相关工具放在统一目录下）</p>
<p>进入到 kibana-7.14.0-windows-x86_64\bin 目录下，双击启动</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0040a6fc2f7b43dca8d70b13ad32f6c7.png" alt="在这里插入图片描述"></p>
<p>访问 <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo1NjAx">http://127.0.0.1:5601<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/bd1980a003184f44b3fa2b35395d9e13.png" alt="在这里插入图片描述"></p>
<p>开发工具</p>
<p>（Postman、curl、head、谷歌浏览器插件）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/702849eaab964d6c9c2c702610cf0815.png" alt="在这里插入图片描述"></p>
<p>如果说，你在英文方面不太擅长，kibana是支持汉化的</p>
<p>kibana汉化</p>
<p>编辑器打开kibana解压目录/config/kibana.yml(kibana-7.13.1-windows-x86_64/config/kibana.yml)，添加</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0393d4d0fc164dc59dcfdbd209354e30.png" alt="在这里插入图片描述"></p>
<p>重启kibana</p>
<p>汉化成功</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/784bbd78425d4dc78eab349eba69ee4d.png" alt="在这里插入图片描述"></p>
<h2 id="三、ElasticSearch核心概念">三、ElasticSearch核心概念</h2>
<h3 id="3-1、概述">3.1、概述</h3>
<p>集群，节点，索引，类型，文档，分片，映射是什么？</p>
<p>1、索引（ElasticSearch）</p>
<p>包多个分片</p>
<p>2、字段类型（映射）mapping</p>
<p>字段类型映射（字段是整型，还是字符型…）</p>
<p>3、文档（documents）</p>
<p>4、分片（Lucene索引，倒排索引）</p>
<p><strong>elasticsearch是面向文档，关系型数据库和elasticsearch客观的对比！一切都是json</strong>!</p>
<table>
<thead>
<tr>
<th>Relational DB</th>
<th>Elasticsearch</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库（database）</td>
<td>索引（indices）</td>
</tr>
<tr>
<td>表（tables）</td>
<td>types</td>
</tr>
<tr>
<td>行（rows）</td>
<td>documents</td>
</tr>
<tr>
<td>字段（columns）</td>
<td>fields</td>
</tr>
</tbody>
</table>
<p>elasticsearch（集群）中可以包含多个索引（数据库） ，每个索引中可以包含多个类型（表） ，每个类型下又包含多个文档（行） ，每个文档中又包含多个字段（列）。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b4b6d49e705c431680358ecfdf601095.png" alt="在这里插入图片描述"></p>
<p><strong>物理设计：</strong></p>
<p>elasticsearch在后台把每个索引划分成多个分片。每个分片可以在集群中的不同服务器间迁移</p>
<p>一个人就是一个集群! ，即启动的ElasticSearch服务，默认就是一个集群，且默认集群名为elasticsearch</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/f97a6ef1187f4ec0a7a78822a25f9f66.png" alt="在这里插入图片描述"></p>
<p><strong>逻辑设计：</strong></p>
<p>一个索引类型中，包含多个文档，比如说文档1，文档2。当我们索引一篇文档时，可以通过这样的一个顺序找到它：索引-&gt;类型-&gt;文档id，通过这个组合我们就能索引到某个具体的文档。注意：ID不必是整数，实际上它是一个字符串。</p>
<h3 id="3-2、文档">3.2、文档</h3>
<p>文档（”行“）</p>
<p>就是我们的一条条的记录</p>
<p>之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档， elasticsearch中，文档有几个重要属性:</p>
<ul>
<li>自我包含， 一篇文档同时包含字段和对应的值，也就是同时包含key:value !</li>
<li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的! {就是一 个json对象! fastjson进行自动转换！}</li>
<li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li>
</ul>
<p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。</p>
<h3 id="3-3、类型">3.3、类型</h3>
<p>类型（“表”）</p>
<p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定 义称为映射，比如name映射为字符串类型。我们说文档是无模式的 ，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型， elasticsearch就开始猜，如果这个值是18 ，那么elasticsearch会认为它是整形。但是elasticsearch也可能猜不对 ，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。</p>
<h3 id="3-4、索引">3.4、索引</h3>
<p>索引（“库”）</p>
<p>就是数据库!</p>
<p>索引是映射类型的容器， elasticsearch中的索引是一个非常大的文档集合。索|存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p>
<p>物理设计:节点和分片如何工作</p>
<p><img data-src="https://img-blog.csdnimg.cn/eaa177e252e843e792de6e8144596c29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>一个集群至少有一 个节点，而一个节点就是一-个elasricsearch进程 ，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片( primary shard ，又称主分片)构成的，每一个主分片会有-一个副本( replica shard ，又称复制分片）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/ed34371596c344cbada49df3105a9edf.png" alt="在这里插入图片描述"></p>
<p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同-个节点内，这样有利于某个节点挂掉了，数据也不至于丢失。实际上， 一个分片是- -个Lucene索引， 一个包含==倒排索引==的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。不过，等等，倒排索引是什么鬼?</p>
<h3 id="3-5、倒排索引">3.5、倒排索引</h3>
<p>elasticsearch使用的是一种称为倒排索引 |的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档，每个文档包含如下内容:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Study <span class="keyword">every</span> <span class="built_in">day</span>， good good up <span class="keyword">to</span> forever  <span class="comment"># 文档1包含的内容</span></span><br><span class="line">To forever， study <span class="keyword">every</span> <span class="built_in">day</span>，good good up  <span class="comment"># 文档2包含的内容</span></span><br></pre></td></tr></table></figure>
<p>为为创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens) ，然后创建一一个包含所有不重 复的词条的排序列表，然后列出每个词条出现在哪个文档:</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Study</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>To</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>every</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>forever</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>day</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>study</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>good</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>every</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>to</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>up</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>现在，我们试图搜索 to forever，只需要查看包含每个词条的文档</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>forever</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>total</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。</p>
<p>再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构:</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/dd3138e456594fd29935bba97a751325.png" alt="在这里插入图片描述"></p>
<p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏，然后获取相关的文章ID即可。完全过滤掉无关的所有数据，提高效率!</p>
<p>elasticsearch的索引和Lucene的索引对比</p>
<p>在elasticsearch中，索引(库)这个词被频繁使用，这就是术语的使用。在elasticsearch中 ，索引被分为多个分片，每份分片是-个Lucene的索引。所以一个elasticsearch索引是由多 个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢!如无特指，说起索引都是指elasticsearch的索引。</p>
<p>接下来的一切操作都在kibana中Dev Tools下的Console里完成。基础操作!</p>
<h2 id="四、IK分词器-elasticsearch插件">四、IK分词器(elasticsearch插件)</h2>
<h3 id="4-1、IK分词器">4.1、IK分词器</h3>
<p>中文分词器</p>
<p>分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一一个匹配操作，默认的中文分词是将每个字看成一个词（不使用用IK分词器的情况下），比如“我爱狂神”会被分为”我”，”爱”，”狂”，”神” ，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。</p>
<p>IK提供了两个分词算法: (ik_smart和ik_max_word )，其中ik_smart为最少切分，ik_max_word为最细粒度划分!</p>
<p>1、下载</p>
<p>版本要与ElasticSearch版本对应</p>
<p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lZGNsL2VsYXN0aWNzZWFyY2gtYW5hbHlzaXMtaWsvcmVsZWFzZXM=">https://github.com/medcl/elasticsearch-analysis-ik/releases<i class="fa fa-external-link-alt"></i></span></p>
<p>2、安装</p>
<p>ik文件夹是自己创建的</p>
<p>解压放入到es对应的plugins下即可</p>
<p>3、重启观察ES，发现ik插件被加载了</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/38b1d63421ab4382b3311fcb0d3895c0.png" alt="在这里插入图片描述"></p>
<p>4、elasticsearch-plugin 可以通过这个命令来查看加载进来的插件</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/38f19cf2eab64372a275ffabc24f48c7.png" alt="在这里插入图片描述"></p>
<p>5、使用kibana测试</p>
<p>查看不同的分词效果</p>
<p>ik_smart：最少切分</p>
<p><img data-src="https://img-blog.csdnimg.cn/3fde229f03a1473cb51f08b432c35fc6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>ik_max_word：最细粒度划分（穷尽词库的可能）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4d73848123e84b208b4e40816b571650.png" alt="在这里插入图片描述"></p>
<p>我们输入 超级喜欢狂神说java</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/38aea40d916f438790ab9ca400181243.png" alt="在这里插入图片描述"></p>
<p>发现问题：狂神说被拆开了！</p>
<p>这种自己需要的词，需要自己加到我们的分词器的字典中！</p>
<p><strong>ik 分词器增加自己的配置</strong></p>
<p>添加自定义的词添加到扩展字典中</p>
<p>elasticsearch目录/plugins/ik/config/IKAnalyzer.cfg.xml</p>
<p>创建 <code>kuang.dic</code> 字典文件，添加字典内容</p>
<p><img data-src="https://img-blog.csdnimg.cn/08b073c0fb7342cb89f71cbaecf73ef9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>打开 IKAnalyzer.cfg.xml 文件，扩展字典</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/8a9feed75ad24bb78327a1330655659b.png" alt="在这里插入图片描述"></p>
<p>重启ElasticSearch，再次使用kibana测试</p>
<p><strong>加载了自己的</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/3715bb78330f447885bb4d18e72f7726.png" alt="在这里插入图片描述"></p>
<p><strong>测试kibana</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/ce04eb6b519d4c14a0801e2236985016.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>以后的话，我们需要自己配置分词就在自己定义的dic文件进行配置即可！</p>
<h2 id="五、Rest风格说明">五、Rest风格说明</h2>
<p><strong>一种软件架构风格</strong>,而不是标准,只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以<strong>更简洁</strong>，<strong>更有层次</strong>，<strong>更易于实现缓存</strong>等机制。</p>
<h3 id="5-1、基本Rest命令说明：">5.1、基本Rest命令说明：</h3>
<table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUT（创建,修改）</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>创建文档（指定文档id）</td>
</tr>
<tr>
<td>POST（创建）</td>
<td>localhost:9200/索引名称/类型名称</td>
<td>创建文档（随机文档id）</td>
</tr>
<tr>
<td>POST（修改）</td>
<td>localhost:9200/索引名称/类型名称/文档id/_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE（删除）</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET（查询）</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>查询文档通过文档ID</td>
</tr>
<tr>
<td>POST（查询）</td>
<td>localhost:9200/索引名称/类型名称/文档id/_search</td>
<td>查询所有数据</td>
</tr>
</tbody>
</table>
<h3 id="5-2、关于索引的基本操作">5.2、关于索引的基本操作</h3>
<p>1、创建一个索引，添加</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引名/~类型名~/文档id</span><br><span class="line"><span class="punctuation">&#123;</span>请求体<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test1/type1/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;流柚&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回结果</span><br><span class="line"># 警告信息： 不支持在文档索引请求中的指定类型</span><br><span class="line"># 而是使用无类型的断点(/<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span><span class="punctuation">,</span> /<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_doc<span class="punctuation">,</span> or /<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_create/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span>).</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;test1&quot;</span><span class="punctuation">,</span>	# 索引</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;type1&quot;</span><span class="punctuation">,</span>	# 类型（已经废弃）</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span>			# id</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>		# 版本</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;created&quot;</span><span class="punctuation">,</span>	# 操作类型</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span>			# 分片信息</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>完成了自动增加索引！数据也成功的添加了，这就是我说大家在初期可以把它当做数据库学习的原因！</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/a1662e1682294fe8931f6c8f4b687389.png" alt="在这里插入图片描述"></p>
<p>2、字段数据类型</p>
<ul>
<li>
<p>字符串类型</p>
<p>text、keyword</p>
<ul>
<li>text：支持分词，全文检索,支持模糊、精确查询,不支持聚合,排序操作;text类型的最大支持的字符长度无限制,适合大字段存储；</li>
<li>keyword：不进行分词，直接索引、支持模糊、支持精确匹配，支持聚合、排序操作。keyword类型的最大支持的长度为——32766个UTF-8类型的字符,可以通过设置ignore_above指定自持字符长度，超过给定长度后的数据将不被索引，无法通过term精确匹配检索返回结果。</li>
</ul>
</li>
<li>
<p>数值型</p>
<p>long、Integer、short、byte、double、float、half float、scaled float</p>
</li>
<li>
<p>日期类型</p>
<p>date</p>
</li>
<li>
<p>te布尔类型</p>
<p>boolean</p>
</li>
<li>
<p>二进制类型</p>
<p>binary</p>
<p>等等…</p>
</li>
</ul>
<p>3、指定字段的类型（使用PUT）</p>
<p>创建规则 类似于建库（建立索引和字段对应类型），也可看做规则的建立</p>
<p><img data-src="https://img-blog.csdnimg.cn/970cd3944d8549fe883ce0e12b4c71f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>4、获取规则</p>
<p>可以通过 GET 请求获取具体的信息</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9ce725800ca3465a8c34ffccd7d8bd2b.png" alt="在这里插入图片描述"></p>
<p>5、查看默认信息</p>
<p><code>_doc</code> 默认类型（default type），type 在未来的版本中会逐渐弃用，因此产生一个默认类型进行代替</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4da91cb2d5df42bebac4fcb58f8b99f4.png" alt="在这里插入图片描述"></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/19a9e6e92488420e83d34d77502d0472.png" alt="在这里插入图片描述"></p>
<p>如果自己的文档字段没有指定，那么es就会给我们默认配置字段类型！</p>
<p>扩展：通过命令 elasticsearch索引情况！通过<code>get _cat/</code> 可以获取ElasticSearch的当前的很多信息！</p>
<p><img data-src="https://img-blog.csdnimg.cn/981f1f82ba0244c8a063cca8ac0c5939.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/c63b3977ea4c4f4999c6582f8c8aba04.png" alt="在这里插入图片描述"></p>
<p>6、修改</p>
<p>两种方案</p>
<p>旧的（使用put覆盖原来的值）</p>
<p>版本+1（_version）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/a51c87dd6df847a4a1f5d477ddecebc6.png" alt="在这里插入图片描述"></p>
<p>但是如果漏掉某个字段没有写，那么更新是没有写的字段 ，会消失</p>
<p>新的（使用post的update）</p>
<p><img data-src="https://img-blog.csdnimg.cn/d09be475ac2042079ba2c630ecd8c595.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>version不会改变</p>
<p>需要注意doc</p>
<p>不会丢失字段</p>
<p>7、删除</p>
<p>通过DELETE 命令实现删除，根据你的请求来判断是删除索引还是删除文档记录！</p>
<p>使用RESTFUL 风格是我们ES推荐大家使用的！</p>
<h3 id="5-3、关于文档的基本操作（重点）">5.3、关于文档的基本操作（重点）</h3>
<h4 id="基本操作">基本操作</h4>
<p>1、添加数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kuangshen/user/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;狂神说&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一顿操作猛如虎，一看工资2500&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;运动&quot;</span><span class="punctuation">,</span><span class="string">&quot;阳光&quot;</span><span class="punctuation">,</span><span class="string">&quot;直男&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/8dfa5df40a8b452eb658ed6ea52939ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kuangshen/user/<span class="number">2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;法外狂徒&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;运动&quot;</span><span class="punctuation">,</span><span class="string">&quot;旅游&quot;</span><span class="punctuation">,</span><span class="string">&quot;渣男&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /kuangshen/user/<span class="number">3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mmp,不知道 如何形容&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;靓仔&quot;</span><span class="punctuation">,</span><span class="string">&quot;旅游&quot;</span><span class="punctuation">,</span><span class="string">&quot;唱歌&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>2、获取数据 GET</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0e50324e7c9d4073befc3e9c5b839f60.png" alt="在这里插入图片描述"></p>
<p>3、更新数据 PUT</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kuangshen/user/<span class="number">3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四233&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mmp,不知道 如何形容&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;靓仔&quot;</span><span class="punctuation">,</span><span class="string">&quot;旅游&quot;</span><span class="punctuation">,</span><span class="string">&quot;唱歌&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e5007de387844be5bfce42147f181e11.png" alt="在这里插入图片描述"></p>
<p>4、Post  _update，推荐使用这种更新方式！</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9e051316013f400891b1ffd5d4473408.png" alt="在这里插入图片描述"></p>
<p>简单的搜索</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET kuangshen/user/<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>简单的条件查询，可以根据默认的映射规则，产生基本的查询！</p>
<p><img data-src="https://img-blog.csdnimg.cn/0b0ea5fffae64c5099fc021f1924b7af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>这边name是text 所以做了分词的查询 如果是keyword就不会分词搜索了</p>
<h4 id="复杂操作">复杂操作</h4>
<p>复杂操作搜索 select（排序，分页，高亮，模糊查询，精准查询）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/a20e749f1863490d89cd3746c954a9de.png" alt="在这里插入图片描述"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试只能一个字段查询</span></span><br><span class="line">GET lisen/user/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李森&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出结果，不想要那么多，只展示列表中某些字段</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b7907b445a9a47598675e271890f7263.png" alt="在这里插入图片描述"></p>
<p>我们之后使用java操作es，所有的方法和对象就是这里面的key</p>
<p><strong>排序</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/583539109f444b15a44de8ef0a527751.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>分页</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0ffa8f13a2d04d1c874e4cdf42b1168f.png" alt="在这里插入图片描述"></p>
<p>数据下标还是从0开始的，和学的所有数据结构是一样的！</p>
<p><strong>多条件查询</strong></p>
<p>布尔值查询</p>
<p>must（and），所有的条件都要符合 where id=1 and name = xxx</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/3589fc9a7b7b48c79c8493997be7adbe.png" alt="在这里插入图片描述"></p>
<p>should（or），所有的条件都要符合  where id=1 or name = xxx</p>
<p><img data-src="https://img-blog.csdnimg.cn/721a2b681384440ea87daee668eea7eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>must_not（not）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4ac6b16f0a7d4b2687e35c2f7cc03fad.png" alt="在这里插入图片描述"></p>
<p><strong>过滤器 filter</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/23a68a449b51445eba3a88e9b30eb97a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>gt 大于</li>
<li>gte 大于等于</li>
<li>lte 小于</li>
<li>lte 小于等于</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e8bc04cc80a94c1589c21d522fdcae76.png" alt="在这里插入图片描述"></p>
<p><strong>匹配多个条件（数组）</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/5c36c5aa99f64a5f86839e2982870c30.png" alt="在这里插入图片描述"></p>
<p><strong>精确查询</strong></p>
<p>term查询是直接通过倒排索引指定的词条进程精确查找的</p>
<p>关于分词</p>
<ul>
<li>term，直接查询精确的</li>
<li>match，会使用分词器解析！（先分析文档，然后通过分析的文档进行查询）</li>
</ul>
<p>两个类型 text  keyword</p>
<p><img data-src="https://img-blog.csdnimg.cn/e30c975c422e4312ba98abfda5987aaa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/8cbfcbf35fb74cedb63a91c05298229f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/3de24b19e77441c39c6b2eaf1df58f6f.png" alt="在这里插入图片描述"></p>
<p><strong>多个值匹配精确查询</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/f5fc6c7a9b794c829fa48d56bfd81f96.png" alt="在这里插入图片描述"></p>
<p><strong>高亮</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/6bbe3eee045a44b9ab52097aedd27964.png" alt="在这里插入图片描述"></p>
<p>还能自定义高亮的样式</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/1b8f05ec014343a2b6e85a0564dbe4b5.png" alt="在这里插入图片描述"></p>
<p>这些mysql也能做，只是效率比较低</p>
<ul>
<li>匹配</li>
<li>按条件匹配</li>
<li>精确匹配</li>
<li>区间范围匹配</li>
<li>匹配字段过滤</li>
<li>多条件查询</li>
<li>高亮查询</li>
</ul>
<h2 id="六、Springboot集成">六、Springboot集成</h2>
<p>找官方文档</p>
<p><img data-src="https://img-blog.csdnimg.cn/03a46f66dbe7480182fcc45536f8b3e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/19b99197625040c28a2f44f26feaa791.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/e186b75d68d14b41b62f8fa0e444e333.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="6-1、导入依赖">6.1、导入依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意下spring-boot的parent包内的依赖的es的版本是不是你对应的版本</p>
<p>不是的话就在pom文件下写个properties的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这边配置下自己对应的版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.14.0<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2、找对象">6.2、找对象</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e3d293ae07494d09a4cec0c2fe18e7db.png" alt="在这里插入图片描述"></p>
<h3 id="6-3、分析这个类中的方法">6.3、分析这个类中的方法</h3>
<p>配置基本的项目</p>
<p>一定要保证我们导入的依赖和我们本地的es版本一致</p>
<p><img data-src="https://img-blog.csdnimg.cn/b0876b20083740afa52422eabb14462d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>新建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、找对象</span></span><br><span class="line"><span class="comment">// 2、放到spring中待用</span></span><br><span class="line"><span class="comment">// 3、如果是springboot 就先分析源码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticSearchClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">            RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/5ffde15a8f0a4ca0a59a72508654579b.png" alt="在这里插入图片描述"></p>
<p>虽然这里导入了3个类，都是静态内部类，核心类就一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.elasticsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.auth.AuthScope;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.auth.Credentials;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.auth.UsernamePasswordCredentials;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig.Builder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.BasicCredentialsProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.nio.client.HttpAsyncClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.PropertyMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RestHighLevelClient.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;RestClient.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ElasticsearchRestClientProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchRestClientAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElasticsearchRestClientAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PropertiesCredentialsProvider</span> <span class="keyword">extends</span> <span class="title class_">BasicCredentialsProvider</span> &#123;</span><br><span class="line">        PropertiesCredentialsProvider(ElasticsearchRestClientProperties properties) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(properties.getUsername())) &#123;</span><br><span class="line">                <span class="type">Credentials</span> <span class="variable">credentials</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(properties.getUsername(), properties.getPassword());</span><br><span class="line">                <span class="built_in">this</span>.setCredentials(AuthScope.ANY, credentials);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.getUris().stream().map(<span class="built_in">this</span>::toUri).filter(<span class="built_in">this</span>::hasUserInfo).forEach(<span class="built_in">this</span>::addUserInfoCredentials);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URI <span class="title function_">toUri</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> URI.create(uri);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasUserInfo</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> uri != <span class="literal">null</span> &amp;&amp; StringUtils.hasLength(uri.getUserInfo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addUserInfoCredentials</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">            <span class="type">AuthScope</span> <span class="variable">authScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthScope</span>(uri.getHost(), uri.getPort());</span><br><span class="line">            <span class="type">Credentials</span> <span class="variable">credentials</span> <span class="operator">=</span> <span class="built_in">this</span>.createUserInfoCredentials(uri.getUserInfo());</span><br><span class="line">            <span class="built_in">this</span>.setCredentials(authScope, credentials);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Credentials <span class="title function_">createUserInfoCredentials</span><span class="params">(String userInfo)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">delimiter</span> <span class="operator">=</span> userInfo.indexOf(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (delimiter == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(userInfo, (String)<span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> userInfo.substring(<span class="number">0</span>, delimiter);</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> userInfo.substring(delimiter + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(username, password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultRestClientBuilderCustomizer</span> <span class="keyword">implements</span> <span class="title class_">RestClientBuilderCustomizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PropertyMapper</span> <span class="variable">map</span> <span class="operator">=</span> PropertyMapper.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchRestClientProperties properties;</span><br><span class="line"></span><br><span class="line">        DefaultRestClientBuilderCustomizer(ElasticsearchRestClientProperties properties) &#123;</span><br><span class="line">            <span class="built_in">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(RestClientBuilder builder)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(HttpAsyncClientBuilder builder)</span> &#123;</span><br><span class="line">            builder.setDefaultCredentialsProvider(<span class="keyword">new</span> <span class="title class_">ElasticsearchRestClientAutoConfiguration</span>.PropertiesCredentialsProvider(<span class="built_in">this</span>.properties));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">            <span class="type">PropertyMapper</span> <span class="variable">var10000</span> <span class="operator">=</span> map;</span><br><span class="line">            <span class="type">ElasticsearchRestClientProperties</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.properties;</span><br><span class="line">            var10001.getClass();</span><br><span class="line">            var10000.from(var10001::getConnectionTimeout).whenNonNull().asInt(Duration::toMillis).to(builder::setConnectTimeout);</span><br><span class="line">            var10000 = map;</span><br><span class="line">            var10001 = <span class="built_in">this</span>.properties;</span><br><span class="line">            var10001.getClass();</span><br><span class="line">            var10000.from(var10001::getReadTimeout).whenNonNull().asInt(Duration::toMillis).to(builder::setSocketTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">        proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;RestHighLevelClient.class&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RestHighLevelClientConfiguration</span> &#123;</span><br><span class="line">        RestHighLevelClientConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RestHighLevelClient 高级客户端，也是我们这里要讲，后面项目会用到客户端</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        RestHighLevelClient <span class="title function_">elasticsearchRestHighLevelClient</span><span class="params">(RestClientBuilder restClientBuilder)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(restClientBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">        proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;RestClientBuilder.class&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RestClientBuilderConfiguration</span> &#123;</span><br><span class="line">        RestClientBuilderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        RestClientBuilderCustomizer <span class="title function_">defaultRestClientBuilderCustomizer</span><span class="params">(ElasticsearchRestClientProperties properties)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchRestClientAutoConfiguration</span>.DefaultRestClientBuilderCustomizer(properties);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RestClientBuilder</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        RestClientBuilder <span class="title function_">elasticsearchRestClientBuilder</span><span class="params">(ElasticsearchRestClientProperties properties, ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers)</span> &#123;</span><br><span class="line">            HttpHost[] hosts = (HttpHost[])properties.getUris().stream().map(<span class="built_in">this</span>::createHttpHost).toArray((x$<span class="number">0</span>) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>[x$<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">RestClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RestClient.builder(hosts);</span><br><span class="line">            builder.setHttpClientConfigCallback((httpClientBuilder) -&gt; &#123;</span><br><span class="line">                builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123;</span><br><span class="line">                    customizer.customize(httpClientBuilder);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> httpClientBuilder;</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.setRequestConfigCallback((requestConfigBuilder) -&gt; &#123;</span><br><span class="line">                builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123;</span><br><span class="line">                    customizer.customize(requestConfigBuilder);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> requestConfigBuilder;</span><br><span class="line">            &#125;);</span><br><span class="line">            builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123;</span><br><span class="line">                customizer.customize(builder);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> builder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HttpHost <span class="title function_">createHttpHost</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.createHttpHost(URI.create(uri));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var3) &#123;</span><br><span class="line">                <span class="keyword">return</span> HttpHost.create(uri);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HttpHost <span class="title function_">createHttpHost</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasLength(uri.getUserInfo())) &#123;</span><br><span class="line">                <span class="keyword">return</span> HttpHost.create(uri.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> HttpHost.create((<span class="keyword">new</span> <span class="title class_">URI</span>(uri.getScheme(), (String)<span class="literal">null</span>, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment())).toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (URISyntaxException var3) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4、索引的增、删、是否存在">6.4、索引的增、删、是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试索引的创建 request</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 1、创建索引请求</span></span><br><span class="line">   <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">   <span class="comment">// 2、客户端执行请求 indexResponse, 请求后获得相应</span></span><br><span class="line">   <span class="type">CreateIndexResponse</span> <span class="variable">createIndexResponse</span> <span class="operator">=</span> client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">   System.out.println(createIndexResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试获取索引，只能判断其是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">   System.out.println(exists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">   <span class="type">AcknowledgedResponse</span> <span class="variable">delete</span> <span class="operator">=</span> client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">   System.out.println(delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5、文档的操作">6.5、文档的操作</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试创建文档</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;狂神说&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 put /kuang_index/_doc/1</span></span><br><span class="line">    request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    request.timeout(TimeValue.timeValueDays(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//    request.timeout(&quot;1&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将我们的数据放入请求 json</span></span><br><span class="line">    request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端发送请求，获取响应结果</span></span><br><span class="line">    <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(indexResponse.toString());</span><br><span class="line">    System.out.println(indexResponse.status());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档，判断是否存在 get /index/doc/1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIsExists</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 不获取返回的 _source 的上下文了</span></span><br><span class="line">    request.fetchSourceContext(<span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">false</span>));</span><br><span class="line">    request.storedFields(<span class="string">&quot;_none_&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(getResponse.getSourceAsString()); <span class="comment">// 打印文档的内容</span></span><br><span class="line">    System.out.println(getResponse);  <span class="comment">// 返回的全部内容和命令是一样的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新文档的信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    updateRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;狂神说java&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    updateRequest.doc(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">    <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(updateResponse.status());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文档记录</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeleteResponse</span> <span class="variable">delete</span> <span class="operator">=</span> client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.status());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量插入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;kuangshen1&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;kuangshen2&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;kuangshen3&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;qinjiang1&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;qinjiang2&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;qinjiang3&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批处理请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 批量更新和批量删除，就在这里修改对应的请求就可以了</span></span><br><span class="line">        bulkRequest.add(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>)</span><br><span class="line">            .id(<span class="string">&quot;&quot;</span> + (i + <span class="number">1</span>))</span><br><span class="line">            .source(JSON.toJSONString(list.get(i)), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(bulkResponse.hasFailures());  <span class="comment">// 是否失败,返回false代表成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="comment">// SearchRequest 搜索请求</span></span><br><span class="line"><span class="comment">// SearchSourceBuilder 条件构造</span></span><br><span class="line"><span class="comment">// HighLightBuilder 构建高亮</span></span><br><span class="line"><span class="comment">// TermQueryBuilder  精确查询</span></span><br><span class="line"><span class="comment">// MatchAllQueryBuilder</span></span><br><span class="line"><span class="comment">// xxx QueryBuilder 对应我们刚才看到的命令！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">    <span class="comment">// 构建搜索条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件，我们可以使用 QueryBuilders 工具来实现</span></span><br><span class="line">    <span class="comment">// QueryBuilders.termQuery  精确</span></span><br><span class="line">    <span class="comment">//QueryBuilders.matchAllQuery 匹配所有</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;qinjiang1&quot;</span>);</span><br><span class="line">    <span class="comment">//    MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();</span></span><br><span class="line">    sourceBuilder.query(termQueryBuilder);</span><br><span class="line">    sourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(JSON.toJSONString(searchResponse.getHits()));</span><br><span class="line">    System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SearchHit documentFields : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty入门</title>
    <url>/posts/51340.html</url>
    <content><![CDATA[<p>Netty是一个基于NIO网络通信框架，使用它可以简单快速地开发网络应用程序，比如客户端和服务端的协议。Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<span id="more"></span>
<h3 id="前置知识">前置知识</h3>
<ul>
<li>IO操作的流程</li>
<li>操作系统的IO模型</li>
<li>JavaIO模型</li>
<li>如何理解同步/异步、阻塞和非阻塞？</li>
</ul>
<h4 id="为什么要了解前置知识？">为什么要了解前置知识？</h4>
<p>Netty的底层使用的是Java NIO，而Java NIO封装的是操作系统的IO模型，所以在学习Netty之前，了解前置知识至关重要。</p>
<h4 id="IO操作的流程">IO操作的流程</h4>
<p>应用程序发起的一次IO操作包含两个阶段：</p>
<ul>
<li>IO调用：应用程序进程向操作系统<strong>内核</strong>发起调用</li>
<li>IO执行：操作系统内核完成IO操作</li>
</ul>
<p>操作系统内核完成IO操作还包括连个两个过程：</p>
<ul>
<li>准备数据阶段：内核等待I/O设备准备好数据</li>
<li>拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071057687.webp" alt="img"></p>
<blockquote>
<ul>
<li>什么是内核？
<ul>
<li>内核就是为操作系系统提供驱动、<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlODYlODUlRTUlQUQlOTgmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">内存<i class="fa fa-external-link-alt"></i></span>管理、网络、IO等功能的软件代码</li>
</ul>
</li>
<li>什么是用户空间？什么是内核空间?
<ul>
<li>操作系统为进程分配的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。</li>
</ul>
</li>
<li>IO设备？
<ul>
<li>可以与计算机进行数据传输的硬件。分类如下：</li>
<li>字符设备（character device），又叫做人机交互设备。用户通过这些设备实现与计算机系统的通信。它们大多是以字符为单位发送和接受数据的，数据通信的速度比较慢。例如，键盘和显示器为一体的字符终端、打印机、扫描仪、包括鼠标等，还有早期的卡片和纸带输入和输出机。含有显卡的图形显示器的速度相对较快，可以用来进行图像处理中的复杂图形的显示。</li>
<li>块设备（block device），又叫外部存储器，用户通过这些设备实现程序和数据的长期保存。与字符设备相比，它们是以块为单位进行传输的，如磁盘、磁带和光盘等。块的常见尺寸为512~32768B之间。</li>
<li>网络通信设备。这类设备主要有网卡、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQjAlODMlRTUlODglQjYlRTglQTclQTMlRTglQjAlODMlRTUlOTklQTg=">调制解调器<i class="fa fa-external-link-alt"></i></span>等，主要用于与远程设备的通信。这类设备的传输速度比字符设备高，但比<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQTQlOTYlRTklODMlQTglRTUlQUQlOTglRTUlODIlQTglRTUlOTklQTgvNDg0MzE4MA==">外部存储器<i class="fa fa-external-link-alt"></i></span>低。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="操作系统的IO模型"><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDM2NTE4MDE1NDYyMDE1MDA2I2hlYWRpbmctNg==">操作系统的IO模型<i class="fa fa-external-link-alt"></i></span></h4>
<h5 id="同步阻塞IO模型">同步阻塞IO模型</h5>
<p>假设应用程序的进程发起<strong>IO调用</strong>，但是如果<strong>内核的数据还没准备好</strong>的话，那应用程序进程就一直在<strong>阻塞等待</strong>，一直等到内核数据准备好，直到内核拷贝到用户空间，才返回成功提示，此次IO操作，称之为<strong>阻塞IO</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071111906.webp" alt="img"></p>
<blockquote>
<ul>
<li>阻塞IO比较经典的应用就是<strong>阻塞socket、Java BIO</strong>。</li>
<li>阻塞IO的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，<strong>浪费性能</strong>，可以使用<strong>非阻塞IO</strong>优化。</li>
</ul>
</blockquote>
<h5 id="同步非阻塞IO模型">同步非阻塞IO模型</h5>
<p>如果内核数据还没准备好，可以先返回错误信息给用户进程，让它不需要等待，通过轮询的方式再来请求，这就是非阻塞IO，流程图如下：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071114171.webp" alt="img"></p>
<p>非阻塞IO的流程如下：</p>
<ul>
<li>应用进程向操作系统内核，发起<code>recvfrom</code>读取数据。</li>
<li>操作系统内核数据没有准备好，立即返回<code>EWOULDBLOCK</code>错误码。</li>
<li>应用程序轮询调用，继续向操作系统内核发起<code>recvfrom</code>读取数据。</li>
<li>操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间。</li>
<li>完成调用，返回成功提示。</li>
</ul>
<p>非阻塞IO模型，简称<strong>NIO</strong>，<code>Non-Blocking IO</code>。它相对于阻塞IO，虽然大幅提升了性能，但是它依然存在<strong>性能问题</strong>，即<strong>频繁的轮询</strong>，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑<strong>IO复用模型</strong>，去解决这个问题。</p>
<h5 id="IO多路复用模型">IO多路复用模型</h5>
<p>IO复用模型核心思路：系统给我们提供<strong>一类函数</strong>（如我们耳濡目染的<strong>select、poll、epoll</strong>函数），它们可以同时监控多个文件描述符的操作，并在其中某个文件描述符可读写时由操作系统唤醒阻塞等待的线程。</p>
<blockquote>
<p>I/O 复用其实复用的不是 I/O 连接，而是复用线程，让线程能够监听多个连接（I/O 事件）。</p>
<p>文件描述符（fd）：它是计算机科学中的一个术语，形式上是一个非负整数。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
</blockquote>
<h6 id="IO多路复用之select">IO多路复用之select</h6>
<p>应用进程通过调用select函数，可以同时监控多个<code>fd</code>，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071138127.webp" alt="img"></p>
<p>非阻塞IO模型（NIO）中，需要<code>N</code>（N&gt;=1）次轮询系统调用，然而借助<code>select</code>的IO多路复用模型，只需要发起一次系统调用就够了,大大优化了性能。</p>
<p>但是呢，<code>select</code>有几个缺点：</p>
<ul>
<li>监听的IO最大连接数有限，在Linux系统上一般为1024。</li>
<li>select函数返回后，是通过遍历<code>fdset</code>，找到就绪的描述符<code>fd</code>。</li>
</ul>
<p>因为<strong>存在连接数限制</strong>，所以后来又提出了<strong>poll</strong>。与select相比，<strong>poll</strong>解决了<strong>连接数限制问题</strong>。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的<code>socket</code>。如果同时连接的大量客户端在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，<strong>效率也会线性下降</strong>。</p>
<p>因此经典的多路复用模型<code>epoll</code>诞生。</p>
<h6 id="IO多路复用之epoll">IO多路复用之epoll</h6>
<p>为了解决<code>select/poll</code>存在的问题，多路复用模型<code>epoll</code>诞生，它采用事件驱动来实现，流程图如下：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071139505.webp" alt="img"></p>
<p><strong>epoll</strong>先通过<code>epoll_ctl()</code>来注册一个<code>fd</code>（文件描述符），一旦基于某个<code>fd</code>就绪时，内核会采用回调机制，迅速激活这个<code>fd</code>，当进程调用<code>epoll_wait()</code>时便得到通知。这里去掉了<strong>遍历文件描述符</strong>的坑爹操作，而是采用<strong>监听事件回调</strong>的的机制。这就是epoll的亮点。</p>
<p>select、poll、epoll的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>select</strong></th>
<th><strong>poll</strong></th>
<th><strong>epoll</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>底层数据结构</td>
<td>数组</td>
<td>链表</td>
<td>红黑树和双链表</td>
</tr>
<tr>
<td>获取就绪的fd</td>
<td>遍历</td>
<td>遍历</td>
<td>事件回调</td>
</tr>
<tr>
<td>事件复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最大连接数</td>
<td>1024</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>fd数据拷贝</td>
<td>每次调用select，需要将fd数据从用户空间拷贝到内核空间</td>
<td>每次调用poll，需要将fd数据从用户空间拷贝到内核空间</td>
<td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间</td>
</tr>
</tbody>
</table>
<p><strong>epoll</strong>明显优化了IO的执行效率，但在进程调用<code>epoll_wait()</code>时，仍然可能被阻塞的。能不能这样：不用我老是去问你数据是否准备就绪，等我发出请求后，你数据准备好了通知我就行了，这就诞生了<strong>信号驱动IO模型</strong>。</p>
<h5 id="IO模型之信号驱动模型">IO模型之信号驱动模型</h5>
<p>信号驱动IO不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用<code>sigaction</code>的时候建立一个<code>SIGIO</code>的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过<code>SIGIO</code>信号通知应用进程。应用用户进程收到信号之后，立即调用<code>recvfrom</code>，去读取数据。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071141603.webp" alt="img"></p>
<p>信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，<strong>发现数据复制到应用缓冲的时候</strong>，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。还有没有优化方案呢？<strong>AIO</strong>（真正的异步IO）！</p>
<h5 id="IO-模型之异步IO-AIO">IO 模型之异步IO(AIO)</h5>
<p>前面讲的<code>BIO，NIO和信号驱动</code>，在数据从内核复制到应用缓冲的时候，都是<strong>阻塞</strong>的，因此都不是真正的异步。<code>AIO</code>实现了IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是<strong>立即返回的不是处理结果，而是表示提交成功类似的意思</strong>。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程IO操作执行完毕。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211071142114.webp" alt="img"></p>
<p>异步IO的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。日常开发中，有类似的业务场景：</p>
<blockquote>
<p>比如发起一笔批量转账，但是转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>
<p>阻塞IO就是那种<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPXJlY3Ymc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9zb3VyY2U9RW50aXR5Jmh5YnJpZF9zZWFyY2hfZXh0cmE9JTdCJTIyc291cmNlVHlwZSUyMiUzQSUyMmFuc3dlciUyMiUyQyUyMnNvdXJjZUlkJTIyJTNBMTQ0MTM1OTklN0Q=">recv<i class="fa fa-external-link-alt"></i></span>, read，一直等，等到有了数据才返回；</p>
</li>
<li>
<p>非阻塞IO就是立即返回，设置描述符为非阻塞，但是要进程自己一直检查是否可读；</p>
</li>
<li>
<p>IO复用其实也是阻塞的，不过可以用来等很多描述符，比起阻塞有了进步，可以算有点异步了，但需要阻塞着检查是否可读。<strong>对同一个描述符的IO操作也是有序的。</strong></p>
</li>
<li>
<p>信号驱动采用<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNCVCRiVBMSVFNSU4RiVCNyVFNiU5QyVCQSVFNSU4OCVCNiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyJTNBJTIyYW5zd2VyJTIyJTJDJTIyc291cmNlSWQlMjIlM0ExNDQxMzU5OSU3RA==">信号机制<i class="fa fa-external-link-alt"></i></span>等待，有了更多的进步，不用监视描述符了，而且不用阻塞着等待数据到来，被动等待信号通知，由<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNCVCRiVBMSVFNSU4RiVCNyVFNSVBNCU4NCVFNyU5MCU4NiVFNyVBOCU4QiVFNSVCQSU4RiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyJTNBJTIyYW5zd2VyJTIyJTJDJTIyc291cmNlSWQlMjIlM0ExNDQxMzU5OSU3RA==">信号处理程序<i class="fa fa-external-link-alt"></i></span>处理。<strong>但对同一个描述符的IO操作还是有序的。</strong></p>
</li>
<li>
<p>异步IO，发送IO请求后，不用等了，也不再需要发送IO请求获取结果了。等到通知后，其实是系统帮你把数据读取好了的，<strong>你等到的通知也不再是要求你去读写IO了，而是告诉你IO请求过程已经结束了</strong>。你要做的就是可以处理数据了。且同一个描述符上可能同时存在很多请求。</p>
</li>
</ul>
<h4 id="JavaIO模型"><span class="exturl" data-url="aHR0cHM6Ly9qYXZhZ3VpZGUuY24vamF2YS9pby9pby1tb2RlbC5odG1sI2Fpby1hc3luY2hyb25vdXMtaS1v">JavaIO模型<i class="fa fa-external-link-alt"></i></span></h4>
<p>在Java中，主要有三种IO模型，分别是阻塞IO（BIO）、非阻塞IO（NIO）和 异步IO（AIO）。</p>
<p>注意：这三种是Java中提供的IO有关的API。并不是操作系统层面的IO模型呢。</p>
<p>Java中提供的IO有关的API，在进行IO处理的时候，其实依赖操作系统层面的IO操作实现的。</p>
<p>比如在Java中NIO和AIO都是通过Linux IO复用模型中的epoll函数来实现的。</p>
<p>可以把Java中的BIO、NIO和AIO理解为是Java语言对操作系统的各种IO模型的封装。程序员在使用这些API的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p>
<h5 id="BIO"><strong>BIO</strong></h5>
<p>在Java的java.io包下，属于同步阻塞的IO模型</p>
<h5 id="NIO">NIO</h5>
<p>在Java1.4引入的java.nio包下，属于多路复用的IO模型</p>
<h5 id="AIO">AIO</h5>
<p>在Java1.7之后引入的包，是NIO的升级版本，属于异步非阻塞的IO模型</p>
<h4 id="如何理解同步-异步、阻塞和非阻塞？">如何理解同步/异步、阻塞和非阻塞？</h4>
<h5 id="同步和异步">同步和异步</h5>
<p>同步就是在一个功能调用时，在没有得到结果之前，该调用就不返回。也就是一件一件事做，等前一件做完了才做下一件事。</p>
<p>异步和同步相对，当一个异步过程调用出发后，调用者不能立刻得到结果。实际处理这个调用在完成后，通过状态，通知和回调来通知调用者。</p>
<h5 id="阻塞和非阻塞">阻塞和非阻塞</h5>
<p>非阻塞：数据没来，进程就轮询的去检测数据，直到数据来。实现了同时服务多个客户端，能够在等待任务完成的时间里干其他活了，包括提交其他任务。</p>
<p>阻塞：数据没来，啥都不做，直到数据来了，才进行下一步的处理。</p>
<h3 id="Netty简介">Netty简介</h3>
<p><span class="exturl" data-url="aHR0cDovL25ldHR5LmlvLw==">Netty<i class="fa fa-external-link-alt"></i></span>是一个提供异步事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
<p>换句话说，Netty是一个基于NIO网络通信框架，使用它可以简单快速地开发网络应用程序，比如客户端和服务端的协议。Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<blockquote>
<p>1.异步怎么理解：外部线程执行write或者execute任务的时候会立马返回，为什么会立马返回，是因为他内部有一个Mpsc(多生产者单消费者)队列，所有外部线程的任务都给扔到这个队列里，同时把回调，也就是future绑定在这个任务上，reactor线程会在第三步挨个执行这些任务，执行完之后callback，典型的观察者模式<br>
2.事件怎么理解：netty内部默认两倍cpu核数个reactor线程，每个reactor线程维护一个selector，每个selector维护一堆channel，每个channel都把读写等事件都注册到selector上<br>
3.驱动怎么理解：netty里面默认所有的操作都在reactor线程中执行，reactor线程核心的就是run方法，所有的操作都由这个方法来驱动，驱动的过程分为三个过程，轮询事件，处理事件，处理异步任务</p>
</blockquote>
<h3 id="为什么要用Netty">为什么要用Netty</h3>
<ul>
<li>Netty提供统一的 API，支持多种通信模型，如阻塞、非阻塞， 以及epoll、poll等模型。</li>
<li>Netty可以使用很少的代码实现Reactor多线程模型以及主从线程模型。</li>
<li>可以使用自带的编解码器解决 TCP 拆包/粘包问题。</li>
<li>Netty默认提供了多协议的通信支持。</li>
<li>Netty处理高吞吐量、低延迟、低资源消耗，比Java原生NIO的API更有优势。</li>
<li>经典的开源项目底层也使用到了Netty通信框架， 比如Zookeeper、Dubbo、RocketMQ等等，经历了大型项目的使用和考验更加成熟稳定。</li>
<li>Netty对安全性支持也不错，比如支持SSL/TLS等。</li>
</ul>
<h3 id="能用来干什么">能用来干什么</h3>
<ul>
<li>RPC框架的基础通信组件
<ul>
<li>典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFOCVCRiU5QiVFNyVBOCU4QiVFOCU4QSU4MiVFNyU4MiVCOSZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyJTNBJTIyYW5zd2VyJTIyJTJDJTIyc291cmNlSWQlMjIlM0E3ODk0NzQwNSU3RA==">进程节点<i class="fa fa-external-link-alt"></i></span>之间的内部通信。</li>
<li>除了 Dubbo 之外，淘宝的消息中间件 RocketMQ 的消息生产者和消息消费者之间，也采用 Netty 进行高性能、异步通信。</li>
</ul>
</li>
<li>高性能的通信组件
<ul>
<li>Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈，非常方便定制和开发<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNyVBNyU4MSVFNiU5QyU4OSVFNSU4RCU4RiVFOCVBRSVBRSVFNiVBMCU4OCZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyJTNBJTIyYW5zd2VyJTIyJTJDJTIyc291cmNlSWQlMjIlM0E3ODk0NzQwNSU3RA==">私有协议栈<i class="fa fa-external-link-alt"></i></span>。</li>
</ul>
</li>
</ul>
<h3 id="网络框架还有哪些？">网络框架还有哪些？</h3>
<p>1、Apache MINA<br>
项目主页：<span class="exturl" data-url="aHR0cDovL21pbmEuYXBhY2hlLm9yZy8=">http://mina.apache.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>为开发高性能和高可用性的网络应用程序提供了非常便利的框架;支持基于 Java NIO 技术的 TCP/UDP 应用程序开发、串口通讯程序</p>
<p>2、Grizzly<br>
官网：<span class="exturl" data-url="aHR0cDovL3hzb2NrZXQuc291cmNlZm9yZ2UubmV0Lw==">http://xsocket.sourceforge.net/<i class="fa fa-external-link-alt"></i></span></p>
<p>设计与一般的nio框架相比是比较不同的，主要不同点在于读和写都是采用blocking方式，并且使用临时selector ；<br>
线程模型高度可配置，不过据作者介绍在跑一个selector主线程处理ACCEPT，用线程池处理read和write性能表现最好，这点不出意料。</p>
<p>3、Netty<br>
官网：<span class="exturl" data-url="aHR0cDovL25ldHR5LmlvLw==">http://netty.io/<i class="fa fa-external-link-alt"></i></span></p>
<p>提供了一组基于事件的API来开发高性能, 可管理的TCP/IP服务端或客户端应用程序. 对于要求建立高性能的网络应用来说，Netty提供许多基本特性，像readiness selection, 线程池, 写缓冲DoS的预防, 可重用的缓冲等.</p>
<p>4、NIO Framework<br>
搭建在Java NIO library之上，封装了原始NIO的大部分复杂性。利用NIO Framework能够很容易地开发安全，高性能的Java网络应用程序。</p>
<p>5、QuickServer<br>
官网：<span class="exturl" data-url="aHR0cDovL3d3dy5xdWlja3NlcnZlci5vcmcv">http://www.quickserver.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>一个免费的开源Java库，用于快速创建健壮的多线程、多客户端TCP服务器应用程序。使用QuickServer，用户可以只集中处理应用程序的逻辑/ 协议。</p>
<p>6、xSocket<br>
官网：<span class="exturl" data-url="aHR0cDovL3hzb2NrZXQuc291cmNlZm9yZ2UubmV0Lw==">http://xsocket.sourceforge.net/<i class="fa fa-external-link-alt"></i></span></p>
<p>一个轻量级的基于nio的服务器框架用于开发高性能、可扩展、多线程的服务器。该框架封装了线程处理、异步读/写等方面。</p>
<p>7、IOServer<br>
高性能，易扩展的网络框架，相对于Apache的MINA更加轻量级，源码更容易读懂，源码中有大量详细的中文注解，是一个非常不错的学习框架，框架主要至力于解决中国市场上手机网游的服务器端程序的编写。</p>
<p>IoServer构建简单服务器例程(更详细的例程可下载例程包，或进入Wiki查看)服务器接收一个来自客户端的整型，并加一返回给客户端。</p>
<p>8、XNIO<br>
官网：<span class="exturl" data-url="aHR0cDovL3huaW8uamJvc3Mub3JnLw==">http://xnio.jboss.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>一个帮助你简化NIO应用程序开发的Java包；</p>
<p>提供了一个独特和易于使用的API，用于结合blocking和非blocking操作，即使是在同一个channel上，也可以允许你利用简单和低延迟性的blocking I/O，同时还能获得非blocking I/O的优势；</p>
<p>还引入了一个功能强大的基于回调的接口，可以大大简化基于traditional state machine的非blocking应用，并让您的应用程序之间的吞吐量（throughput）和延时达到完美平衡。</p>
<h3 id="Netty优点">Netty优点</h3>
<ul>
<li>API使用简单，学习成本低。</li>
<li>功能强大，内置了多种解码编码器，支持多种协议。</li>
<li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li>
<li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li>
<li>高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），它的并发性能得到了很大提高。</li>
<li>封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。</li>
<li>传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。
<ul>
<li>传统的数据拷贝：
<ul>
<li>将数据从磁盘读取到内核缓存</li>
<li>将数据从内核缓存读取到用户缓存</li>
<li>将数据从用户缓存写入到<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1zb2NrZXQmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">socket<i class="fa fa-external-link-alt"></i></span>缓存</li>
<li>将数据从socket缓存写入到网卡设备</li>
</ul>
</li>
<li>操作系统层面的零拷贝：
<ul>
<li>将数据从磁盘读取到内核缓存</li>
<li>将数据从内核缓存拷贝到<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1zb2NrZXQmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">socket<i class="fa fa-external-link-alt"></i></span>缓存</li>
<li>将数据从socket缓存写入到网卡设备</li>
</ul>
</li>
<li>[netty零拷贝](<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDg4MDg4">彻底搞懂Netty高性能之零拷贝 - 腾讯云开发者社区-腾讯云 (tencent.com)<i class="fa fa-external-link-alt"></i></span>)：
<ul>
<li>Netty 中的 <code>Zero-copy</code> 与上面我们所提到到 OS 层面上的 <code>Zero-copy</code> 不太一样, Netty的 <code>Zero-coyp</code> 完全是在用户态(Java 层面)的, 它的 <code>Zero-copy</code> 的更多的是偏向于 <code>优化数据操作</code> 这样的概念.Netty 的 <code>Zero-copy</code> 体现在如下五个方面:
<ul>
<li>Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。</li>
<li>Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。</li>
<li>通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。</li>
<li>ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Netty缺点">Netty缺点</h3>
<ul>
<li>NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li>
<li>需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li>
<li>臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li>
</ul>
<h3 id="如何使用">如何使用</h3>
<h4 id="引入依赖">引入依赖</h4>
<p>使用的版本是4.1.20，相对比较稳定的一个版本。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;dependency&gt;</span></span><br><span class="line">    <span class="section">&lt;groupId&gt;</span><span class="attribute">io</span>.netty&lt;/groupId&gt;</span><br><span class="line">    <span class="section">&lt;artifactId&gt;</span><span class="attribute">netty</span>-<span class="literal">all</span>&lt;/artifactId&gt;</span><br><span class="line">    <span class="section">&lt;version&gt;</span><span class="attribute">4</span>.<span class="number">1</span>.<span class="number">20</span>.Final&lt;/version&gt;</span><br><span class="line"><span class="section">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建服务端启动类">创建服务端启动类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建两个线程组 boosGroup、workerGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动对象，设置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">//设置两个线程组boosGroup和workerGroup</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">//设置服务端通道实现类型    </span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//设置线程队列得到连接个数    </span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//设置保持活动连接状态    </span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//使用匿名内部类的形式初始化通道对象</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//给pipeline管道设置处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);<span class="comment">//给workerGroup的EventLoop对应的管道设置处理器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;netty服务端已经准备就绪...&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(<span class="number">6666</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建服务端处理器">创建服务端处理器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span></span><br><span class="line"><span class="comment"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取客户端发送过来的消息</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;发送的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//发送消息给客户端</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;服务端已收到消息，并给你发送一个问号?&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//发生异常，关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建客户端启动类">创建客户端启动类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建bootstrap对象，配置参数</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置线程组</span></span><br><span class="line">            bootstrap.group(eventExecutors)</span><br><span class="line">                <span class="comment">//设置客户端的通道实现类型    </span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//使用匿名内部类初始化通道</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//添加客户端通道的处理器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端准备就绪，随时可以起飞~&quot;</span>);</span><br><span class="line">            <span class="comment">//连接服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>).sync();</span><br><span class="line">            <span class="comment">//对通道关闭进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程组</span></span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建客户端处理器">创建客户端处理器</h4>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelActive(<span class="type">ChannelHandlerContext</span> ctx) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">//发送消息到服务端</span></span><br><span class="line">        ctx.writeAndFlush(<span class="type">Unpooled</span>.copiedBuffer(<span class="string">&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;</span>, <span class="type">CharsetUtil</span>.<span class="type">UTF_8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">//接收服务端发送过来的消息</span></span><br><span class="line">        <span class="type">ByteBuf</span> byteBuf = (<span class="type">ByteBuf</span>) msg;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;的消息：&quot;</span> + byteBuf.toString(<span class="type">CharsetUtil</span>.<span class="type">UTF_8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运作流程"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg1NTAzL2FydGljbGUvZGV0YWlscy8xMTQxNjg3MjI=">运作流程<i class="fa fa-external-link-alt"></i></span></h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211082152413.png" alt="img"></p>
<ol>
<li>
<p>ServerBootStrap作为Netty的服务端入口，会对BossGroup和WorkGroup进行相关初始化操作。</p>
<ol>
<li>在BossGroup中，主要是对客户端的新连接请求进行处理（即OP_ACCEPT事件，但其实OP_ACCEPT事件的具体处理也会涉及到读写事件，因为数据不是读就是写）</li>
<li>在WorkGroup中，则负责处理IO读写、编解码、业务逻辑等（即OP_READ事件、OP_WRITE事件）。</li>
<li>服务端启动的时候会绑定一个端口，作为后续客户端连接入口，绑定端口的时候会在BossGroup(由NioEventLoopGroup类创建的对象）的其中一个NioEventLoop的Selector（多路复用器）上注册一条NioServerSocketChannel通道，后面的连接处理就是在通道中进行的。</li>
</ol>
</li>
<li>
<p>BootStrap则作为Netty的客户端入口，会对ClientGroup进行相关初始化操作，在ClientGroup中，先创建与服务端的连接（即OP_CONNECT事件），然后再进行IO读写、编解码、业务逻辑等操作（即OP_READ事件、OP_WRITE事件）。</p>
</li>
<li>
<p>服务端和客户端启动之后，当服务端收到客户端发来的连接请求，由于属于OP_ACCEPT事件，在BossGroup中处理。</p>
<ol>
<li>BossGroup(由NioEventLoopGroup类创建的对象）管理着若干个NioEventLoop，每个NioEventLoop（事件循环）持有一个线程（就好比线程池中的一组线程并发处理若干个连接请求）</li>
<li>每个NioEventLoop上会创建一个Selector，一个Selector上可以注册多个通道（所以叫多路复用器），且它会以不断轮询的方式同时监听每个通道上是否有IO事件发生</li>
<li>每个通道里都会有个ChannelPipeline管道，管道里全是Handler，包括管道头Head和管道尾Tail，以及进行IO读写、编解码，业务处理的若干个Handler，Handler也可以自定义，把需要的Handler注册进管道就可以执行了。</li>
<li>当请求到达Head时，代表“请求数据”已准备好，OP_ACCEPT事件已就绪，Selector监听到事件已就绪，就会让持有的线程对事件进行处理，处理过程是在Handler中进行。</li>
<li>首先会创建一个NioSocketChannel实例，然后交给ServerBootStrapAcceptor（接收客户端连接对象）这个Handler，，Acceptor具体操作就是向WorkGroup中的某个Selector注册刚才创建好的NioSocketChannel，自此客户端连接请求处理结束。</li>
</ol>
</li>
<li>
<p>客户端发出连接请求的同时会自己创建一条NioSocketChannel通道与服务端NioSocketChannel进行互通，连接完之后就是WorkGroup的事了，不需要BossGroup管了，一个客户端连接对应一条服务端NioSocketChannel。</p>
<p>比如现在客户端要进行一个远程方法的调用，将方法参数传给服务端后，服务端处理完将结果返回给客户端。</p>
<ol>
<li>首先请求从客户端通道传输到WorkGroup中的对应通道</li>
<li>然后Head会申请一块堆外内存来缓冲请求内容，缓冲完之后，代表数据已准备好，OP_READ事件已就绪</li>
<li>selector监听到就绪事件之后，让持有的线程对事件进行处理，这里我定义了Decode解码，Compute方法调用处理和Encode编码三个Handler进行操作，其中Inbound入站Handler包括Decode和Compute（从Head到Tail就是入站），Outbound出站Handler包括Encode（从Tail到Head就是出站），每一个Handler被注册到Pipeline中的时候都会创建一个与之对应的ChannelHandlerContext，它包含着Handler的上下文信息，主要负责管理和其他在同一管道里的Handler之间的交互，它有一个前指针和后指针，可以与其他ChannelHandlerContext关联，这样Handler处理就变得更加灵活，比如这次请求需要三个Handler，而下次请求只涉及到Decode和Encode，那下次就可以执行完Decode然后指针直接指向Encode，next指针具体指向谁是依靠ChannelHandlerContext中的数据类型与其他Handler类型进行匹配得出的。</li>
<li>在处理完读事件之后，接着处理Handler中涉及到的写事件，将处理结果写到ByteBuf中，回到Head，执行flush操作将ByteBuf内容写到SocketBuffer中，然后再到网卡buffer，通过互联网把结果传回给客户端，客户端拿到结果之后同样要进行解码，反序列化等操作，那么回过头发现客户端在发送调用请求之前在Pipeline中也进行了Encode处理的。（Head的主要作用：从SocketBuffer读请求内容到ByteBuf，从ByteBuf写返回结果到SocketBuffer）</li>
</ol>
</li>
<li>
<p>假设又有另外一个客户端连接了服务端，且和之前那个服务端NioSocketChannel注册到了同一个Selector上，当线程正在处理另一个通道上的事件的时候，这时该客户端也发起了一个处理请求，请求到达服务端通道之后会被Head读到堆外内存中缓冲着，此时OP_READ事件已就绪，Selector监听到了就绪事件，但由于线程正在处理另外一个通道上的事件，所以就要等当前通道的事件处理完，下一轮循环监听再处理了（这也是堆外内存的作用体现之一，数据可以先在缓冲区放着）。</p>
</li>
<li>
<p>当两个通道被注册在不同的Selector上的时候就互不影响了，因为是在不同的线程中并行处理的。</p>
</li>
</ol>
<blockquote>
<h4 id="在netty中的IO事件类型：">在netty中的IO事件类型：</h4>
<ul>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_CONNECT</li>
</ul>
<p>因此Selector每次循环监听的其实就是SelectionKey中的就绪事件集，看是否存在已就绪的事件，存在就进行处理。SelectionKey相当于是Selector和Channel之间的桥梁。</p>
<h4 id="如何理解Channel、Handler、EventLoop：">如何理解Channel、Handler、EventLoop：</h4>
<ul>
<li>把 Channel 可以理解为数据的通道</li>
<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>把 Handler 理解为数据的处理工序
<ul>
<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler 分 Inbound 和 Outbound 两类</li>
</ul>
</li>
<li>把 EventLoop 理解为处理数据的工人
<ul>
<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>
<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Netty相关对象和组件">Netty相关对象和组件</h3>
<h4 id="Bootstrap与ServerBootStrap">Bootstrap与ServerBootStrap</h4>
<p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211081713546.png" alt="image.png"></p>
<p>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p>
<p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211081713172.png" alt="image.png"></p>
<h5 id="设置线程组方法：group">设置线程组方法：group()</h5>
<ul>
<li>bossGroup用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li>
<li>workerGroup用于处理每一个连接发生的读写事件。</li>
</ul>
<p>既然是线程组，那线程数默认是多少呢？深入源码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line">  <span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line">  <span class="keyword">private</span> static final <span class="built_in">int</span> DEFAULT_EVENT_LOOP_THREADS= <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(<span class="number">1</span>, <span class="module-access"><span class="module"><span class="identifier">SystemPropertyUtil</span>.</span></span>get<span class="constructor">Int(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.<span class="params">availableProcessors</span>()</span><span class="operator"> * </span><span class="number">2</span>));</span><br><span class="line">  protected <span class="constructor">MultithreadEventLoopGroup(<span class="params">int</span> <span class="params">nThreads</span>, Executor <span class="params">executor</span>, Object<span class="operator">...</span> <span class="params">args</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//如果不传入，则使用常量的值</span></span><br><span class="line">      super(nThreads<span class="operator"> == </span><span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看到，默认的线程数是cpu核数的两倍。</p>
<p>假设想自定义线程数，可以使用有参构造器：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置bossGroup线程数为1</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> <span class="type">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置workerGroup线程数为16</span></span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> <span class="type">NioEventLoopGroup</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<h5 id="设置通道类型的方法：channel">设置通道类型的方法：channel()</h5>
<p>NioSocketChannel： 异步非阻塞的客户端 TCP Socket 连接。</p>
<p>NioServerSocketChannel： 异步非阻塞的服务器端 TCP Socket 连接。</p>
<blockquote>
<p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p>
</blockquote>
<p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p>
<p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p>
<p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。</p>
<p>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p>
<h4 id="Selector">Selector</h4>
<p>Netty中的Selector用于监听事件，管理注册到Selector中的channel，实现多路复用器。</p>
<p>首先要将对应的Channel及IO事件（读、写、连接）注册到Selector，注册后会产生一个SelectionKey对象，用于关联Selector和Channel，及后续的IO事件处理。这三者的关系如下图所示。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211091047290.png" alt="image-20221109104512842"></p>
<h4 id="ByteBuf">ByteBuf</h4>
<p>Netty的字节容器，它其实等同于Java Nio中的ByteBuffer，但是ByteBuf对Nio中的ByteBuffer的功能做了很多增强。</p>
<p>下面这段代码演示了ByteBuf的创建以及内容的打印，这里显示出了和普通ByteBuffer最大的区别之一，就是ByteBuf可以自动扩容，默认长度是256，如果内容长度超过阈值时，会自动触发扩容。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.<span class="literal">DEFAULT</span>.<span class="built_in">buffer</span>(); <span class="comment">//可自动扩容</span></span><br><span class="line">        <span class="built_in">log</span>(buffer);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(<span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">writeBytes</span>(sb.<span class="built_in">toString</span>().<span class="built_in">getBytes</span>());</span><br><span class="line">        <span class="built_in">log</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(ByteBuf buf)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>()</span><br><span class="line">            .<span class="built_in">append</span>(<span class="string">&quot; read index:&quot;</span>).<span class="built_in">append</span>(buf.<span class="built_in">readerIndex</span>())<span class="comment">//获取读索引</span></span><br><span class="line">            .<span class="built_in">append</span>(<span class="string">&quot; write index:&quot;</span>).<span class="built_in">append</span>(buf.<span class="built_in">writerIndex</span>()) <span class="comment">//获取写索引</span></span><br><span class="line">            .<span class="built_in">append</span>(<span class="string">&quot; capacity:&quot;</span>).<span class="built_in">append</span>(buf.<span class="built_in">capacity</span>())<span class="comment">//获取容量</span></span><br><span class="line">            .<span class="built_in">append</span>(StringUtil.NEWLINE);</span><br><span class="line">        <span class="comment">//把ByteBuf中的内容，dump到StringBuilder中</span></span><br><span class="line">        ByteBufUtil.<span class="built_in">appendPrettyHexDump</span>(builder, buf);</span><br><span class="line">        System.out.<span class="built_in">println</span>(builder.<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="创建">创建</h5>
<ul>
<li>
<p>第一种，创建基于堆内存的ByteBuf</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二种，创建基于直接内存（堆外内存）的ByteBuf（默认）</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java中的内存分为两个部分，一部分是不需要jvm管理的直接内存，也被称为堆外内存。堆外内存就是把内存对象分配在JVM堆以外的内存区域，这部分内存不是虚拟机管理，而是由操作系统来管理，这样可以减少垃圾回收对应用程序的影响。</p>
<p>直接内存的好处是读写性能会高一些，如果数据存放在堆中，此时需要把Java堆空间的数据发送到远程服务器，首先需要把堆内部的数据拷贝到直接内存（堆外内存)，然后再发送，如果是把数据直接存储到堆外内存中，发送的时候就少了一个复制步骤。</p>
<p>但是它也有缺点，由于缺少了JMM的内存管理，所以需要我们自己来维护堆外内存，防止内存溢出。</p>
</blockquote>
<p>另外，需要注意的是，ByteBuf默认采用了池化技术来创建。它的核心思想是实现对象的复用，从而减少对象频繁创建销毁带来的性能开销。</p>
<p>池化功能是否开启，可以通过下面的环境变量来控制，其中unpooled表示不开启。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">-<span class="type">Dio</span>.netty.allocator.<span class="keyword">type</span>=&#123;unpooled | pooled&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="存储结构">存储结构</h5>
<p>该结构包含四部分：</p>
<ul>
<li>已经丢弃的字节，这部分数据是无效的</li>
<li>可读字节，这部分数据是ByteBuf的主体数据，从ByteBuf里面读取的数据都来自这部分;</li>
<li>可写字节，所有写到ByteBuf的数据都会存储到这一段</li>
<li>可扩容字节，表示ByteBuf最多还能扩容多少容量。</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211101654546.png" alt="img"></p>
<p>在ByteBuf中，有两个指针:</p>
<ul>
<li>readerIndex:读指针，每读取一个字节，readerIndex自增加1。ByteBuf里面总共有witelndex-readerlndex个字节可读，当readerlndex和writeIndex相等的时候，ByteBuf不可读。</li>
<li>writelndex:写指针，每写入一个字节，writeIndex自增加1，直到增加到capacity后，可以触发扩容后继续写入。</li>
<li>ByteBuf中还有一个maxCapacity最大容量，默认的值是Integer.MAX_VALUE，当ByteBuf写入数据时，如果容量不足时，会触发扩容，直到capacity扩容到maxCapacity。</li>
</ul>
<h5 id="Write相关方法">Write相关方法</h5>
<p>对于write方法来说，ByteBuf提供了针对各种不同数据类型的写入，比如</p>
<ul>
<li>writeChar，写入char类型</li>
<li>writelnt，写入int类型</li>
<li>writeFloat，写入float类型</li>
<li>writeBytes，写入nio的ByteBuffer</li>
<li>writeCharSequence，写入字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(); <span class="comment">//可自动扩容</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">//写入四个字节</span></span><br><span class="line">        log(buffer);</span><br><span class="line">        buffer.writeInt(<span class="number">5</span>); <span class="comment">//写入一个int类型，也是4个字节</span></span><br><span class="line">        log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buf)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()</span><br><span class="line">            .append(<span class="string">&quot; read index:&quot;</span>).append(buf.readerIndex())<span class="comment">//获取读索引</span></span><br><span class="line">            .append(<span class="string">&quot; write index:&quot;</span>).append(buf.writerIndex()) <span class="comment">//获取写索引</span></span><br><span class="line">            .append(<span class="string">&quot; capacity:&quot;</span>).append(buf.capacity())<span class="comment">//获取容量</span></span><br><span class="line">            .append(StringUtil.NEWLINE);</span><br><span class="line">        <span class="comment">//把ByteBuf中的内容，dump到StringBuilder中</span></span><br><span class="line">        ByteBufUtil.appendPrettyHexDump(builder, buf);</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="扩容">扩容</h5>
<p>当向ByteBuf写入数据时，发现容量不足时，会触发扩容。</p>
<p>假设ByteBuf初始容量是10。扩容规则为：</p>
<ul>
<li>内容大小&gt;Integer.Max则抛出异常</li>
<li>内容大小==4M，直接返回最新容量为4M</li>
<li>内容大小 &gt; 4M
<ul>
<li>内容大小 &lt;= 最大值-4M，最新容量=内容大小+4M</li>
<li>内容大小 &gt; 最大值-4M，最新容量=最大容量</li>
</ul>
</li>
<li>内容大小 &lt; 4M，每次扩容2倍，扩容基数为64kb。例如：64，128，256。</li>
</ul>
<h5 id="Reader相关方法">Reader相关方法</h5>
<p>reader方法也同样针对不同数据类型提供了不同的操作方法，</p>
<ul>
<li>readByte，读取单个字节</li>
<li>readInt，读取一个int类型</li>
<li>readFloat，读取一个float类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(); <span class="comment">//可自动扩容</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">//写入四个字节</span></span><br><span class="line">        log(buffer);</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buf)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()</span><br><span class="line">                .append(<span class="string">&quot; read index:&quot;</span>).append(buf.readerIndex())<span class="comment">//获取读索引</span></span><br><span class="line">                .append(<span class="string">&quot; write index:&quot;</span>).append(buf.writerIndex()) <span class="comment">//获取写索引</span></span><br><span class="line">                .append(<span class="string">&quot; capacity:&quot;</span>).append(buf.capacity())<span class="comment">//获取容量</span></span><br><span class="line">                .append(StringUtil.NEWLINE);</span><br><span class="line">        <span class="comment">//把ByteBuf中的内容，dump到StringBuilder中</span></span><br><span class="line">        ByteBufUtil.appendPrettyHexDump(builder, buf);</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从下面结果中可以看到，读完一个字节后，这个字节就变成了废弃部分，再次读取的时候只能读取未读取的部分数据。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211101701680.png" alt="img"></p>
<p>另外，如果想重复读取哪些已经读完的数据，这里提供了两个方法来实现标记和重置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(); <span class="comment">//可自动扩容</span></span><br><span class="line">     buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">//写入四个字节</span></span><br><span class="line">     log(buffer);</span><br><span class="line">     buffer.markReaderIndex();<span class="comment">//标记读取的索引位置</span></span><br><span class="line">     System.out.println(<span class="string">&quot;开始进行读取操作&quot;</span>);</span><br><span class="line">     System.out.println(buffer.readByte());</span><br><span class="line">     log(buffer);</span><br><span class="line">     buffer.resetReaderIndex();<span class="comment">//重置到标记位</span></span><br><span class="line">     System.out.println(<span class="string">&quot;重置到标记位&quot;</span>);</span><br><span class="line">     log(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果想不改变读指针位置来获得数据，在ByteBuf中提供了get开头的方法，这个方法基于索引位置读取，并且允许重复读取的功能。</p>
<h5 id="ByteBuf的零拷贝机制">ByteBuf的零拷贝机制</h5>
<p>需要说明一下，ByteBuf的零拷贝机制和我们之前提到的操作系统层面的零拷贝不同，操作系统层面的零拷贝，是我们要把一个文件发送到远程服务器时，需要从内核空间拷贝到用户空间,再从用户空间拷贝到内核空间的网卡缓冲区发送，导致拷贝次数增加。</p>
<p>而ByteBuf中的零拷贝思想也是相同，都是减少数据复制提升性能。如图3-2所示，假设有一个原始ByteBuf，我们想对这个ByteBuf其中的两个部分的数据进行操作。按照正常的思路，我们会创建两个新的ByteBuf，然后把原始ByteBuf中的部分数据拷贝到两个新的ByteBuf中，但是这种会涉及到数据拷贝，在并发量较大的情况下，会影响到性能。</p>
<p>ByteBuf中提供了一个slice方法，这个方法可以在不做数据拷贝的情况下对原始ByteBuf进行拆分，使用方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(); <span class="comment">//可自动扩容</span></span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);<span class="comment">//写入四个字节</span></span><br><span class="line">    log(buffer);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">b1</span> <span class="operator">=</span> buffer.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">b2</span> <span class="operator">=</span> buffer.slice(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    log(b1);</span><br><span class="line">    log(b2);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改原始数据&quot;</span>);</span><br><span class="line">    buffer.setByte(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">//修改原始buf数据</span></span><br><span class="line">    log(b1); <span class="comment">//再次打印b1的结果。发现数据发生了变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，通过slice对原始buf进行切片，每个分片是5个字节。</p>
<p>为了证明slice是没有数据拷贝，我们通过修改原始buf的索引2所在的值，然后再打印第一个分片b1,可以发现b1的结果发生了变化。说明两个分片和原始buf指向的数据是同一个。</p>
<h5 id="Unpooled">Unpooled</h5>
<p>Unpooled工具类，它是同了非池化的ByteBuf的创建、组合、复制等操作。</p>
<p>假设有一个协议数据，它有头部和消息体组成，这两个部分分别放在两个ByteBuf中</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuf </span>header = ...</span><br><span class="line"><span class="keyword">ByteBuf </span><span class="keyword">body </span>= ...</span><br></pre></td></tr></table></figure>
<p>我们希望把header和body合并成一个ByteBuf，通常的做法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">allBuf</span> <span class="operator">=</span> Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class="line">allBuf.writeBytes(header);</span><br><span class="line">allBuf.writeBytes(body);</span><br></pre></td></tr></table></figure>
<p>在这个过程中，我们把header和body拷贝到了新的allBuf中，这个过程在无形中增加了两次数据拷贝操作。那有没有更高效的方法减少拷贝次数来达到相同目的呢?<br>
​ 在Netty中，提供了一个<code>CompositeByteBuf</code>组件，它提供了这个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">header</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(); <span class="comment">//可自动扩容</span></span><br><span class="line">    header.writeCharSequence(<span class="string">&quot;header&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">body</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(); <span class="comment">//可自动扩容</span></span><br><span class="line">    body.writeCharSequence(<span class="string">&quot;body&quot;</span>,CharsetUtil.UTF_8);</span><br><span class="line">    <span class="type">CompositeByteBuf</span> <span class="variable">compositeByteBuf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line">    <span class="comment">//其中第一个参数是true，表示当添加新的ByteBuf时，自动递增CompositeByteBuf的writeIndex</span></span><br><span class="line">    <span class="comment">//默认是false,就是writeIndex=0,这样的话我们不可能从CompositeByteBuf中读到数据</span></span><br><span class="line">    compositeByteBuf.addComponents(<span class="literal">true</span>,header,body);</span><br><span class="line">    log(compositeByteBuf);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">allBuf</span> <span class="operator">=</span> Unpooled.buffer(header.readableBytes() + body.readableBytes());</span><br><span class="line">    allBuf.writeBytes(header);</span><br><span class="line">    allBuf.writeBytes(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以CompositeByteBuf能够实现零拷贝，是因为在组合header和body时，并没有对这两个数据进行复制，而是通过CompositeByteBuf构建了一个逻辑整体，里面仍然是两个真实对象，也就是有一个指针指向了同一个对象，所以这里类似于浅拷贝的实现。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211101701920.png" alt="img"></p>
<h5 id="wrappedBuffer">wrappedBuffer</h5>
<p>在Unpooled工具类中，提供了一个wrappedBuffer方法，来实现CompositeByteBuf零拷贝功能。使用方法如下。</p>
<h5 id="copiedBuffer">copiedBuffer</h5>
<p>copiedBuffer，和wrappedBuffer最大的区别是，该方法会实现数据复制，下面代码演示了<br>
copiedBuffer和wrappedbuffer的区别，可以看到在<code>case</code>标注的位置中，修改了原始ByteBuf的值，并没有影响到原来的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ByteBuf header= ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    header.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    ByteBuf body=ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    body.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;);</span><br><span class="line">    ByteBuf total=Unpooled.wrappedBuffer(header,body);</span><br><span class="line">    log(total);</span><br><span class="line">    header.setByte(<span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line">    log(total);</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.copiedBuffer(header, body);</span><br><span class="line">    log(byteBuf);</span><br><span class="line">    header.setByte(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">    log(byteBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  read index:0 write index:10 capacity :10         +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">     *          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     * |00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     *  read index:0 write index:10 capacity :10         +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">     *          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     * |00000000| 01 02 09 04 05 06 07 08 09 0a                   |..........      |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     * ===============================</span></span><br><span class="line"><span class="comment">     *  read index:0 write index:10 capacity :10         +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">     *          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     * |00000000| 01 02 09 04 05 06 07 08 09 0a                   |..........      |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     *  read index:0 write index:10 capacity :10         +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">     *          |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     * |00000000| 01 02 09 04 05 06 07 08 09 0a                   |..........      |</span></span><br><span class="line"><span class="comment">     * +--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h5 id="内存释放">内存释放</h5>
<p>针对不同的ByteBuf创建，内存释放的方法不同。</p>
<ul>
<li>UnpooledHeapByteBuf，使用JVM内存，只需要等待GC回收即可</li>
<li>UnpooledDirectByteBuf，使用堆外内存，需要特殊方法来回收内存</li>
<li>PooledByteBuf和它的子类使用了池化机制，需要更复杂的规则来回收</li>
</ul>
<p>内存如果ByteBuf是使用堆外内存来创建，那么尽量手动释放内存，那怎么释放呢?</p>
<p>Netty采用了引用计数方法来控制内存回收，每个ByteBuf都实现了ReferenceCounted接口。</p>
<ul>
<li>每个ByteBuf对象的初始计数为1</li>
<li>调用release方法时，计数器减一，如果计数器为0，ByteBuf被回收</li>
<li>调用retain方法时，计数器加一，表示调用者没用完之前，其他handler即时调用了release也不会造成回收。</li>
<li>当计数器为0时，底层内存会被回收，这时即使ByteBuf对象还存在，但是它的各个方法都无法正常使用</li>
</ul>
<h4 id="TaskQueue任务队列">TaskQueue任务队列</h4>
<p><strong>解决问题：耗时的业务处理，防止阻塞</strong></p>
<p>在 ChannelInboundHandlerAdapter 的 channelRead 方法执行时 , 客户端与服务器端的反应器 Reactor 线程 NioEventLoop 是处于阻塞状态的 , 此时服务器端与客户端同时都处于阻塞状态 , 这样肯定不行 , 因为 NioEventLoop 需要为多个客户端服务 , 不能因为与单一客户端交互而产生阻塞 ;</p>
<p><strong>用法：</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">//获取到线程池eventLoop，添加线程，执行</span></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void run() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span></span><br><span class="line">                    <span class="type">Thread</span>.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">System</span>.out.println(<span class="string">&quot;长时间的业务处理&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ScheduleTaskQueue延时任务队列">ScheduleTaskQueue延时任务队列</h4>
<p><strong>解决问题：需要定时执行的业务</strong></p>
<p><strong>用法：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;长时间的业务处理&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">5</span>, TimeUnit.SECONDS);<span class="comment">//5秒后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Channel">Channel</h4>
<p>Channel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channel 的EventLoop。</p>
<p><strong>作用：</strong></p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭
<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h4 id="EventLoop-EventLoopGroup">EventLoop&amp;EventLoopGroup</h4>
<p><strong>事件循环对象</strong></p>
<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，</li>
<li>提供了 <strong>boolean inEventLoop(Thread thread)</strong> 的方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
<p><strong>事件循环组</strong></p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup</li>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
<p>Channel 为Netty 网络操作抽象类，EventLoop 主要是为Channel 处理 I/O 操作，两者配合参与 I/O 操作。</p>
<p>下图是Channel、EventLoop、Thread、EventLoopGroup之间的关系（摘自《Netty In Action》）：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211082105620.jpeg" alt="img"></p>
<ul>
<li>一个 EventLoopGroup 包含一个或多个 EventLoop。</li>
<li>一个 EventLoop 在它的生命周期内只能与一个Thread绑定。</li>
<li>所有有 EnventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理。</li>
<li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li>
<li>一个 EventLoop 可被分配至一个或多个 Channel 。</li>
</ul>
<p>当一个连接到达时，Netty 就会注册一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 绑定到这个Channel上，在该Channel的整个生命周期中都是有这个绑定的 EventLoop 来服务的。</p>
<h4 id="ChannelFuture">ChannelFuture</h4>
<p>Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<p><strong>解决问题：需要对操作进行监听的业务</strong></p>
<p><strong>用法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    <span class="comment">//使用匿名内部类，ChannelFutureListener接口</span></span><br><span class="line">    <span class="comment">//重写operationComplete方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	 * 主要方法有：</span></span><br><span class="line"><span class="comment">         * isDone 判断当前操作是否完成</span></span><br><span class="line"><span class="comment">         * isSuccess 判断当前操作是否成功执行</span></span><br><span class="line"><span class="comment">         * getCause 获取当前操作失败的原因</span></span><br><span class="line"><span class="comment">         * isCanclled 判断当前已完成的操作是否被取消</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//判断是否操作成功    </span></span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).sync();</span><br><span class="line"><span class="comment">//或者在客户端处理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">//发送消息到服务端</span></span><br><span class="line">	ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;我是客户端&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ChannelHandler-ChannelPipeline">ChannelHandler&amp;ChannelPipeline</h4>
<p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L3RrZT9mcm9tPTEwNjgw">容器<i class="fa fa-external-link-alt"></i></span>。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>
</ul>
<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品。</p>
<p>所有 ChannelHandler 被连成一串，就是 Pipeline，ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211082105583.png" alt="img"></p>
<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>
<p>当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。其中 ChannelHandler 添加到 ChannelPipeline 过程如下：</p>
<ol>
<li>一个 ChannelInitializer 的实现被注册到了 ServerBootStrap中</li>
<li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler</li>
<li>ChannelInitializer 将它自己从 ChannelPipeline 中移除</li>
</ol>
<p>猜一下，下面的输出结果：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .<span class="title function_">group</span>(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .<span class="title function_">channel</span>(<span class="title class_">NioServerSocketChannel</span>.<span class="property">class</span>)</span><br><span class="line">    .<span class="title function_">childHandler</span>(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;<span class="title class_">NioSocketChannel</span>&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">void</span> <span class="title function_">initChannel</span>(<span class="params">NioSocketChannel ch</span>) &#123;</span><br><span class="line">            ch.<span class="title function_">pipeline</span>().<span class="title function_">addLast</span>(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">channelRead</span>(<span class="params">ChannelHandlerContext ctx, <span class="built_in">Object</span> msg</span>) &#123;</span><br><span class="line">                    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">1</span>);</span><br><span class="line">                    ctx.<span class="title function_">fireChannelRead</span>(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.<span class="title function_">pipeline</span>().<span class="title function_">addLast</span>(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">channelRead</span>(<span class="params">ChannelHandlerContext ctx, <span class="built_in">Object</span> msg</span>) &#123;</span><br><span class="line">                    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">2</span>);</span><br><span class="line">                    ctx.<span class="title function_">fireChannelRead</span>(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.<span class="title function_">pipeline</span>().<span class="title function_">addLast</span>(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">channelRead</span>(<span class="params">ChannelHandlerContext ctx, <span class="built_in">Object</span> msg</span>) &#123;</span><br><span class="line">                    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">3</span>);</span><br><span class="line">                    ctx.<span class="title function_">channel</span>().<span class="title function_">write</span>(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.<span class="title function_">pipeline</span>().<span class="title function_">addLast</span>(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">write</span>(<span class="params">ChannelHandlerContext ctx, <span class="built_in">Object</span> msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise</span>) &#123;</span><br><span class="line">                    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">4</span>);</span><br><span class="line">                    ctx.<span class="title function_">write</span>(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.<span class="title function_">pipeline</span>().<span class="title function_">addLast</span>(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">write</span>(<span class="params">ChannelHandlerContext ctx, <span class="built_in">Object</span> msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise</span>) &#123;</span><br><span class="line">                    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">5</span>);</span><br><span class="line">                    ctx.<span class="title function_">write</span>(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.<span class="title function_">pipeline</span>().<span class="title function_">addLast</span>(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">write</span>(<span class="params">ChannelHandlerContext ctx, <span class="built_in">Object</span> msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise</span>) &#123;</span><br><span class="line">                    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="number">6</span>);</span><br><span class="line">                    ctx.<span class="title function_">write</span>(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="相关面试题">相关面试题</h3>
<h4 id="Netty-是什么？">Netty 是什么？</h4>
<ul>
<li>Netty 是一个 <strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>
<li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li>
<li><strong>支持多种协议</strong> 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ul>
<h4 id="为什么要用-Netty？">为什么要用 Netty？</h4>
<ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li>
<li>简单而强大的线程模型。</li>
<li>自带编解码器解决 TCP 粘包/拆包问题。</li>
<li>自带各种协议栈。</li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。</li>
<li>社区活跃</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目比如我们常用的 Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</li>
</ul>
<h4 id="Netty-应用场景了解么？">Netty 应用场景了解么？</h4>
<p>理论上来说，NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做<strong>网络通信</strong> :</p>
<ul>
<li>作为 RPC 框架的网络通信组件** ：我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务节点之间的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！</li>
<li><strong>实现一个自己的 HTTP 服务器</strong> ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。</li>
<li><strong>实现一个即时通讯系统</strong> ：使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。</li>
<li><strong>实现消息推送系统</strong> ：市面上有很多消息推送系统都是基于 Netty 来做的。</li>
</ul>
<h4 id="Netty-核心组件有哪些？分别有什么作用？">Netty 核心组件有哪些？分别有什么作用？</h4>
<h5 id="1-Channel">1.Channel</h5>
<p><strong>Channel</strong> 接口是 <strong>Netty</strong> 对网络操作抽象类，它除了包括基本的 <strong>I/O</strong> 操作，如 <strong>bind()</strong>、<strong>connect()</strong>、<strong>read()</strong>、<strong>write()</strong> 等。</p>
<p>比较常用的<strong>Channel</strong>接口实现类是<strong>NioServerSocketChannel</strong>（服务端）和<strong>NioSocketChannel</strong>（客户端），这两个 <strong>Channel</strong> 可以和 <strong>BIO</strong> 编程模型中的<strong>ServerSocket</strong>以及<strong>Socket</strong>两个概念对应上。<strong>Netty</strong> 的 <strong>Channel</strong> 接口所提供的 <strong>API</strong>，大大地降低了直接使用 <strong>Socket</strong> 类的复杂性。</p>
<h5 id="2-EventLoop">2.EventLoop</h5>
<p>这么说吧！<strong>EventLoop</strong>（事件循环）接口可以说是 <strong>Netty</strong> 中最核心的概念了！</p>
<p>《Netty 实战》这本书是这样介绍它的：</p>
<blockquote>
<p>“EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。</p>
</blockquote>
<p>是不是很难理解？说实话，我学习 Netty 的时候看到这句话是没太能理解的。</p>
<p>说白了，<strong>EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。</strong></p>
<p>那 <strong>Channel</strong> 和 <strong>EventLoop</strong> 直接有啥联系呢？</p>
<p>Channel 为 Netty 网络操作(读写等操作)抽象类，<strong>EventLoop</strong> 负责处理注册到其上的<strong>Channel</strong> 处理 I/O 操作，两者配合参与 I/O 操作。</p>
<h5 id="3-ChannelFuture">3.ChannelFuture</h5>
<p><strong>Netty</strong> 是异步非阻塞的，所有的 I/O 操作都为异步的。</p>
<p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <strong>ChannelFuture</strong> 接口的 <strong>addListener()</strong> 方法注册一个 <strong>ChannelFutureListener</strong>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<p>并且，你还可以通过<strong>ChannelFuture 的 channel()</strong> 方法获取关联的<strong>Channel</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public interface ChannelFuture extends Future&lt;Void&gt; &#123;</span><br><span class="line">    Channel channel();</span><br><span class="line"></span><br><span class="line">    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; var1);</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    ChannelFuture sync() throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以通过 <strong>ChannelFuture</strong> 接口的 **sync()**方法让异步的操作变成同步的。</p>
<h5 id="4-ChannelHandler-和-ChannelPipeline">4.ChannelHandler 和 ChannelPipeline</h5>
<p>下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 <strong>ChannelHandler</strong> 处理消息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">b.group(eventLoopGroup)</span><br><span class="line">        .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void initChannel(SocketChannel ch) &#123;</span><br><span class="line">                ch.pipeline().addLast(new NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">                ch.pipeline().addLast(new NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">                ch.pipeline().addLast(new KryoClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>ChannelHandler</strong> 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p>
<p><strong>ChannelPipeline</strong> 为 <strong>ChannelHandler</strong> 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 <strong>Channel</strong> 被创建时，它会被自动地分配到它专属的<strong>ChannelPipeline</strong>。</p>
<p>我们可以在 <strong>ChannelPipeline</strong> 上通过 <strong>addLast()</strong> 方法添加一个或者多个<strong>ChannelHandler</strong> ，因为一个数据或者事件可能会被多个 <strong>Handler</strong> 处理。当一个 <strong>ChannelHandler</strong> 处理完之后就将数据交给下一个 <strong>ChannelHandler</strong> 。</p>
<h4 id="EventloopGroup-了解么-和-EventLoop-啥关系">EventloopGroup 了解么?和 EventLoop 啥关系?</h4>
<p>EventLoopGroup（线程组）包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程），上面我们已经说了 EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。</p>
<p>并且 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</p>
<h4 id="Bootstrap-和-ServerBootstrap-了解么？">Bootstrap 和 ServerBootstrap 了解么？</h4>
<ul>
<li>
<p>Bootstrap 是客户端的启动引导类/辅助类。</p>
</li>
<li>
<p>ServerBootstrap 服务的启动引导类/辅助类</p>
</li>
<li>
<p>Bootstrap 通常使用 connet() 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，Bootstrap 也可以通过 bind() 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</p>
</li>
<li>
<p>ServerBootstrap通常使用 bind() 方法绑定本地的端口上，然后等待客户端的连接。</p>
</li>
<li>
<p>Bootstrap 只需要配置一个线程组— EventLoopGroup ,而 ServerBootstrap需要配置两个线程组— EventLoopGroup ，一个用于接收连接，一个用于具体的处理。</p>
</li>
</ul>
<h4 id="Netty-服务端和客户端的启动过程了解么？">Netty 服务端和客户端的启动过程了解么？</h4>
<p><strong>服务端：</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211091129493.png" alt="img"></p>
<p><strong>客户端：</strong></p>
<ul>
<li>用户线程创建Bootstrap实例，通过API设置创建客户端相关的参数，异步发起客户端连接。</li>
<li>创建处理客户端连接、I/O读写的Reator线程组NioEventLoopGroup。可以通过构造函数指定I/O线程的个数，默认为CPU内核数的2倍。</li>
<li>通过Bootstrap的ChannelFactory和用户指定的Channel类型创建用于客户端连接的NioSocketChannel，它的功能类似于JDK NIO类库提供的SocketChannel。</li>
<li>创建默认的Channel Handler Pipeline，用于调度和执行网络事件。</li>
<li>异步发起TCP连接，判断连接是否成功。如果成功，则直接将NioSocketChannel注册到多路复用器上，监听读操作位，用于数据报读取和消息发送。如果没有立即连接成功，则注册连接监听位到多路复用器，等待连接结果。</li>
<li>注册对应的网络监听状态位到多路复用器。</li>
<li>由多路复用器在I/O现场中轮询Channel，处理连接结果。</li>
<li>如果连接成功，设置Future结果，发送连接成功事件，触发ChannelPipeline执行。<br>
有ChannelPipeline调度执行系统和用户的ChannelHandler，执行业务逻辑。</li>
</ul>
<h4 id="Netty-长连接、心跳机制了解么？">Netty 长连接、心跳机制了解么？</h4>
<p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，他们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 心跳机制 。</p>
<p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于</p>
<p>idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.</p>
<p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：</p>
<p>SO_KEEPALIVE。但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义信跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 IdleStateHandler 。</p>
<h4 id="Netty-的零拷贝了解么？">Netty 的零拷贝了解么？</h4>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202211091146020.png" alt="img"></p>
<p>传统数据拷贝方式：<br>
（1）数据从存储设备或网卡缓冲区，拷贝到内核的received buffer<br>
（2）数据从received buffer读到堆外内存，再拷贝到用户缓冲区<br>
（3）数据从用户缓冲区拷贝到堆外内存，再写到内核的send buffer<br>
（4）数据从send buffer再拷贝到网卡buffer<br>
Netty零拷贝方式：<br>
（1）调用java的FileChannel.transferTo()，数据从存储设备或网卡buffer利用DMA引擎拷贝到received buffer<br>
（2）数据从received buffer读到堆外内存<br>
（3）数据从堆外内存写到send buffer<br>
（4）数据从send buffer再利用DMA引擎拷贝到网卡buffer<br>
由于以上操作都不需要CPU参与，所以就达到了“零拷贝”的效果，传统拷贝都是需要CPU参与的，就会占用cpu资源，DMA拷贝是不需要CPU的。<br>
除此之外，对于传统的ByteBuffer，如果需要将两个ByteBuffer中的数据组合到一起，我们就需要创建一个size=size1+size2大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。</p>
<p>但是使用Netty提供的组合ByteBuf（CompositeByteBuf），就可以避免这样的操作，因为CompositeByteBuf并没有真正将多个Buffer组合起来，而是保存了它们的引用，从而避免了数据的拷贝，这也是“零拷贝”的另一个体现。</p>
<h4 id="Netty是基于NIO实现的，那么什么是NIO？Netty中的NIO相比原始NIO的优势在哪儿？">Netty是基于NIO实现的，那么什么是NIO？Netty中的NIO相比原始NIO的优势在哪儿？</h4>
<p><strong>NIO</strong></p>
<p>非阻塞IO模型</p>
<p><strong>优势：</strong></p>
<ul>
<li>JDK的NIO存在空轮询的BUG，而Netty则巧妙的规避了这一点；</li>
<li>JDK的API复杂，开发人员使用起来比较困难，更重要的是，很容易写出BUG；而Netty的API简单，容易上手。</li>
<li>Netty的性能更高，它在JDK的基础上做了很多性能优化，例如将selector中的<code>publicSelectedKeys</code>属性的数据结构由Set集合改成了数组。</li>
<li>Netty底层对IO模型可以随意切换，针对Reactor三种线程模型，只需要通过修改参数就可以实现IO模型的切换。</li>
<li>Netty经过了众多高并发场景的考验，如Dubbo等RPC框架的验证。</li>
<li>Netty帮助我们解决了TCP的粘包拆包等问题，开发人员不用去关心这些问题，只需专注于业务逻辑开发即可。</li>
<li>Netty支持很多协议栈。JDK自带的对象序列化性能很差，序列化后码流较大，而是用其他方式的序列化则性能较高，例如protobuf等。</li>
</ul>
<h4 id="Netty的线程模型是基于Reactor线程模型的，那么什么是Reactor线程模型呢？">Netty的线程模型是基于Reactor线程模型的，那么什么是Reactor线程模型呢？</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yOTk0ODM0MjA=">Netty中的Reactor和Proactor模型 - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="Netty是异步非阻塞的，异步和非阻塞体现在什么地方？">Netty是异步非阻塞的，异步和非阻塞体现在什么地方？</h4>
<ul>
<li>首先Netty非阻塞就是因为NIO中的Selector，可以轮询监听多条通道（一个客户端对应一条通道），而不像传统的BIO，一个线程只能负责一个客户端，只要客户端没发请求过来，线程就一直阻塞着傻傻等待，浪费资源。</li>
<li>第二个异步的概念是当一个异步过程调用发出后会立即返回，调用者不能立刻得到结果。实际处理完成后，通过状态、通知或者回调的形式来告诉调用者，异步的优势是在高并发情形下会更稳定，具有更高吞吐量。</li>
<li>Netty中的IO操作都是异步的，异步的实现是依靠ChannelFuture，它可以添加ChannelFutureListener监听器，当IO操作真正完成的时候，客户端会得到操作成功或失败的通知。</li>
</ul>
<h4 id="Netty对于TCP粘包、半包问题的解决？">Netty对于TCP粘包、半包问题的解决？</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSWloeWNVSWNkVHVpZ0VtQmJia2ZCZw==">Netty源码分析系列之TCP粘包、半包问题以及Netty是如何解决的 (qq.com)<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="Netty为什么不使用AIO">Netty为什么不使用AIO?</h4>
<ol>
<li>Netty 不看重 Windows 上的使用，在 Linux 系统上，AIO 的底层实现仍使用 EPOLL，没有很好实现 AIO，因此在性能上没有明显的优势，而且被 JDK 封装了一层不容易深度优化</li>
<li>Netty 整体架构是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPXJlYWN0b3Imc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9zb3VyY2U9RW50aXR5Jmh5YnJpZF9zZWFyY2hfZXh0cmE9JTdCJTIyc291cmNlVHlwZSUyMiUzQSUyMmFuc3dlciUyMiUyQyUyMnNvdXJjZUlkJTIyJTNBMjMwODcyMjAzOSU3RA==">reactor<i class="fa fa-external-link-alt"></i></span> 模型, 而 AIO 是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPXByb2FjdG9yJnNlYXJjaF9zb3VyY2U9RW50aXR5Jmh5YnJpZF9zZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX2V4dHJhPSU3QiUyMnNvdXJjZVR5cGUlMjIlM0ElMjJhbnN3ZXIlMjIlMkMlMjJzb3VyY2VJZCUyMiUzQTIzMDg3MjIwMzklN0Q=">proactor<i class="fa fa-external-link-alt"></i></span> 模型, 混合在一起会非常混乱,把 AIO 也改造成 reactor 模型看起来是把 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPWVwb2xsJnNlYXJjaF9zb3VyY2U9RW50aXR5Jmh5YnJpZF9zZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX2V4dHJhPSU3QiUyMnNvdXJjZVR5cGUlMjIlM0ElMjJhbnN3ZXIlMjIlMkMlMjJzb3VyY2VJZCUyMiUzQTIzMDg3MjIwMzklN0Q=">epoll<i class="fa fa-external-link-alt"></i></span> 绕个弯又绕回来，具体模型可以参考这篇文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDI0NTU4MDA=">你真的了解Netty吗？<i class="fa fa-external-link-alt"></i></span></li>
<li>AIO 还有个缺点是接收数据需要预先分配缓存, 而不是 NIO 那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多</li>
<li>Linux 上 AIO 不够成熟，处理回调结果速度跟不到处理需求，比如外卖员太少，顾客太多，供不应求，造成处理速度有瓶颈</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
</search>
