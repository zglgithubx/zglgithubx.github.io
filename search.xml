<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang项目部署</title>
    <url>/posts/36933.html</url>
    <content><![CDATA[<p>此博客提供了三种方案，可以根据项目需求适当选择</p>
<span id="more"></span>
<h3 id="qian-yan" id="前言">前言</h3>
<p>Golang项目部署流程：编译——&gt;上传到服务器——&gt;运行。<br />
简单的实现方案有：本地编译上传部署，构建docker镜像部署，自动化docker镜像部署</p>
<h3 id="1-ben-di-bian-yi-shang-chuan-bu-shu" id="1、本地编译上传部署">1、本地编译上传部署</h3>
<blockquote>
<p>注：在本地（window环镜）编译，需修改Go语言的环境配置<br />
命令：go env -w GOOS=linux</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>在项目根目录执行,生成二进制文件server</span><br><span class="line">go build -o server .</span><br><span class="line"><span class="regexp">//</span>上传到服务器，<span class="number">22</span>为服务端口，/xxx为服务器目录</span><br><span class="line">scp -P <span class="number">22</span> server root@ip:/xxx</span><br><span class="line"><span class="regexp">//</span>在服务器切换到文件目录</span><br><span class="line">cd /xxx</span><br><span class="line"><span class="regexp">//</span>运行二进制文件</span><br><span class="line">nohup ./server &gt;start.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>查看日志</span><br><span class="line">tail -f <span class="number">200</span> start.log</span><br></pre></td></tr></table></figure>
<h3 id="2-gou-jian-docker-jing-xiang-bu-shu" id="2、构建docker镜像部署">2、构建docker镜像部署</h3>
<ul>
<li>在项目根目录创建Dockerfile文件</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一阶段构建编译环境</span></span><br><span class="line"><span class="keyword">FROM</span> golang:alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /project/go</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go <span class="built_in">env</span> -w GO111MODULE=on \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; go generate &amp;&amp; go <span class="built_in">env</span> &amp;&amp; go build -o server .</span></span><br><span class="line"><span class="comment"># 第二阶段构建运行环境，alpine为linux轻量级发行版</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /project/go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /project/go ./</span></span><br><span class="line">//暴露的端口号</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8888</span></span><br><span class="line">//容器运行时执行，直接运行二进制文件，防止容器挂掉</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./server</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://xn--shellgo-ig5kq7upx8ahcpluesr6h.sh">创建shell脚本文件go.sh</a>（简化部署步骤）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 镜像名字</span></span><br><span class="line">IMAGE_NAME=centos7_go_database</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker容器名字</span></span><br><span class="line">CONTAINER_NAME=go</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译好的二进制文件</span></span><br><span class="line">SERVER_NAME=server</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数X</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [start]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">#构建镜像和并启动容器(在宿主机执行)</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#容器id</span></span><br><span class="line">  CID=$(docker ps -a | grep <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#镜像id</span></span><br><span class="line">  IID=$(docker images | grep <span class="string">&quot;<span class="variable">$IMAGE_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建docker镜像</span></span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$IMAGE_NAME</span> image，IID=<span class="variable">$IID</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;NOT exit <span class="variable">$IMAGE_NAME</span> image，start build image...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据项目个路径下的Dockerfile文件，构建镜像</span></span><br><span class="line"></span><br><span class="line">    docker build -t <span class="variable">$IMAGE_NAME</span> .</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$IMAGE_NAME</span> image has been builded&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$CONTAINER_NAME</span> container，CID=<span class="variable">$CID</span>.   ---Remove container&quot;</span></span><br><span class="line"></span><br><span class="line">      docker stop <span class="variable">$CONTAINER_NAME</span>   <span class="comment"># 停止运行中的容器</span></span><br><span class="line"></span><br><span class="line">      docker <span class="built_in">rm</span> <span class="variable">$CONTAINER_NAME</span>     <span class="comment">##删除原来的容器</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构建容器</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span> container,start build...&quot;</span></span><br><span class="line">  <span class="comment"># 运行容器</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># --name 容器的名字</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#   -d   容器后台运行</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#   -p   指定容器映射的端口和主机对应的端口</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#   -v   将主机的目录挂载到容器的目录中（不可少）</span></span><br><span class="line"></span><br><span class="line">  docker run -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -p 8888:8888 -<span class="built_in">id</span> --name <span class="variable">$CONTAINER_NAME</span> -v <span class="variable">$PWD</span>:/project/<span class="variable">$CONTAINER_NAME</span> <span class="variable">$IMAGE_NAME</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CONTAINER_NAME</span> container build end&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<ul>
<li>开始部署</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh</span> <span class="keyword">go</span>.<span class="keyword">sh</span> start</span><br></pre></td></tr></table></figure>
<h3 id="3-zi-dong-hua-docker-jing-xiang-bu-shu" id="3、自动化docker镜像部署">3、自动化docker镜像部署</h3>
<p>此自动化方案是基于阿里云效代码平台的流水线功能实现的，实现的效果：当有master分支有完成合并请求时执行（和其他的方案大同小异，思想可以借鉴）</p>
<ul>
<li>创建流水线选择模板</li>
</ul>
<p><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/202207161736015.png" alt="" /></p>
<ul>
<li>测试步骤可以根据需要进行删改</li>
<li>点击流水线源，编辑流水线源
<ul>
<li>开启代码出发——&gt;合并请求完成后</li>
<li>设置工作目录：api</li>
</ul>
</li>
<li>编辑构建步骤
<ul>
<li>选择构建集群（可以查看官方教程）</li>
<li>选择下载部分流水线源</li>
<li>流水线源选择仓库代码</li>
<li>构建命令：</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换到流水线的工作目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/workspace/api</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译项目文件，此步骤是在平台进行项目编译，可以选择不编译，因为在Dockerfile中已经有编译的步骤</span></span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct \&amp;&amp; go <span class="built_in">env</span> -w GO111MODULE=on \&amp;&amp; go <span class="built_in">env</span> -w CGO_ENABLED=0 \&amp;&amp; go generate &amp;&amp; go <span class="built_in">env</span> &amp;&amp; go build -o server .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>* 构建物上传，打包路径为./ 此打包路径指打包项目根目录下所有文件
</code></pre>
<ul>
<li>编辑部署步骤
<ul>
<li>下载路径：下载到服务器的文件目录，需要提前创建</li>
<li>执行用户：root</li>
<li>部署脚本：</li>
</ul>
</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压项目二进制压缩包（构建物上传时直接将压缩包上传到了下载路径）</span></span><br><span class="line">tar zxvf 下载路径 -C 解压目录</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到项目目录</span></span><br><span class="line">cd 解压目录</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本文件</span></span><br><span class="line"><span class="keyword">sh </span>go.<span class="keyword">sh </span>start</span><br></pre></td></tr></table></figure>
<p>自此完成部署</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/35921.html</url>
    <content><![CDATA[<h3 id="you-lai" id="由来">由来</h3>
<p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<span id="more"></span>
<h3 id="kmp-suan-fa-shi-shi-yao" id="KMP算法是什么">KMP算法是什么</h3>
<p>KMP算法主要应用于字符串的快速匹配。</p>
<p>比如在给定字符串中，让你找一个目标子串，常规的解法就是暴力匹配，用双层for循环分别遍历两个字符串，但是它的时间复杂度是O(m*n)。而KMP算法可以让这个匹配过程降到时间复杂度为O(m+n)。</p>
<h3 id="kmp-suan-fa-wei-shi-yao-na-yao-kuai" id="KMP算法为什么那么快">KMP算法为什么那么快</h3>
<h4 id="ju-ge" id="举个🌰">举个🌰</h4>
<p>在文本串（aabaabaaf）中，找到第一次匹配到模式串（aabaaf）的索引。</p>
<p>KMP算法匹配的过程：</p>
<p>①和常规解法一样，从文本串首字符和模式串的首字符开始，一 一进行比较</p>
<p>②当遇到不匹配的时候，如下图</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171018117.png" alt="image-20211017101822955" /></p>
<p>模式串会从b的位置开始匹配，文本串匹配的位置不变</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171106451.png" alt="image-20211017110657407" /></p>
<p>到这里，肯定会有疑问：会什么从b开始？</p>
<p>下面的概念都是模式串的。</p>
<p>这里会提到几个概念：前缀、后缀和 最大公共字符长度表（前缀表）</p>
<ul>
<li>
<p>前缀：除了末尾字符之外的所有字符</p>
</li>
<li>
<p>后缀：除了首字符之外的所有字符</p>
</li>
<li>
<p>最大公共字符长度表：每个子串中最长相同的前后缀字符长度</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>模式串的各个子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最大公共字符长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>空</td>
<td>空</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a,aa</td>
<td>b,ba</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a,aa,aab</td>
<td>a,ba,aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a,aa,aab,aaba</td>
<td>a,aa,baa,abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a,aa,aab,aabaa</td>
<td>f,af,aaf,baaf,abaaf</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>为什么有最大公共字符长度表？</p>
<p>这个表，可以在你匹配失败时，跳跃式的匹配，避免重复已经匹配相同的字符。</p>
<p>③直到将文本串匹配完</p>
<h4 id="ju-ge-wan-zheng-de" id="举个完整的🌰">举个完整的🌰</h4>
<p>文本串：BBC ABCDAB ABCDABCDABDE</p>
<p>模式串：ABCDABD</p>
<p>前缀表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大前缀后缀公共元素长度</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>这个例子咱们就根据这个前缀表去跳跃式的匹配（表中的数值代表跳跃到模式串索引）</p>
<p>①开始匹配</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171151156.png" alt="img" /></p>
<p>② 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171151451.png" alt="img" /></p>
<p>③继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《前缀表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171152957.png" alt="img" /></p>
<p>④模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171153610.png" alt="img" /></p>
<p>⑤A与空格不匹配，向右移动1位</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171154064.png" alt="img" /></p>
<p>⑥继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171154305.png" alt="img" /></p>
<p>⑦经历第5步后，发现匹配成功，过程结束。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110171155335.png" alt="img" /></p>
<p>至此这就是KMP算法的大致原理。</p>
<h3 id="kmp-suan-fa-dai-ma-shi-xian" id="KMP算法代码实现">KMP算法代码实现</h3>
<p>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大前缀后缀公共元素长度</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>而且，根据这个表可以得出下述结论</p>
<p>当失配时，模式串向右移动的位数为：已匹配字符数-失配字符的上一位字符所对应的最大长度值</p>
<p>文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p>
<p>给定字符串“ABCDABD”，可求得它的next 数组如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>A</th>
<th>B</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="next-shu-zu-qiu-fa" id="Next数组求法">Next数组求法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> strlen(p);  </span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>KMP算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">KmpSearch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> strlen(s);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> strlen(p);  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++      </span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]      </span></span><br><span class="line">            <span class="comment">//next[j]即为j所对应的next值        </span></span><br><span class="line">            j = next[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置之location</title>
    <url>/posts/35269.html</url>
    <content><![CDATA[<p>nginx学习location的使用</p>
<span id="more"></span>
<h3 id="1-location-jie-shao" id="1、location介绍">1、location介绍</h3>
<p>location是Nginx中的块级指令(block directive),location指令的功能是用来匹配不同的url请求，进而对请求做不同的处理和响应，这其中较难理解的是多个location的匹配顺序。</p>
<p>开始之前先明确一些约定，我们输入的网址叫做请求URI，nginx用请求URI与location中配置的URI做匹配。</p>
<h3 id="2-location-yu-fa" id="2、location-语法">2、location 语法</h3>
<p>location有两种匹配规则：</p>
<ul>
<li>匹配URL类型，有四种参数可选，当然也可以不带参数。 location [ = | ~ | ~* | ^~ ] uri { … }</li>
<li>命名location，用@标识，类似于定于goto语句块。 location @name { … }</li>
</ul>
<p>location匹配参数解释：</p>
<p>（1） “=” ，精确匹配</p>
<ul>
<li>内容要同表达式完全一致才匹配成功</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> =/abc&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.baidu.com/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问 http://117.50.162.61:88/abc-&gt;http://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<p>（2） “~”，执行正则匹配，区分大小写</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /Abc</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问http://117.50.162.61:88/Abc-&gt;</span></span><br><span class="line">http://www.baidu.com/Abc</span><br></pre></td></tr></table></figure>
<p>（3）“~*”，执行正则匹配，忽略大小写</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> ~*/Def&#123;</span><br><span class="line">     <span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问http://117.50.162.61:88/def|Def-&gt;</span></span><br><span class="line">http://www.baidu.com/def|Def</span><br></pre></td></tr></table></figure>
<p>（4）“^~”，表示普通字符串匹配上以后不再进行正则匹配。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /index &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.baidu.com/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问http://117.50.162.61:88/index-&gt;</span></span><br><span class="line">http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>（5）不加任何规则时，默认是大小写敏感，前缀匹配，相当于加了“<sub>”与“^</sub>”</p>
<p>（6）“@”，nginx内部跳转</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /index/ &#123;</span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">404</span> <span class="variable">@index_error</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> <span class="variable">@index_error</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#以 /index/ 开头的请求，如果链接的状态为 404。则会匹配到 @index_error 这条规则上。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-location-uri-jie-wei-dai-bu-dai" id="3、location-URI结尾带不带">3、location URI结尾带不带 /</h3>
<p>(1)结尾不带/</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">proxy_proxy</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问：http://117.50.162.61:88/test-&gt;</span></span><br><span class="line">http://www.baidu.com/<span class="attribute">test</span></span><br><span class="line">即此种情况会把所有的路径加uri中</span><br></pre></td></tr></table></figure>
<p>(1)结尾带/</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">proxy_proxy</span> http://www.baidu.com/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问：http://117.50.162.61:88/test/index-&gt;</span></span><br><span class="line">http://www.baidu.com/<span class="attribute">index</span></span><br><span class="line">即此种情况会把除了匹配路径之外的地址加到uri中</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣_50之x的n次幂</title>
    <url>/posts/4606.html</url>
    <content><![CDATA[<p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。</p>
<p><strong>示例 1：</strong><br />
输入：x = 2.00000, n = 10<br />
输出：1024.00000</p>
<p><strong>示例 2：</strong><br />
输入：x = 2.10000, n = 3<br />
输出：9.26100</p>
<p><strong>示例 3：</strong><br />
输入：x = 2.00000, n = -2<br />
输出：0.25000<br />
解释：2-2 = 1/22 = 1/4 = 0.25</p>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode.cn/problems/powx-n">https://leetcode.cn/problems/powx-n</a></p>
<span id="more"></span>
<h3 id="fang-fa-1-die-dai" id="方法1：迭代">方法1：迭代</h3>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">myPow1</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> res=<span class="number">1.00000</span>;</span><br><span class="line">    <span class="comment">//判断0次幂和1的任何次幂；</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||x==res)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断-1的n次幂</span></span><br><span class="line">    <span class="keyword">if</span>(x*<span class="number">-1</span>==res)&#123;</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断最小次幂及0的n次幂</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">-2147483648</span>||x==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res*<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代求n次幂</span></span><br><span class="line">    <span class="type">int</span> len=n&lt;<span class="number">0</span>?n*<span class="number">-1</span>:n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        res=res*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1.0</span>/res:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：2484ms</p>
<h3 id="fang-fa-2-kuai-su-mi-di-gui-guan-fang" id="方法2：快速幂-递归-官方">方法2：快速幂 + 递归(官方)</h3>
<p>「快速幂算法」的本质是分治算法。<br />
举个例子，如果我们要计算 x64，我们可以按照：x→x2→x4→x8→x16→x32→x64的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 x64的值，而不需要对 x 乘 63 次 x。再举一个例子，如果我们要计算 x77，我们可以按照：x→x2→x4→x9→x19→x38→x77的顺序，在 x→x2，x2→x4，x19→x38这些步骤中，我们直接把上一次的结果进行平方，而在 x4→x9，x9→x19，x38→x77这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：</p>
<ul>
<li>当我们要计算 xn时，我们可以先递归地计算出 y=x⌊n/2⌋，其中 ⌊a⌋ 表示对 a 进行下取整；</li>
<li>根据递归计算的结果，如果 n 为偶数，那么 xn=y2；如果 n 为奇数，那么 xn=y2×x；</li>
<li>递归的边界为 n=0，任意数的 0 次方均为 1。<br />
由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> N = n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分治法</span></span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//判断奇偶次幂</span></span><br><span class="line">    <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：&lt;1ms</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣_56之合并区间</title>
    <url>/posts/28381.html</url>
    <content><![CDATA[<h3 id="ti-mu-miao-shu" id="题目描述">题目描述</h3>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<span id="more"></span>
<h3 id="shi-li" id="示例">示例</h3>
<p>1、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>
<p>2、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>
<h3 id="jie-ti-si-lu" id="解题思路">解题思路</h3>
<p>从题目描述，这个题就是把给定的数组，如有重叠就组合到一起，直到所有的数组都无法重叠，然后输出所有的数组。这个题，常规的做法就是将每个数组先按第一个元素排序，然后将根据数组的第二个元素拿出来和后一个数组进行比较，根据结果来进行是否合并或者保留。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">//先对二维数组中的一维数组进行排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//在判断merged中的数组的第二个元素和当前遍历到的数组的两个元素进行比较，然后再判断如何添加</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202112122059641.png" alt="image-20211212205935591" /></p>
<p>我的思路是：</p>
<p>1、创建一个长度为n的数组box，n的值为给定的二维数组的数字的最大值。</p>
<p>2、然后遍历给定的数组，根据每一个一维数组元素，将其设为遍历box的起点和终点，并且把中间值设为1，起点设为1，终点设为2。（也可以设为其他值）</p>
<p>3、遍历所有的一维数组后，此时的box数组，将相当于，把所有覆盖的区间都设定了值。</p>
<p>4、再次遍历一维数组，把box中所有已经设定的值得区间的起点和终点记录下来即可。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge1(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">		<span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    	<span class="comment">//获取数组中的最大值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>[] interval:intervals)&#123;</span><br><span class="line">			max= Math.max(max, interval[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>[] ints=<span class="keyword">new</span> <span class="title class_">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    	<span class="comment">//遍历给定数组，相当于把所有区间数在ints数组进行标记</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>[] interval:intervals)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=interval[<span class="number">0</span>];i&lt;interval[<span class="number">1</span>];i++)&#123;</span><br><span class="line">				ints[i]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ints[interval[<span class="number">1</span>]]=ints[interval[<span class="number">1</span>]]==<span class="number">1</span>?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//用两个栈来存结果的一维数组的左元素和右元素</span></span><br><span class="line">		Stack&lt;Integer&gt; left=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; right=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ints.length;i++)&#123;</span><br><span class="line">            <span class="comment">//判断特殊情况</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;ints[i]==<span class="number">2</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;ints[i]==<span class="number">1</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">1</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">1</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">2</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">2</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">				left.push(i);</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ints[i]==<span class="number">2</span>&amp;&amp;ints[i-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">				right.push(i);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==ints.length-<span class="number">1</span>&amp;&amp;ints[i]==<span class="number">2</span>)&#123;</span><br><span class="line">				right.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> leng=right.size();</span><br><span class="line">		<span class="type">int</span>[][] result=<span class="keyword">new</span> <span class="title class_">int</span>[leng][<span class="number">2</span>];</span><br><span class="line">    	<span class="comment">//处理返回结果，从左栈和右栈分别取出左元素和右元素分别作为一维数组的第一个元素和第二个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line">            <span class="comment">//pop元素可以从栈顶拿除元素，并删除栈中的元素</span></span><br><span class="line">			result[i][<span class="number">0</span>]=left.pop();</span><br><span class="line">			result[i][<span class="number">1</span>]=right.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202112122057242.png" alt="image-20211212205705100" /></p>
<p>看这两种思路的时间可能第二种的时间更短（第一种的方法主要浪费在排序上了），但第二种思路不太好想，而且特殊情况需要考虑完全，才能通过，所以大家可以根据实际情况来选择合适的方法解题。</p>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-intervals">https://leetcode-cn.com/problems/merge-intervals</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/posts/29203.html</url>
    <content><![CDATA[<h3 id="what" id="what">what</h3>
<p>哈夫曼树是一颗最优二叉树，带权路径长度最小的二叉树，经常来用来进行数据压缩。</p>
<h3 id="why" id="why">why</h3>
<h4 id="wei-shi-yao-zhe-ke-shu-shi-zui-you-de" id="为什么这棵树是最优的？">为什么这棵树是最优的？</h4>
<p>一个棵树是不是最优的，要看它是否满足构建的这棵树的带权路径长度最小。</p>
<span id="more"></span>
<p>在证明哈夫曼树是一颗最优二叉树之前，要先知道这几个概念：</p>
<ul>
<li>路径：从树中一个节点到另一个节点之间的分支构成这两个节点之间的路径。</li>
<li>路径长度：从根节点开始计数到该节点，路径上的分支数目称作路径长度。</li>
<li>权：也称为权值，指的是节点的属性数值。</li>
<li>树的带权路径长度：树中所有叶子节点的带权路径长度之和，一般用WPL表示。</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202109221714863.png" alt="avatar" /></p>
<p>如上图中，a的权值为7，路径长度为1；b的权值为5，路径长度为2。</p>
<p>树的带权路径长度WPL=7x1+5x2+2x3+4x3=35</p>
<p>知道了这些，那为什么是最优的，知道构建的哈夫曼树，你就知道为什么了。</p>
<p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p>
<ol>
<li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li>
<li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li>
<li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li>
</ol>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202109221713874.png" alt="img" /></p>
<p>在上图中（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。</p>
<p>哈夫曼树在构建的过程中，将最短的路径，巧妙的给了权值最大的，最长的路径给了权值最小的，所以可使WPL最小。</p>
<h4 id="wei-shi-yao-ke-yi-yong-lai-jin-xing-shu-ju-ya-suo-wu-sun-ya-suo" id="为什么可以用来进行数据压缩（无损压缩）？">为什么可以用来进行数据压缩（无损压缩）？</h4>
<p>压缩不外乎就是对数据的编码处理，使其占用的内存更小。</p>
<p>在数据压缩中，有一种叫做无损压缩，它其中的原理利用了哈夫曼编码，哈夫曼编码相当于哈夫曼树理论的实践。</p>
<p>哈夫曼编码，是一种非常巧妙的编码方式，而且也是可变的，依据字符出现的概率来决定字符编码长度。</p>
<p>在编码时，首先根据待编码的文本统计出每个字符出现的概率，组成初始的节点。然后每次取出概率最小的两个节点，新建一个节点，使得新建节点的左右儿子为选取的两个节点，并且其概率是两个节点概率之和，把新建的节点再放进所有节点中重新选择最小的两个节点。重复此过程直到只剩一个节点，这个就是哈夫曼树的根节点。</p>
<p>以下以字符串&quot;aaaaaabbbbccddd&quot;为例进行说明，为了方便，以字符出现的频数来代替频率（实际中通常使用的是频率，二者效果上是一样的），经过统计，可以知道每个字符出现的频数为：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>具体建树过程如下：</p>
<ol>
<li>首先节点权值为6、4、2、3，选择最小的2和3，组成一个根节点为5的组合节点。</li>
<li>当前节点权值为6、4、5，选择最小的4和5，组成一个根节点为9的组合节点。</li>
<li>当前节点权值为6、9，选择最小的6和9，组成一个根节点为15的组合节点。</li>
<li>当前节点权值为15，只有一个节点，哈夫曼树建立完成。<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202109221715998.png" alt="avatar" /></li>
</ol>
<p>要从哈夫曼树得到每个字符的编码，只要在哈夫曼树中从根节点遍历到该字符节点，每次向左走时加一个0，向右走时加一个1，最终得到的字符串即为该字符的编码字符串。</p>
<p>如从上图可以看到，a的编码为0，b的编码为10，c的编码为110，d的编码为111。</p>
<p>哈夫曼编码之所以可以这样解码，是因为它是一种前缀编码，任何一个字符的编码都不会是另一个字符编码的前缀。于是给定一个编码后的串，其解码的结果是唯一的。</p>
<p>最终经过哈夫曼编码后为：  0 0 0 0 0 0 10 10 10 10 110 110 111 111 111 一共为31位，在原始的数据中，一个字符占用3bit, 一共需要45bit</p>
<p>一串字符串，经过哈夫曼编码从45bit压缩到了31bit。因为在这个过程没有数据的丢失，所以是无损压缩。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序提现功能实现</title>
    <url>/posts/4359.html</url>
    <content><![CDATA[<h2 id="xu-qiu" id="需求">需求</h2>
<p>在微信小程序中实现一个提现功能 ，提现的钱其实来自系统中的其他功能。</p>
<p>当然这个功能，需要一个微信支付的商户号，并且账户中需要有充足的余额。</p>
<span id="more"></span>
<h2 id="qian-qi-zhun-bei" id="前期准备">前期准备</h2>
<h3 id="1-deng-lu-wei-xin-shang-hu-ping-tai-guan-wang-a-href-https-pay-weixin-qq-com-index-php-core-home-login-return-url-2-f-wei-xin-zhi-fu-zhong-guo-ling-xian-de-di-san-fang-zhi-fu-ping-tai-wei-xin-zhi-fu-ti-gong-an-quan-kuai-jie-de-zhi-fu-fang-shi-qq-com-a" id="1、登录微信商户平台官网：微信支付-中国领先的第三方支付平台-｜-微信支付提供安全快捷的支付方式-qq-com">1、登录微信商户平台官网：<a href="https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F">微信支付 - 中国领先的第三方支付平台 ｜ 微信支付提供安全快捷的支付方式 (qq.com)</a></h3>
<h3 id="2-zhao-dao-chan-pin-zhong-xin-de-qi-ye-fu-kuan-dao-ling-qian-bing-kai-tong-qi-ye-fu-kuan-dao-ling-qian-gong-neng" id="2、找到产品中心的企业付款到零钱，并开通企业付款到零钱功能">2、找到产品中心的企业付款到零钱，并开通企业付款到零钱功能</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122047375.png" alt="image-20220212204704151" /></p>
<h3 id="3-zhao-dao-app-id-zhang-hao-guan-li-tian-jia-guan-lian-app-id" id="3、找到AppID账号管理，添加关联AppID">3、找到AppID账号管理，添加关联AppID</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122049879.png" alt="image-20220212204950779" /></p>
<h3 id="4-jiang-wei-xin-shang-hu-hao-he-xiao-cheng-xu-jin-xing-bang-ding" id="4、将微信商户号和小程序进行绑定">4、将微信商户号和小程序进行绑定</h3>
<h3 id="5-shen-qing-api-zheng-shu-he-ap-iv-2-mi-yao-tuo-shan-bao-cun-hou-mian-hui-shi-yong" id="5、申请API证书和APIv2密钥，妥善保存，后面会使用">5、申请API证书和APIv2密钥，妥善保存，后面会使用</h3>
<p>注：API证书文件的后缀是.p12</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122101758.png" alt="image-20220212210121591" /></p>
<h3 id="6-huo-qu-shang-hu-hao" id="6、获取商户号">6、获取商户号</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202122106554.png" alt="image-20220212210613468" /></p>
<h2 id="dai-ma-shi-xian-spring-boot" id="代码实现（SpringBoot）">代码实现（SpringBoot）</h2>
<h3 id="1-yin-ru-xiang-guan-guan-fang-yi-lai" id="1、引入相关官方依赖">1、引入相关官方依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.wxpay<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wxpay-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-zai-yaml-wen-jian-tian-jia-pei-zhi" id="2、在yaml文件添加配置">2、在yaml文件添加配置</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">withDraw:</span><br><span class="line">	apiKey: xxxxxxxx</span><br><span class="line">     mchid: xxxxxx</span><br><span class="line">     mch_appid: xxxxxxxxx</span><br><span class="line">     <span class="comment">//此路径代表是在项目的resouce根目录</span></span><br><span class="line">     certPath: /xxxxxxxx.p12</span><br><span class="line">     count: <span class="number">10</span></span><br><span class="line">     quota: <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="3-bian-xie-pei-zhi-lei" id="3、编写配置类">3、编写配置类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithDrawConfig</span> <span class="keyword">implements</span> <span class="title class_">WXPayConfig</span> &#123;</span><br><span class="line">    <span class="comment">//从yaml注入配置</span></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mch_appid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mch_appid;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.apiKey&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String apiKey;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mchid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mchid;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.certPath&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String certPath;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getAppID</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mch_appid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMchID</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mchid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> apiKey;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> InputStream <span class="title function_">getCertStream</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//获取证书,证书建议放到resource目录下</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.getClass().getResourceAsStream(certPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHttpConnectTimeoutMs</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">8000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHttpReadTimeoutMs</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-bian-xie-ti-xian-gong-ju-lei" id="4、编写提现工具类">4、编写提现工具类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithDrawUtils</span> &#123;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mch_appid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mch_appid;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.mchid&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String mchid;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;withDraw.apiKey&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String apiKey;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WithDrawConfig withDrawConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成订单号日期时间+随机字符</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getOrderNumber</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> date.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + RandomStringUtils.randomNumeric(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">fillRequest</span><span class="params">(Map&lt;String, String&gt; reqData)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		reqData.put(<span class="string">&quot;mch_appid&quot;</span>, mch_appid);</span><br><span class="line">		reqData.put(<span class="string">&quot;mchid&quot;</span>, mchid);</span><br><span class="line">		reqData.put(<span class="string">&quot;nonce_str&quot;</span>, WXPayUtil.generateNonceStr().toUpperCase());</span><br><span class="line">		reqData.put(<span class="string">&quot;sign&quot;</span>, WXPayUtil.generateSignature(reqData, apiKey, WXPayConstants.SignType.MD5));</span><br><span class="line">		<span class="keyword">return</span> reqData;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMd5ByString</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">hexString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">MessageDigest</span> <span class="variable">mdTemp</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">			mdTemp.update(str.getBytes());</span><br><span class="line">			<span class="type">byte</span>[] hash = mdTemp.digest();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">byte</span> b : hash) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((<span class="number">0xff</span> &amp; b) &lt; <span class="number">0x10</span>) &#123;</span><br><span class="line">					hexString.append(<span class="string">&quot;0&quot;</span>).append(Integer.toHexString((<span class="number">0xFF</span> &amp; b)));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					hexString.append(Integer.toHexString(<span class="number">0xFF</span> &amp; b));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hexString.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将对象直接转换成String类型的 XML输出</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">convertToXml</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建输出流</span></span><br><span class="line">		<span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 利用jdk中自带的转换类实现</span></span><br><span class="line">			<span class="type">JAXBContext</span> <span class="variable">context</span> <span class="operator">=</span> JAXBContext.newInstance(obj.getClass());</span><br><span class="line"></span><br><span class="line">			<span class="type">Marshaller</span> <span class="variable">marshaller</span> <span class="operator">=</span> context.createMarshaller();</span><br><span class="line">			<span class="comment">// 格式化xml输出的格式</span></span><br><span class="line">			marshaller.setProperty(Marshaller.JAXB_FRAGMENT,</span><br><span class="line">					Boolean.TRUE);</span><br><span class="line">			<span class="comment">// 将对象转换成输出流形式的xml</span></span><br><span class="line">			marshaller.marshal(obj, sw);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (JAXBException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sw.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getRestInstance</span><span class="params">(String url, String data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">UTF8</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">		<span class="type">URL</span> <span class="variable">httpUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">		<span class="type">char</span>[] password = mchid.toCharArray();<span class="comment">//证书密码</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">certStream</span> <span class="operator">=</span> withDrawConfig.getCertStream();<span class="comment">//获取证书的流</span></span><br><span class="line">		<span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);</span><br><span class="line">		ks.load(certStream, password);</span><br><span class="line">		<span class="comment">// 实例化密钥库 &amp; 初始化密钥工厂</span></span><br><span class="line">		<span class="type">KeyManagerFactory</span> <span class="variable">kmf</span> <span class="operator">=</span> KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">		kmf.init(ks, password);</span><br><span class="line">		<span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">		sslContext.init(kmf.getKeyManagers(), (TrustManager[]) <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">		HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());</span><br><span class="line">		<span class="type">HttpURLConnection</span> <span class="variable">httpURLConnection</span> <span class="operator">=</span> (HttpURLConnection) httpUrl.openConnection();</span><br><span class="line">		httpURLConnection.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">		httpURLConnection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">		httpURLConnection.setConnectTimeout(withDrawConfig.getHttpConnectTimeoutMs());</span><br><span class="line">		httpURLConnection.setReadTimeout(withDrawConfig.getHttpReadTimeoutMs());</span><br><span class="line">		httpURLConnection.connect();</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> httpURLConnection.getOutputStream();</span><br><span class="line">		outputStream.write(data.getBytes(UTF8));</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> httpURLConnection.getInputStream();</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, UTF8));</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		String line;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">			stringBuffer.append(line);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			bufferedReader.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			outputStream.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (certStream != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				certStream.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-ti-xian-de-ye-wu-shi-xian" id="5、提现的业务实现">5、提现的业务实现</h3>
<p>官方接口文档：<a href="https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2">【微信支付】付款开发者文档 (qq.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始提现，生成订单号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">orderNumber</span> <span class="operator">=</span> withDrawUtils.getOrderNumber();</span><br><span class="line"><span class="comment">//自定义的将提现所需要的参数封装的实体类</span></span><br><span class="line"><span class="type">WithDrawDTO</span> <span class="variable">withDrawDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithDrawDTO</span>();</span><br><span class="line">withDrawDTO.setPartner_trade_no(orderNumber);</span><br><span class="line">withDrawDTO.setDesc(<span class="string">&quot;xxxxx&quot;</span>);</span><br><span class="line">withDrawDTO.setAmount(appletWithDrawDTO.getAmount());</span><br><span class="line"><span class="comment">//此参数代表，开启真实姓名校验，也可以关闭，详看官方文档的参数说明</span></span><br><span class="line">withDrawDTO.setCheck_name(<span class="string">&quot;FORCE_CHECK&quot;</span>);</span><br><span class="line">withDrawDTO.setRe_user_name(appletWithDrawDTO.getName());</span><br><span class="line"><span class="comment">//微信小程序用户的openid</span></span><br><span class="line">withDrawDTO.setOpenid(wxUser.getOpenid());</span><br><span class="line">Map&lt;String, String&gt; params = JSON.parseObject(JSON.toJSONString(withDrawDTO), <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">params = withDrawUtils.fillRequest(params);</span><br><span class="line">withDrawDTO.setNonce_str(params.get(<span class="string">&quot;nonce_str&quot;</span>));</span><br><span class="line">withDrawDTO.setMchid(params.get(<span class="string">&quot;mchid&quot;</span>));</span><br><span class="line">withDrawDTO.setMch_appid(params.get(<span class="string">&quot;mch_appid&quot;</span>));</span><br><span class="line">withDrawDTO.setSign(params.get(<span class="string">&quot;sign&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">post</span> <span class="operator">=</span> withDrawUtils.getRestInstance(url, withDrawUtils.convertToXml(withDrawDTO));</span><br><span class="line">Map&lt;String, String&gt; result = WXPayUtil.xmlToMap(post);</span><br><span class="line"><span class="comment">//result为调用接口之后的返回参数，可以根据返回参数判断是否成功</span></span><br><span class="line"></span><br><span class="line">WithDrawEnum resultEnum;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;SUCCESS&quot;</span>.equals(result.get(<span class="string">&quot;result_code&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">//提现成功</span></span><br><span class="line">    resultEnum = WithDrawEnum.fromText(<span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> resultEnum;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//提现失败</span></span><br><span class="line">    resultEnum = WithDrawEnum.fromText(result.get(<span class="string">&quot;err_code&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(resultEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-ti-xian-fan-hui-cuo-wu-dai-ma-de-mei-ju-lei" id="6、提现返回错误代码的枚举类">6、提现返回错误代码的枚举类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">WithDrawEnum</span> &#123;</span><br><span class="line">	SUCCESS(<span class="number">0</span>, <span class="string">&quot;提现成功&quot;</span>),</span><br><span class="line">	FAIL(<span class="number">400</span>, <span class="string">&quot;提现失败，余额小于提现金额&quot;</span>),</span><br><span class="line">	HANDLE_FRE(<span class="number">5000</span>, <span class="string">&quot;操作太频繁&quot;</span>),</span><br><span class="line">	NO_AUTH(<span class="number">5001</span>, <span class="string">&quot;没有该接口权限&quot;</span>),</span><br><span class="line">	AMOUNT_LIMIT(<span class="number">5002</span>, <span class="string">&quot;金额超限&quot;</span>),</span><br><span class="line">	PARAM_ERROR(<span class="number">5003</span>, <span class="string">&quot;参数错误&quot;</span>),</span><br><span class="line">	OPENID_ERROR(<span class="number">5004</span>, <span class="string">&quot;Openid错误&quot;</span>),</span><br><span class="line">	SEND_FAILED(<span class="number">5005</span>, <span class="string">&quot;付款错误&quot;</span>),</span><br><span class="line">	NOTENOUGH(<span class="number">5006</span>, <span class="string">&quot;余额不足&quot;</span>),</span><br><span class="line">	SYSTEMERROR(<span class="number">5007</span>, <span class="string">&quot;系统繁忙，请稍后再试。&quot;</span>),</span><br><span class="line">	NAME_MISMATCH(<span class="number">5008</span>, <span class="string">&quot;姓名校验出错&quot;</span>),</span><br><span class="line">	SIGN_ERROR(<span class="number">5009</span>, <span class="string">&quot;签名错误&quot;</span>),</span><br><span class="line">	XML_ERROR(<span class="number">5010</span>, <span class="string">&quot;发送内容出错&quot;</span>),</span><br><span class="line">	FATAL_ERROR(<span class="number">5011</span>, <span class="string">&quot;两次发送参数不一致&quot;</span>),</span><br><span class="line">	FREQ_LIMIT(<span class="number">5012</span>, <span class="string">&quot;超过频率限制，请稍后再试。&quot;</span>),</span><br><span class="line">	MONEY_LIMIT(<span class="number">5013</span>, <span class="string">&quot;已经达到今日付款总额上限/已达到付款给此用户额度上限&quot;</span>),</span><br><span class="line">	CA_ERROR(<span class="number">5014</span>, <span class="string">&quot;商户证书校验出错&quot;</span>),</span><br><span class="line">	V2_ACCOUNT_SIMPLE_BAN(<span class="number">5015</span>, <span class="string">&quot;无法给未实名用户付款&quot;</span>),</span><br><span class="line">	PARAM_IS_NOT_UTF8(<span class="number">5016</span>, <span class="string">&quot;发送参数中包含不规范字符&quot;</span>),</span><br><span class="line">	SENDNUM_LIMIT(<span class="number">5017</span>, <span class="string">&quot;该用户今日付款次数超过限制, 如有需要请进入【微信支付商户平台-产品中心-付款到零钱-产品设置】进行修改&quot;</span>),</span><br><span class="line">	RECV_ACCOUNT_NOT_ALLOWED(<span class="number">5018</span>, <span class="string">&quot;收款账户不在收款账户列表&quot;</span>),</span><br><span class="line">	PAY_CHANNEL_NOT_ALLOWED(<span class="number">5019</span>, <span class="string">&quot;本商户号未配置此功能&quot;</span>),</span><br><span class="line">	SEND_MONEY_LIMIT(<span class="number">5020</span>, <span class="string">&quot;已达到今日商户付款额度上限&quot;</span>),</span><br><span class="line">	RECEIVED_MONEY_LIMIT(<span class="number">5021</span>, <span class="string">&quot;已达到今日付款给此用户额度上限&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> WithDrawEnum <span class="title function_">fromText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (text != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (WithDrawEnum b : WithDrawEnum.values()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (text.equalsIgnoreCase(b.name())) &#123;</span><br><span class="line">					<span class="keyword">return</span> b;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zui-hou" id="最后">最后</h2>
<p>微信相关接口的调用，主要还是要耐心看文档的说明，才能实现业务需求。</p>
]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>企业付款到零钱</tag>
      </tags>
  </entry>
  <entry>
    <title>微信扫码登录实现</title>
    <url>/posts/18301.html</url>
    <content><![CDATA[<h2 id="xu-qiu" id="需求-2">需求</h2>
<p>使用微信扫码登录的授权方式登录系统</p>
<span id="more"></span>
<h2 id="shi-xian" id="实现">实现</h2>
<p>此扫码登陆过程中使用了，微信开放平台（需支付300开通开发者认证）的网站应用实现的。</p>
<p>官方文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</a></p>
<h3 id="liu-cheng" id="流程：">流程：</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202202052041625.png" alt="image-20220205204119502" /></p>
<p>大概就是：前端调接口获取后端生成的state（可以用验证登录授权的有效性）——&gt;用户扫码后确认授权——&gt;前端开始调用微信开放平台的接口之后回调服务端接口——&gt;回调时传入了两个参数，code和state——&gt;根据code，appid和appSecret调用接口获取access_token——根据access_token获取微信用户的个人信息</p>
<h3 id="dai-ma" id="代码：">代码：</h3>
<h4 id="qian-duan-vue" id="前端vue：">前端vue：</h4>
<h5 id="an-zhuang-yi-ge-cha-jian" id="安装一个插件：">安装一个插件：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-wxlogin --save-dev</span><br></pre></td></tr></table></figure>
<h5 id="yin-ru-zu-jian" id="引入组件：">引入组件：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;wxlogin</span><br><span class="line">         appid=&quot;xxxxxx&quot;</span><br><span class="line">         :scope=&quot;&#x27;snsapi_login&#x27;&quot;</span><br><span class="line">         theme=&quot;black&quot;</span><br><span class="line">         redirect_uri=&quot;redirectUrl&quot;</span><br><span class="line">         :state=&quot;xxxxxx&quot;</span><br><span class="line">         :self_redirect=&quot;&#x27;true&#x27;&quot;</span><br><span class="line">         rel=&quot;external nofollow&quot;</span><br><span class="line">         /&gt;</span><br></pre></td></tr></table></figure>
<p>注：重定向地址需要使用urlEncode对链接进行处理</p>
<h4 id="hou-duan-spring-boot" id="后端SpringBoot：">后端SpringBoot：</h4>
<h5 id="hou-duan-sheng-cheng-state-jie-kou" id="后端生成state接口">后端生成state接口</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;企业端：获取扫码登录的state&quot;, notes = &quot; \n author：ZhuGuangLiang&quot;)</span></span><br><span class="line"><span class="meta">@AnonymousGetMapping(&quot;/wx/qrcode&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Object&gt; <span class="title function_">getQrCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//生成票据</span></span><br><span class="line">    String state= IdUtil.simpleUUID();</span><br><span class="line">    <span class="comment">//可以将state参数作为存放在redis中的授权用户信息key键</span></span><br><span class="line">    redisUtils.set(state, JSON.toJSON(<span class="keyword">new</span> <span class="title class_">CompanyWxDTO</span>()), <span class="number">5</span> * <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.success(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hui-diao-jie-kou-bing-xi-dai-state-he-code-can-shu" id="回调接口，并携带state和code参数">回调接口，并携带state和code参数</h5>
<p>注：回调接口，尽量不要抛出异常，异常可以在登录接口抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;企业端：微信用户授权后，回调地址&quot;, notes = &quot; \n author：ZhuGuangLiang&quot;)</span></span><br><span class="line"><span class="meta">@AnonymousGetMapping(&quot;/wx/callback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(String code, String state)</span> &#123;</span><br><span class="line">    companyAuthService.callback(code, state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法中所有第三方接口都可在官方文档中找到</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(String code, String state)</span> &#123;</span><br><span class="line">    <span class="comment">//authurl获取access_token的接口，可以看官方文档中的第二步</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">resultAuthUrl</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(authUrl, appid, secret, code)));</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultAuthUrl.containsKey(<span class="string">&quot;errcode&quot;</span>)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;授权失败&quot;</span>);</span><br><span class="line">        isSuccess = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//			throw new BadRequestException(ResultEnum.USER_NO_AUTH);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> resultAuthUrl.getString(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> resultAuthUrl.getString(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> resultAuthUrl.getString(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">    <span class="comment">//根据code获取access_toke</span></span><br><span class="line">    LambdaQueryWrapper&lt;SpiritCompanyUser&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(SpiritCompanyUser::getOpenid, openid);</span><br><span class="line">    <span class="type">CompanyWxDTO</span> <span class="variable">companyWxDTO</span> <span class="operator">=</span> loginUtils.noExceptinCheckCompanyUser(queryWrapper);</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> companyWxDTO.getType();</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">        <span class="comment">//登录失败，此时我使用type类型去记录每一种异常</span></span><br><span class="line">        companyWxDTO.setType(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span> &amp;&amp; isSuccess) &#123;</span><br><span class="line">        <span class="comment">//校验授权凭证</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resultCheckToken</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(checkTokenUrl, accessToken, openid)));</span><br><span class="line">        <span class="keyword">if</span> (resultCheckToken.getInteger(<span class="string">&quot;errcode&quot;</span>) == <span class="number">40003</span>) &#123;</span><br><span class="line">            <span class="comment">//刷新token，防止出现token失效</span></span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">resultRefreshToken</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(refreshTokenUrl, appid, refreshToken)));</span><br><span class="line">            accessToken = resultRefreshToken.getString(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resultUserInfoUrl</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.get(String.format(userInfoUrl, accessToken, openid)));</span><br><span class="line">        log.info(<span class="string">&quot;resultUserInfoUrl:&quot;</span> + resultUserInfoUrl.toString());</span><br><span class="line">        <span class="keyword">if</span> (resultUserInfoUrl.containsKey(<span class="string">&quot;errcode&quot;</span>)) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取用户信息失败&quot;</span>);</span><br><span class="line">            <span class="comment">//同上</span></span><br><span class="line">            companyWxDTO.setType(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        companyWxDTO.setAvatarUrl(resultUserInfoUrl.getString(<span class="string">&quot;headimgurl&quot;</span>));</span><br><span class="line">        companyWxDTO.setNickName(resultUserInfoUrl.getString(<span class="string">&quot;nickname&quot;</span>));</span><br><span class="line">        companyWxDTO.setOpenid(openid);</span><br><span class="line">        companyWxDTO.setUnionid(resultUserInfoUrl.getString(<span class="string">&quot;unionid&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;微信用户授权成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    companyWxDTO.setTicket(state);</span><br><span class="line">    redisUtils.set(state, JSON.toJSON(companyWxDTO), <span class="number">5</span> * <span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>扫码登录</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的接口监控及邮件提醒实现</title>
    <url>/posts/11529.html</url>
    <content><![CDATA[<h3 id="qian-yan" id="前言-2">前言</h3>
<p>最近因为疫情，不得不在家办公，而且也赶上了项目处于内测阶段，测试期间如果有问题，不能及时把问题复现出来。于是我在网上搜索有没有一些工具能对接口进行一个实时的监控，出现问题，立马通知相关人员。项目虽然有日志信息，但是因为项目是在集群中部署，日志信息，需要进入服务器的控制台中查看，比较麻烦。</p>
<p>忙活了一天，装了不少用来测试接口的框架，他们在介绍的时候，说的是对接口监控，其实是在不断的调用接口，来达到监控的效果，而且用的时候，需要准备很多工作，创建项目，创建测试用例等。</p>
<p>就在我没有思路的时候，看到一篇博客，讲的是，接口监控的原理都是在异常处理中进行的。</p>
<span id="more"></span>
<h3 id="shi-xian" id="实现-2">实现</h3>
<p>注解+异常信息的处理+发送邮件</p>
<h4 id="zhu-jie" id="注解">注解</h4>
<p>该注解只是为了获取接口的创建者或者维护者的邮箱</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> Notice &#123;</span><br><span class="line">	<span class="selector-tag">String</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：创建注解之后，只需要在接口方法上添加@Notice即可，里面的内容为邮箱</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ApiOperation</span>(value = <span class="string">&quot;获取上传凭证&quot;</span>, notes = <span class="string">&quot; \n author：ZhuGuangLiang&quot;</span>)</span><br><span class="line">	<span class="variable">@AnonymousGetMapping</span>(<span class="string">&quot;/upload&quot;</span>)</span><br><span class="line">	<span class="variable">@Notice</span>(<span class="string">&quot;786945363@qq.com&quot;</span>)</span><br><span class="line">	public Result&lt;Object&gt; upload(Integer type) &#123;</span><br><span class="line">		<span class="selector-tag">if</span> (type == null) &#123;</span><br><span class="line">			<span class="selector-tag">throw</span> <span class="selector-tag">new</span> <span class="selector-tag">BadRequestException</span>(<span class="string">&quot;文件种类为空&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-tag">return</span> <span class="selector-tag">Result</span><span class="selector-class">.success</span>(fileUtils.upload(type));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yi-chang-chu-li" id="异常处理">异常处理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> marchsoft.annotation.Notice;</span><br><span class="line"><span class="keyword">import</span> marchsoft.modules.spiritdeerpush.common.utils.email.EmailUtils;</span><br><span class="line"><span class="keyword">import</span> marchsoft.utils.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MyException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ZhuGuangLiang &lt;786945363@qq.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/01/09 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line">    <span class="comment">//自己封装的发送邮箱的工具类，可以注入自己的</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> EmailUtils emailUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管理员邮箱作为默认邮箱</span></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;notice.admin&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String adminEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//邮件提醒的开关</span></span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;notice.open&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> on;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里代表接口监控的范围，可以通过你的项目包名进行配置</span></span><br><span class="line">	<span class="meta">@Around(&quot;execution(* com.modules.xxxx.*.controller..*.*(..))&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pj)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">starttime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			log.info(&quot;---------------------API请求参数：【&quot; + getMessage(pj, null) + &quot;】&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> pj.proceed();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (on == <span class="number">1</span>) &#123;</span><br><span class="line">				concatError(starttime, getMessage(pj, e), pj);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">concatError</span><span class="params">(<span class="type">long</span> starttime, String message, ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&lt;h3&gt;接口耗时:&lt;/h3&gt;&quot;</span>);</span><br><span class="line">		stringBuilder.append(<span class="string">&quot;接口花费时间：&quot;</span>).append(System.currentTimeMillis() - starttime).append(<span class="string">&quot;ms&lt;br/&gt;&quot;</span>);</span><br><span class="line">		stringBuilder.append(message);</span><br><span class="line">		<span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) pj.getSignature();</span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">		<span class="type">Notice</span> <span class="variable">toNotice</span> <span class="operator">=</span> method.getAnnotation(Notice.class);</span><br><span class="line">		<span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> adminEmail;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtil.isNotNull(toNotice) &amp;&amp; StringUtils.isNotBlank(toNotice.value())) &#123;</span><br><span class="line">			to = toNotice.value();</span><br><span class="line">		&#125;</span><br><span class="line">		sendErrorNotice(stringBuilder.toString(), to);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">getMessage</span><span class="params">(ProceedingJoinPoint pj, Exception e)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">			log.error(e.getMessage(), e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">RequestAttributes</span> <span class="variable">ra</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">		<span class="type">ServletRequestAttributes</span> <span class="variable">sra</span> <span class="operator">=</span> (ServletRequestAttributes) ra;</span><br><span class="line">		<span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> sra.getRequest();</span><br><span class="line">		<span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) pj.getSignature();</span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">		<span class="type">ApiOperation</span> <span class="variable">toNotice</span> <span class="operator">=</span> method.getAnnotation(ApiOperation.class);</span><br><span class="line">        <span class="comment">//这一部分是为了，添加负责人，负责人信息我是从swagger的ApiOperation注解中获取的，可以根据自己项目的配置调整</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">charger</span> <span class="operator">=</span> <span class="string">&quot;无&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtil.isNotNull(toNotice) &amp;&amp; StringUtils.isNotBlank(toNotice.notes())) &#123;</span><br><span class="line">			charger = toNotice.notes().trim();</span><br><span class="line">			charger = charger.replace(<span class="string">&quot;\\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">joiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&lt;h3&gt;负责人：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(charger)</span><br><span class="line">				.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;接口地址：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(request.getRequestURI())</span><br><span class="line">				.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;类名：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(pj.getTarget().getClass().getSimpleName())</span><br><span class="line">				.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;方法：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">				.append(pj.getSignature().getName());</span><br><span class="line">		Object[] args = pj.getArgs();</span><br><span class="line">		List&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Object object : args) &#123;</span><br><span class="line">			<span class="keyword">if</span> (object <span class="keyword">instanceof</span> MultipartFile || object <span class="keyword">instanceof</span> File) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			objects.add(object);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtil.isNotNull(objects) &amp;&amp; !objects.isEmpty()) &#123;</span><br><span class="line">			joiner.append(Arrays.toString(objects.toArray()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Objects.nonNull(e)) &#123;</span><br><span class="line">			joiner.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;message：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">					.append(e.getMessage())</span><br><span class="line">					.append(<span class="string">&quot;;&lt;br/&gt;&lt;h3&gt;异常：&lt;/h3&gt;&quot;</span>)</span><br><span class="line">					.append(e.fillInStackTrace());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> joiner.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendErrorNotice</span><span class="params">(String content, String to)</span> &#123;</span><br><span class="line">		<span class="comment">//发送异常提醒邮件给接受人</span></span><br><span class="line">		emailUtils.sendException(to, content);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="fa-song-you-jian" id="发送邮件">发送邮件</h4>
<p>可以自行百度关于发送的邮件的配置，这里就不一一陈述了。</p>
<h3 id="zui-hou" id="最后-2">最后</h3>
<p>这个功能其实还是很简单，也有一定的局限性，比如没有包含具体报错的行数，只包含的方法和参数的信息，方便复现问题吧。在接口监控方面其实也有一些现成的框架，可以实现更加详细的报告，我还是个菜鸟，继续加油学习↖(<sup>ω</sup>)↗。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之循环队列</title>
    <url>/posts/33202.html</url>
    <content><![CDATA[<p>为充分利用向量空间，克服&quot;<a href="https://baike.baidu.com/item/%E5%81%87%E6%BA%A2%E5%87%BA/11050937">假溢出</a>&quot;现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。循环队列是把<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/20832734">顺序队列</a>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p>
<span id="more"></span>
<h3 id="xun-huan-dui-lie-san-chong-qing-kuang" id="循环队列三种情况">循环队列三种情况</h3>
<h4 id="1" id="1、">1、</h4>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061150819.png" alt="image-20211006115040686" /></p>
<ul>
<li>
<p>front指向头元素的前一个元素</p>
</li>
<li>
<p>rear指向队尾元素</p>
</li>
<li>
<p>对空、入队和队满情况判断：</p>
<ul>
<li>队空：front=rear</li>
<li>入队：rear=（rear+1）%maxsize，每次元素进入队列，队尾指针rear向后移动 一位。
<ul>
<li>queue【rear】=x</li>
</ul>
</li>
<li>队满：front==(rear+1)%maxsize</li>
</ul>
</li>
<li>
<p>根据rear和front计算队列长度：</p>
<ul>
<li>当rear&gt;front
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061424940.png" alt="image-20211006142409854" /></li>
<li>很容易得到队列长度为：rear-front</li>
</ul>
</li>
<li>当rear&lt;front
<ul>
<li><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061440374.png" alt="image-20211006144049313" />
<ul>
<li>因为是循环队列，rear的位置可以在front的前面，此时队列长度为：rear+1+maxsize-front-1=rear-front+maxsize
<ul>
<li>rear+ 1为其中一段的长度</li>
<li>maxsize-front-1为另一段的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2" id="2、">2、</h4>
<h4 id="img-src-https-mynotepicture-oss-cn-hangzhou-aliyuncs-com-img-202110061514889-png-alt-image-20211006151401822" id=""><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202110061514889.png" alt="image-20211006151401822" /></h4>
<ul>
<li>front指向头元素</li>
<li>rear指向队尾的后一个元素</li>
<li>队满：front=(rear+1)%maxsize</li>
<li>队列长度：(rear-front+max)%maxsize</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列之RabbitMQ学习笔记</title>
    <url>/posts/49673.html</url>
    <content><![CDATA[<h3 id="shi-yao-shi-xiao-xi-dui-lie" id="什么是消息队列">什么是消息队列</h3>
<p>消息是两个应用间传递的数据。消息队列简单的来讲是将消息在传输的过程中用来存储消息的容器。</p>
<p>在消息队列中，通常会有生产者和消费者，生产者将消息放到队列中，消费者从中取出消息。</p>
<h3 id="wei-shi-yao-yao-shi-yong-xiao-xi-dui-lie" id="为什么要使用消息队列">为什么要使用消息队列</h3>
<ul>
<li>解藕：
<ul>
<li>假如消息的接收方有多个，需要单独给每个接收方都要发送消息，如果又新增一个接收方，则需要增加新代码才能实现。为了降低这种耦合，使用MQ，发送方只需要把消息放到队列中，接受方只需要在队列中取消息，这样就避免了每次新增接收方而去增加新代码，从而实现解藕。</li>
</ul>
</li>
<li>异步：
<ul>
<li>个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</li>
</ul>
</li>
<li>削峰：
<ul>
<li>假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="rabbit-mq-jie-shao" id="RabbitMQ介绍">RabbitMQ介绍</h3>
<p>abbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p>
<p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
<p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h3 id="an-zhuang" id="安装">安装</h3>
<h4 id="1-an-zhuang-er-lang-yu-yan-pei-zhi-huan-jing-bian-liang" id="1、安装ERLang语言，配置环境变量">1、安装ERLang语言，配置环境变量</h4>
<p>ERlang<a href="https://www.erlang.org/downloads?spm=a2c6h.12873639.0.0.433733dfToixYZ">官网</a>下载window版安装包</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071152710.png" alt="img" /></p>
<p>安装中，一直点next，完成后配置环境变量</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071153051.png" alt="img" /></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071154226.png" alt="img" /></p>
<p>完成后，打开cmd,输入验证是否成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">erl -version</span><br></pre></td></tr></table></figure>
<h4 id="2-an-zhuang-rabbit-mq-fu-wu-duan" id="2、安装RabbitMQ服务端">2、安装RabbitMQ服务端</h4>
<p>在RabbitMQ的<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3?spm=a2c6h.12873639.0.0.433733dfvzkoi7&amp;file=v3.7.3">GitHub项目</a>中，下载window版本的服务端安装包</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071157091.png" alt="img" /></p>
<p>安装后，找到安装目录：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071158360.png" alt="img" /></p>
<p>在此目录打开cmd命令，输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装管理页面插件</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>在此目录下双击rabbitmq-server.bat启动脚本，然后打开服务管理可以看到RabbitMQ正在运行：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071200331.png" alt="img" /></p>
<p>最后在浏览器输入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入客户端</span></span><br><span class="line">http:<span class="comment">//localhost:15672</span></span><br><span class="line">账号密码默认是：guest/guest</span><br></pre></td></tr></table></figure>
<h3 id="rabbit-mq-zhong-de-zu-cheng-bu-fen" id="RabbitMQ中的组成部分">RabbitMQ中的组成部分</h3>
<ul>
<li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。</li>
<li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li>
<li>Queue：消息队列，存储消息的队列。</li>
<li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li>
<li>Consumer：消息消费者。消费队列中存储的消息。</li>
</ul>
<p>这些部分协同工作图：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071208178.png" alt="img" /></p>
<ul>
<li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li>
<li>生产者声明交换机类型、名称、是否持久化等。</li>
<li>生产者发送消息，并指定消息是否持久化等属性和routing key。</li>
<li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li>
<li>消费者监听接收到消息之后开始业务处理。</li>
</ul>
<h3 id="you-que-dian" id="优缺点">优缺点</h3>
<h4 id="you-dian" id="优点">优点</h4>
<ul>
<li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li>
<li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>
<li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li>
<li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li>
<li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li>
</ul>
<h4 id="que-dian" id="缺点">缺点</h4>
<ul>
<li>系统可用性降低：你想呀，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低</li>
<li>系统复杂性增加：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，刺痛复杂性增大。</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统学习笔记</title>
    <url>/posts/39126.html</url>
    <content><![CDATA[<p>计算机操作系统学习笔记</p>
<span id="more"></span>
<h2 id="yi-ji-chu" id="一、基础">一、基础</h2>
<h3 id="1-wu-li-nei-cun-he-xu-ni-nei-cun" id="1、物理内存和虚拟内存">1、物理内存和虚拟内存</h3>
<h4 id="1-1-wu-li-nei-cun" id="1-1、物理内存">1.1、物理内存</h4>
<h5 id="1-1-1-ying-yong-zhong-de-miao-shu" id="1-1-1、应用中的描述">1.1.1、应用中的描述</h5>
<p>物理内存是计算机上的最重要的资源之一。Windows的内存管理器负责给活动进程、设备驱动，和操作系统自己分配内存。因为绝大多数系统所能访问的数据和代码远比物理内存多，所以从本质上来说，物理内存是代码和数据在其中运行的窗口。所以内存容量对性能有影响，因为如果进程或者操作系统所需的代码或者数据不存在，内存管理器就需要从磁盘中读取这些内容。</p>
<h5 id="1-1-2-cpu-zhong-de-miao-shu" id="1-1-2、CPU中的描述">1.1.2、CPU中的描述</h5>
<p>物理内存，CPU的地址线可以直接进行寻址的内存空间大小。比如8086只有20根地址线，那它的寻址空间就是1MB。我们就说8086能支持1MB的物理内存。即使我们安装了128M的内存条在板子上，我们也只能说8086拥有1MB的物理内存空间。同理32位的386以上CPU，就可以支持最大4GB的物理内存空间了。</p>
<h4 id="1-2-xu-ni-nei-cun" id="1-2虚拟内存">1.2虚拟内存</h4>
<p>虚拟内存是对主存和磁盘 I/O 设备的抽象表示，是操作系统为每个进程分配的连续的虚拟地址空间。<br />
内存和外存之和为虚拟内存<br />
<img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220620093116.png" alt="" /></p>
<h4 id="1-3-qu-bie" id="1-3区别">1.3区别</h4>
<p><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a>就与物理内存相反，是指根据系统需要从<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98">硬盘</a><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F">虚拟</a>地匀出来的内存空间，是一种<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">计算机系统</a><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a>技术，属于<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>程序，而物理内存为<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6">硬件</a>。因为有时候当你处理大的程序时候<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98">系统内存</a>不够用，此时就会把<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98">硬盘</a>当内存来使用，来<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%8D%A2">交换</a><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>做<a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98">缓存</a>区，不过物理内存的处理速度是<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a>的30倍以上。</p>
<h3 id="2-huan-cun-io-he-zhi-jie-io" id="2、缓存IO和直接IO">2、缓存IO和直接IO</h3>
<p>I/O：输入/输出(Input/Output)，分为IO设备和IO接口两个部分。在POSIX兼容的系统上，例如Linux系统，I/O操作可以有多种方式，比如DIO(Direct I/O)，AIO(Asynchronous I/O， 异步I/O)，Memory-Mapped I/O(内存映射I/O)等，不同的I/O方式有不同的实现方式和性能，在不同的应用中可以按情况选择不同的I/O方式。<br />
<img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/202206211111129.png" alt="" /></p>
<h4 id="2-1-huan-cun-io" id="2-1、缓存io">2.1、缓存io</h4>
<p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制（DMA copy）到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。</p>
<blockquote>
<p>DMA:IO设备和内存之间的数据传输方式。DMA（直接内存访问，Direct Memory Access），不经过Cpu而直接进行磁盘和内存的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传输，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样在很大程度上降低了CPU占用率，大大节省了系统资源。</p>
</blockquote>
<p>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</p>
<p>写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</p>
<p><strong>缓存I/O的优点</strong>：首先，在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；其次，可以减少读盘的次数，从而提高性能。</p>
<p><strong>缓存I/O的缺点</strong>：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<h4 id="2-2-zhi-jie-io" id="2-2-、直接io">2.2 、直接io</h4>
<p>直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区，自己管理IO缓存区，这样做的目的是减少一次内核缓冲区到用户程序缓存的数据复制。</p>
<p>引入内核缓冲区的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在内核缓冲区中，那么就不需要再次访问磁盘。而当进程需要向文件写入数据是，实际上只是写到了内核缓冲区便告诉进程已经写成功，而真正写入磁盘是通过一定的策略进行延时的。</p>
<p>然而，对于一些较复杂的应用，比如数据库服务器，他们为了充分提高性能。希望绕过内核缓冲区，由自己在用户态空间时间并管理IO缓冲区，包括缓存机制和写延迟机制等，以支持独特的查询机制，比如数据库可以根据加合理的策略来提高查询缓存命中率。另一方面，绕过内核缓冲区也可以减少系统内存的开销，因为内核缓冲区本身就在使用系统内存。</p>
<p><strong>直接IO的缺点</strong>：如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，这种直接加载会非常缓存。通常直接IO与异步IO结合使用，会得到比较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）。<br />
<img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/202206211114867.png" alt="" /></p>
<h3 id="3-jin-cheng-diao-du-suan-fa" id="3、进程调度算法">3、进程调度算法</h3>
<p>操作系统中常用的进程调度算法，主要有三种优先调度算法、高优先权先调度算法和基于时间片的轮转调度算法：</p>
<h4 id="3-1-you-xian-diao-du-suan-fa" id="3-1、优先调度算法">3.1、优先调度算法</h4>
<ul>
<li>先来先服务调度算法（FCFS）<br />
每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存运行，分配执行资源。</li>
<li>短作业（进程）优先调度算法（SFJ）<br />
每次都是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们放入内存运行，分配执行资源。<br />
TIP:采用优先调度算法时，线程一旦获得CPU执行权限，将一直执行到完成，或发生某事件而被阻塞放弃处理时才会再重新调度<br />
缺点：优先调度算法未考虑到紧迫型作业。</li>
</ul>
<h4 id="3-2-gao-you-xian-quan-you-xian-diao-du-suan-fa" id="3-2、高优先权优先调度算法">3.2、高优先权优先调度算法</h4>
<p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法，当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</p>
<ul>
<li>非抢占式优先权算法
<ul>
<li>特点：系统一旦把处理机分配给了就绪队列中优先权最高的进城后，该进程便会一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。</li>
<li>适用系统：这种调度算法主要用于批处理中，也可用于某些对实时性要求不严的实时系统中。</li>
</ul>
</li>
<li>抢占式优先权调度算法
<ul>
<li>特点：当在系统执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序立即停止当前进程（原优先权最高的进程）的执行，重新将处理机分配给信道的优先权最高的进程。</li>
<li>适用系统：显然，这种抢占式的优先权调度算法能更好的满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
</ul>
<h4 id="3-3-gao-xiang-ying-bi-you-xian-diao-du-suan-fa" id="3-3、高响应比优先调度算法">3.3、高响应比优先调度算法</h4>
<p>原理：在短作业优先算法的基础上，为每个作业引入优先权，并使作业的优先级随着等待事件的增加而增加，则长作业在等待一定时间后，必然有机会分配到处理机。<br />
特点：</p>
<ul>
<li>如果作业的等待时间相同，则要求服务的时间越短，其优先权越高，因而该算法有利于短作业；</li>
<li>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间越长，其优先权越高，因而它实现的是先来先服务；</li>
<li>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升的很高，从而也可获得处理机。<br />
优点：该算法即照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。<br />
缺点：在利用该算法时，每当要进行调度之前，都须先做响应比计算，这会增加系统开销。</li>
</ul>
<h4 id="3-4-ji-yu-shi-jian-pian-de-lun-zhuan-diao-du-suan-fa" id="3-4、基于时间片的轮转调度算法">3.4、基于时间片的轮转调度算法</h4>
<p>实现：</p>
<ul>
<li>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片；</li>
<li>当执行的时间片用完时；由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；</li>
<li>然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给顶的时间内均能获得一时间片的处理机执行时间。</li>
</ul>
<h4 id="3-5-duo-ji-fan-kui-dui-lie-diao-du-suan-fa" id="3-5、多级反馈队列调度算法">3.5、多级反馈队列调度算法</h4>
<p>实现：</p>
<ul>
<li>设置多个就绪队列，并未各个队列赋予不同的优先级与不同时间片。第一个队列的优先级最高，第二个队列次之，其余个队列的优先级逐个降低。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。例如，第二个队列的时间片要比第一个队列的时间片长一倍。。，第i+1个队列的时间片要比第i个队列的时间片长1倍；</li>
<li>当一个新进程进入内存后，首先将它放到第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统，如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片仍未完成，再依次将它放入第三队列。。。如此下去，当一个长作业（进程）从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行；</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行。仅当第1-（i-1）队列均为空，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列中，则此时新进程将抢占正在运行进程的处理及，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理及分配给新的高优先权进程。TIP：在多级反馈队列调度算法中，如果规定了第一队列的时间片略大于大多数人机交互所需之处理时间时，便能够较好的满足个类型用户的需要。</li>
</ul>
<h3 id="4-xian-cheng-he-jin-cheng" id="4、线程和进程">4、线程和进程</h3>
<p>参考：<a href="https://blog.csdn.net/ThinkWon/article/details/102021274">进程和线程的区别(超详细)_ThinkWon的博客-CSDN博客_进程和线程的区别</a></p>
<h3 id="5-jin-cheng-he-xian-cheng-de-diao-du" id="5、进程和线程的调度">5、进程和线程的调度</h3>
<p>参考：<a href="https://blog.csdn.net/weixin_45146520/article/details/114478030">进程和线程的调度_Ryan-S的博客-CSDN博客_进程和线程的调度</a></p>
<h3 id="6-xian-cheng-de-chuang-jian-he-jie-shu" id="6、线程的创建和结束">6、线程的创建和结束</h3>
<p>参考：<a href="https://blog.csdn.net/matafeiyanll/article/details/110742792">(1条消息) 第七章_线程 : 线程的概念、创建与终止_马踏飞燕&amp;lin_li的博客-CSDN博客</a></p>
<h3 id="7-xian-cheng-zhuang-tai" id="7、线程状态">7、线程状态</h3>
<p>参考：<a href="https://blog.csdn.net/pange1991/article/details/53860651">(1条消息) Java线程的6种状态及切换(透彻讲解)_潘建南的博客-CSDN博客_线程状态</a></p>
<h3 id="8-xian-cheng-jian-tong-xin-yu-xian-cheng-tong-bu-ji-zhi" id="8、线程间通信与线程同步机制">8、线程间通信与线程同步机制</h3>
<p>参考：<br />
<a href="https://zhuanlan.zhihu.com/p/430069448">面试官：说说进程间通信和线程间通信的几种方式及区别 - 知乎 (zhihu.com)</a><br />
<a href="https://www.jianshu.com/p/9218692cb209">线程间的通信、同步方式与进程间通信方式 - 简书 (jianshu.com)</a></p>
<h3 id="9-hu-chi-suo-he-xin-hao-liang" id="9、互斥锁和信号量">9、互斥锁和信号量</h3>
<p>参考：<a href="http://t.csdn.cn/IZMtu">详解信号量和互斥锁之间的区别和联系</a></p>
<h3 id="10-xian-cheng-chi" id="10、线程池">10、线程池</h3>
<p>参考：<a href="http://t.csdn.cn/NrrjG">java线程池 面试题</a></p>
<h3 id="11-xiao-fei-zhe-he-sheng-chan-zhe" id="11、消费者和生产者">11、消费者和生产者</h3>
<p>参考：<a href="http://t.csdn.cn/vW5QO">http://t.csdn.cn/vW5QO</a></p>
<h3 id="12-si-suo" id="12、死锁">12、死锁</h3>
<p>参考：<a href="https://www.jianshu.com/p/44125bb12ebf">死锁是什么？如何避免死锁？ - 简书 (jianshu.com)</a></p>
<h3 id="13-bing-fa-he-bing-xing" id="13、并发和并行">13、并发和并行</h3>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1424249">面试必考的：并发和并行有什么区别？ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="er-mian-shi-ti" id="二、面试题">二、面试题</h2>
<h3 id="1-shi-yao-shi-xian-cheng" id="1、什么是纤程？">1、什么是纤程？</h3>
<ul>
<li>定义<br />
纤程是 fiber , 是由操作系统实现的一种轻量化线程上的一个执行结构。 通常是多个fiber共享一个固定的线程, 然后他们通过互相主动切换到其他fiber来交出线程的执行权.。各个子任务之间的关系非常强。</li>
</ul>
<blockquote>
<p>在Windows2000/XP中，纤程(fiber)相当于用户级别的线程或轻进程.纤程由Win32库函数支持,对核心是不可见的.纤程可以通过SwitchToFiber切换至另一合作纤程,以实现合作纤程之间的协同。</p>
</blockquote>
<ul>
<li>优缺点
<ul>
<li>优点：消耗小，切换快，一个进程可以创建成千上万个纤程。小任务顺序编程很符合人的思维方式, 规避纯异步编程中状态机的复杂性. 使得使用纤程写的程序将更加的直观, 逻辑描述方便, 简化编程.纤程用于化异步为同步, 你可以进行一个异步操作以后就切换纤程，等到异步操作完成以后在切换回来，这样，在逻辑上相关的代码就可以写到一个函数里面，而不用人为的分到多个回调函数中。没有了线程所谓的安全问题, 避免锁机制。</li>
<li>缺点：纤程一般只支持所有的纤程函数在一个线程里面跑. 无法充分利用多核CPU, 除非把所有的IO和计算操作都剥离成单独的线程。关于跨平台的纤程的实现和使用资料较少。</li>
</ul>
</li>
<li>参考：
<ul>
<li><a href="https://blog.csdn.net/wwj17647590781/article/details/119062520">JVM之线程实现的不同方式、以及协程、纤程（基于《深入理解Java虚拟机》之第12章Java内存模型与线程）（下）_slow is fast.的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/King_weng/article/details/113393405">纤程_king_weng的博客-CSDN博客</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/posts/51189.html</url>
    <content><![CDATA[<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。<br />
计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p>
<span id="more"></span>
<h2 id="yi-ji-chu-zhi-shi" id="一、基础知识">一、基础知识</h2>
<h3 id="1-ipv-4-di-zhi" id="1、IPV4地址">1、IPV4地址</h3>
<h4 id="1-1-v-4-xie-yi" id="1-1、v4协议">1.1、v4协议</h4>
<p>目前的全球因特网所采用的协议族是TCP/IP协议族。IP是TCP/IP协议族中网络层的协议，是TCP/IP协议族的核心协议。目前IP协议的版本号是4(简称为IPv4)。</p>
<h4 id="1-2-v-4-di-zhi" id="1-2、v4地址">1.2、v4地址</h4>
<ul>
<li>在TCP/IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</li>
<li>IPv4地址就是给因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</li>
<li>IP地址由因特网名字和数字分配机构ICANN进行分配。
<ul>
<li>我国用户可向亚太网络信息中心APNIC申请ip地址，需要缴费。</li>
<li>2011年2月3日，互联网号码分配管理局IANA(由ICANN行使职能)宣布，IPv4地址已经分配完毕。</li>
<li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6 。</li>
</ul>
</li>
<li>IPv4地址的编址方法经历了如下三个历史阶段：
<ul>
<li>1981年分类编址</li>
<li>1985年划分子网</li>
<li>1993年无分类编址</li>
</ul>
</li>
<li>表示方法：
<ul>
<li>IPv4的地址位数为32位，也就是说最多有2的32次方的IPv4地址可以联到Internet上。</li>
<li>通常，IPv4地址以点分十进制表示。IPV4 就是有4 段数字，每一段由0~255 数字组成。每个部分代表一组构成8位地址方案的8位地址。<br />
<img data-src="https://img-blog.csdnimg.cn/90b0d6877b234419ab94669086681089.png" alt="image.png" /><br />
<img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531153426.png" alt="" /></li>
</ul>
</li>
</ul>
<h4 id="1-3-fen-lei-bian-zhi-de-i-pv-4-di-zhi" id="1-3、分类编址的IPv4地址">1.3、分类编址的IPv4地址</h4>
<ul>
<li>A类网络，最高位固定为0
<ul>
<li>8位网络号，24位主机号</li>
<li>最小网络号0，保留不指派</li>
<li>第一个可指派的网络号为00000001，网络地址为1.0.0.0</li>
<li>最大网络号二进制011111111（127），作为本地环回测试地址，不指派。最小还回测试地址：127.0.0.1，最大的本地环回测试地址为127.255.255.254</li>
<li>最后一个可指派的网络号为126，网络地址为126.0.0.0</li>
<li>可指派的网络数量为2^(8-1)-2=126（减2的原因是除去最小网络号0和最大网络号127）</li>
<li>每个网络中可分配的IP地址数量为2^24-2=16777214（减2的原因是除去主机号为全0的网络地址和全1的广播地址）</li>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531155340.png" alt="" /></li>
</ul>
</li>
<li>B类网络，最高位固定为10
<ul>
<li>最小网络号也是第一个可指派的网络号128.0网络地址为128.0.0.0</li>
<li>最大网络号也是最后一个可指派的网络号191.255网络地址为191.255.0.0</li>
<li>可指派的网络数量为2^(16-2)=16384</li>
<li>每个网络中可分配的IP地址数量为2^16-2=65534（减2的原因是除去主机号为全0的网络地址和全1的广播地址）</li>
<li>在有些资料中指出128.0是保留网络号，B类第一个可指派的网络好为128.1。但根据2002年9月发表的RFC3330文档，128.0网络号已经可以分配了。</li>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531160550.png" alt="" /></li>
</ul>
</li>
<li>C类网络，最高位固定为110
<ul>
<li>最小网络号也是第一个可指派的网络号192.0.0，网络地址为192.0.0.0</li>
<li>最大网络号也是最后一个可指派的网络号223.255.255网络地址为223.255.255.0</li>
<li>可指派的网络数量为2^(24-3)=2097152</li>
<li>每个网络中可分配的IP地址数量为2^8-2=254（减2的原因是除去主机号为全0的网络地址和全1的广播地址）</li>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531163924.png" alt="" /></li>
</ul>
</li>
</ul>
<h4 id="1-4-hua-fen-zi-wang-de-i-pv-4-di-zhi" id="1-4、划分子网的IPv4地址">1.4、划分子网的IPv4地址</h4>
<ul>
<li>32比特的子网掩码可以表明分类Ip地址的主机号部分被借用了几个比特作为子网号</li>
<li>子网掩码使用连续的比特1来对应网络号和子网号</li>
<li>子网掩码使用连续的比特0来对应主机号</li>
<li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址</li>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531173526.png" alt="" /></li>
<li>例子：
<ul>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531201838.png" alt="" /></li>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531202042.png" alt="" /></li>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531202403.png" alt="" /></li>
</ul>
</li>
<li>默认的子网掩码是指未划分子网的情况下使用的子网掩码
<ul>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531202751.png" alt="" /></li>
</ul>
</li>
</ul>
<h4 id="1-5-wu-fen-lei-bian-zhi-de-i-pv-4-di-zhi" id="1-5、无分类编址的IPv4地址">1.5、无分类编址的IPv4地址</h4>
<ul>
<li>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间大小并没有得到充分使用，而因特网的IP地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</li>
<li>1993年，IETF发布了无分类域间路由选择CIDR
<ul>
<li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念；</li>
<li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的IPv6使用之前 允许因特网的规模继续增长。</li>
</ul>
</li>
<li>例子：
<ul>
<li><img data-src="https://fastly.jsdelivr.net/gh/zglgithubx/picture/img/20220531204506.png" alt="" /></li>
</ul>
</li>
</ul>
<h4 id="1-5-si-kao" id="1-5、思考">1.5、思考</h4>
<h5 id="shi-yao-shi-zi-wang" id="什么是子网">什么是子网</h5>
<p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网(subnet)。</strong></p>
<h5 id="shi-yao-shi-zi-wang-yan-ma" id="什么是子网掩码">什么是子网掩码</h5>
<ul>
<li>指明一个<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>的哪些位标识的是<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>所在的子网，以及哪些位标识的是主机的位掩码</li>
<li>通过子网掩码，就可以判断两个IP在不在一个局域网内部。</li>
<li>子网掩码可以看出有多少位是网络号，有多少位是主机号</li>
</ul>
<h5 id="zi-wang-hua-fen-de-yi-yi" id="子网划分的意义">子网划分的意义</h5>
<ul>
<li>节省IP地址资源</li>
<li>大大减少路由表的数目</li>
</ul>
<h2 id="er-mian-shi-ti" id="二、面试题-2">二、面试题</h2>
<h3 id="1-liu-lan-qi-zhong-shu-ru-wang-zhi-qiao-hui-che-fa-sheng-liao-shi-yao" id="1、浏览器中输入网址敲回车发生了什么？">1、浏览器中输入网址敲回车发生了什么？</h3>
<ul>
<li>URL解析</li>
<li>DNS查询</li>
<li>TCP连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面<br />
参考：<a href="https://zhuanlan.zhihu.com/p/80551769">在浏览器输入 URL 回车之后发生了什么（超详细版） - 知乎 (zhihu.com)</a></li>
</ul>
<h3 id="2-fu-wu-qi-ru-he-qu-fen-yong-hu-qing-qiu-de" id="2、服务器如何区分用户请求的？">2、服务器如何区分用户请求的？</h3>
<ul>
<li>浏览器首次访问服务器时，服务器会给客户端创建一个会话session，并响应一个会话的唯一标识sessionId。</li>
<li>浏览器收到此SessionId后，第二次请求时会将此sessionId添加中请求头的cookie中。</li>
<li>服务器判断cookie中的sessionId是否有效，来判断是否是同一浏览器进程发起的请求。<br />
参考：<a href="https://blog.csdn.net/qq_17125355/article/details/44621195">一分钟解惑：上万个用户请求，服务器如何区分_君子_不器的博客-CSDN博客</a></li>
</ul>
<h3 id="3-lu-you-qi-fang-huo-qiang-chu-yu-na-yi-ceng" id="3、路由器、防火墙处于哪一层？">3、路由器、防火墙处于哪一层？</h3>
<ul>
<li>路由器：则是一种典型的网络层设备，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。</li>
<li>防火墙：传统的包过滤防火墙工作在网络层，电路网关防火墙工作在传输层（线路级防火墙工作在会话层），应用网关类的代理防火墙则工作在OSI最高的应用层。</li>
</ul>
<h3 id="4-dns-xie-yi" id="4、DNS协议">4、DNS协议</h3>
<ul>
<li>域名解析系统，是互联网一项服务，完成域名地址与IP地址的转换</li>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/351059293">超详细 DNS 协议解析 - 知乎 (zhihu.com)</a><br />
<a href="https://blog.csdn.net/weixin_44475093/article/details/117050871">面试官：DNS 协议是什么？说说 DNS 完整的查询过程?_动感超人，的博客-CSDN博客</a></li>
</ul>
<h3 id="5-http-xie-yi" id="5、HTTP协议">5、HTTP协议</h3>
<p><code>HTTP</code>协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。</p>
<blockquote>
<p><strong>注意</strong>：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在传输层协议TCP之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。</p>
</blockquote>
<p><code>HTTP</code> 是一种<strong>无状态</strong> (stateless) 协议, <code>HTTP</code>协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持HTTP协议的简单性，从而能够快速处理大量的事务, 提高效率。</p>
<h3 id="6-http-he-tcp-qu-bie-he-lian-xi" id="6、HTTP和TCP区别和联系？">6、HTTP和TCP区别和联系？</h3>
<ul>
<li>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</li>
<li>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</li>
</ul>
<h3 id="7-http-he-https-de-qu-bie-http-zhong-s-shi-zhi-shi-yao" id="7、HTTP和HTTPS的区别，HTTP中S是指什么？">7、HTTP和HTTPS的区别，HTTP中S是指什么？</h3>
<ul>
<li>区别：
<ul>
<li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口不一样，前者是80，后者是443；</li>
</ul>
</li>
<li>字母S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。
<ul>
<li>SSL/TLS协议目的：
<ul>
<li>所有信息都是加密传播，避免窃听风险</li>
<li>具有校验机制，被篡改后，通信双方可以立刻发现</li>
<li>配被身份证书，防止被冒充</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-https-yuan-li" id="8、HTTPS原理">8、HTTPS原理</h3>
<ul>
<li>建立连接过程（非对称加密）
<ul>
<li>客户端向服务端发送请求，请求内容中包含（支持的TLS版本，客服端支持的加密套件，随机数A）
<ul>
<li>服务端响应给客户端，内容包括（确认支持的TLS版本，服务端选择的加密套件，随机数B）</li>
<li>服务端再次发送响应，此次内容为服务器的证书，客户端（浏览器查看可信任的证书列表）验证证书是否可信</li>
<li>服务端响应给客户端证书公钥</li>
</ul>
</li>
<li>客户端生成随机数C，使用公钥加密随机数C，将加密后的随机数C发送给服务端
<ul>
<li>服务端使用私钥解密随机数C</li>
</ul>
</li>
<li>客户端和服务端使用随机A，B，C，计算出会话密钥（只应用于当前会话）</li>
</ul>
</li>
<li>传输数据（对称加密）
<ul>
<li>客户端和服务端使用会话密钥对数据进行加解密</li>
</ul>
</li>
</ul>
<h3 id="9-gong-yao-jia-mi-he-si-yao-jia-mi-you-shi-yao-qu-bie" id="9、公钥加密和私钥加密有什么区别？">9、公钥加密和私钥加密有什么区别？</h3>
<ul>
<li>公钥加密用来加密数据。公钥加密后，只能用私钥解密，而私钥不是公开的，所以保证了数据只能由私钥持有者才能看到。如果用私钥加密，公钥是公开的，这样就会导致所有人都能解密，并不能保证数据的私密性。</li>
<li>私钥加密用来签名，公钥用于验签。签名并不是为了保密，而是保证了这个签名是由特定的人发出的，而不是被其他人伪造的，所有私钥的私有性适合用在签名的用途上。</li>
<li>公私钥特性
<ul>
<li>公钥与私钥是成对出现的</li>
<li>私钥文件中包含了公钥数据，所以可以基于私钥导出公钥</li>
<li>密钥越长，越难破解，所以2048位密钥比1024位密钥要更安全</li>
<li>公钥和私钥都是密钥，被公开的那个就是公钥，没有被公开的那个就是私钥</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫实践</title>
    <url>/posts/31819.html</url>
    <content><![CDATA[<h3 id="java-xie-pa-chong-fen-wei-liang-bu-di-yi-bu-da-kai-idea-di-er-bu-kai-shi-qiao-dai-ma" id="Java写爬虫分为两步：第一步打开idea，第二步开始敲代码…">Java写爬虫分为两步：第一步打开idea，第二步开始敲代码…</h3>
<span id="more"></span>   
<h3 id="1-wo-de-jian-jie" id="1、我的见解">1、我的见解</h3>
<p>爬虫，我的理解就是，首先要可以获取大量数据，然后在大量数据中筛选出自己想要的数据，并且能对数据进行修饰。接下来，将会给大家介绍，两种爬取数据的方式：JSoup和WebClient。</p>
<h3 id="2-j-soup" id="2、JSoup">2、JSoup</h3>
<h4 id="shi-shi-yao" id="①是什么">①是什么</h4>
<p>Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果。 在本教程中，我们将介绍很多Jsoup的例子。</p>
<h4 id="ta-neng-zuo-shi-yao" id="②它能做什么">②它能做什么</h4>
<ul>
<li>从URL，文件或字符串中刮取并解析HTML</li>
<li>查找和提取数据，使用DOM遍历或CSS选择器</li>
<li>操纵HTML元素，属性和文本</li>
<li>根据安全的白名单清理用户提交的内容，以防止XSS攻击</li>
<li>输出整洁的HTML</li>
</ul>
<h4 id="xia-zai-yi-lai" id="③下载依赖">③下载依赖</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;!-- jsoup HTML parser library @ http:<span class="comment">//jsoup.org/ --&gt;</span></span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.10</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="jsoup-yong-fa" id="④Jsoup用法">④Jsoup用法</h4>
<ul>
<li>
<p>从URL获取HTML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://www.baidu.com/&quot;</span>).get();</span><br><span class="line"><span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> doc.title();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其中其中JSoup.connet(“<a href="http://xxx">http://xxx</a>”)方法返回了一个Connection对象</p>
</li>
<li>
<p>在Connection对象可以调用get()或post()方法执行请求，也可以在Connection对象中设置一些请求信息。比如：头信息，cookie ,请求等待时间，代理等。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">  .data(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">  .userAgent(<span class="string">&quot;Mozilla&quot;</span>)</span><br><span class="line">  .cookie(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;token&quot;</span>)</span><br><span class="line">  .timeout(<span class="number">3000</span>)</span><br><span class="line">  .post();</span><br></pre></td></tr></table></figure>
<ul>
<li>发送请求后，就会获取一个Document文档对象，内容是当前链接的html</li>
</ul>
</li>
<li>
<p>获得Document对象后，接下来就是解析Document对象，并从中获取我们想要的元素了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//doucment对象中获取相应标签的方法</span></span><br><span class="line">getElementById(String id)：通过id来获取</span><br><span class="line">getElementsByTag(String tagName)：通过标签名字来获取</span><br><span class="line">getElementsByClass(String className)：通过类名来获取</span><br><span class="line">getElementsByAttribute(String key)：通过属性名字来获取</span><br><span class="line">getElementsByAttributeValue(String key, String value)：通过指定的属性名字，属性值来获取</span><br><span class="line">getAllElements()：获取所有元素</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Jsoup的强大在于它对文档元素的检索，Select方法将返回一个Elements集合，并提供一组方法来抽取和处理结果，即Jsoup的选择器语法。</p>
<p>1、Selector选择器基本语法</p>
<ul>
<li>
<p>tagname: 通过标签查找元素，比如：a</p>
</li>
<li>
<p>ns|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 <a href="fb:name">fb:name</a> 元素</p>
</li>
<li>
<p>#id: 通过ID查找元素，比如：#logo</p>
</li>
<li>
<p>.class: 通过class名称查找元素，比如：.masthead</p>
</li>
<li></li>
<li></li>
<li></li>
<li>
<p>[attr^=value], [attr$=value], [attr*=value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href*=/path/]</p>
</li>
<li>
<p>[attr~=regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src~=(?i).(png|jpe?g)]</p>
</li>
<li>
<p>*: 这个符号将匹配所有元素</p>
</li>
</ul>
<p>2、Selector选择器组合使用语法</p>
<ul>
<li>el#id: 元素+ID，比如： div#logo</li>
<li>el.class: 元素+class，比如： div.masthead</li>
<li>el[attr]: 元素+class，比如： a[href]</li>
<li>任意组合，比如：a[href].highlight</li>
<li>ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在”body”元素下的所有 p元素</li>
<li>parent &gt; child: 查找某个父元素下的直接子元素，比如：可以用div.content &gt; p 查找 p 元素，也可以用body &gt; * 查找body标签下所有直接子元素</li>
<li>siblingA + siblingB: 查找在A元素之前第一个同级元素B，比如：div.head + div</li>
<li>siblingA ~ siblingX: 查找A元素之前的同级X元素，比如：h1 ~ p</li>
<li>el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo</li>
</ul>
<p>3、Selector伪选择器语法</p>
<ul>
<li>:lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小于三列的元素</li>
<li>:gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素</li>
<li>:eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素</li>
<li>:has(seletor): 查找匹配选择器包含元素的元素，比如：div:has§表示哪些div包含了p元素</li>
<li>:not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class=logo 元素的所有 div 列表</li>
<li>:contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup)</li>
<li>:containsOwn(text): 查找直接包含给定文本的元素</li>
<li>:matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login)</li>
<li>:matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素</li>
</ul>
<p>注意：上述伪选择器索引是从0开始的，也就是说第一个元素索引值为0，第二个元素index为1等。</p>
</li>
</ul>
</li>
</ul>
<h4 id="shi-li" id="⑤实例">⑤实例</h4>
<ul>
<li>
<p>使用<code>Jsoup.connect()</code> 方法从URL加载HTML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Document document=Jsoup.connect(<span class="string">&quot;http://www.baidu.com&quot;</span>).get();</span><br><span class="line">    System.out.println(document);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从文件加载HTML,使用<code>Jsoup.parse()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse( <span class="keyword">new</span> <span class="title class_">File</span>( <span class="string">&quot;D:/temp/index.html&quot;</span> ) , <span class="string">&quot;utf-8&quot;</span> );</span><br><span class="line">    System.out.println(document.title());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>Jsoup.parse()</code> 方法从字符串加载HTML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">                    + <span class="string">&quot;&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">    System.out.println(document.title());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取HTML页面的图标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">favImage</span> <span class="operator">=</span> <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/temp/index.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> document.head().select(<span class="string">&quot;link[href~=.*\\.(ico|png)]&quot;</span>).first();</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="literal">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        element = document.head().select(<span class="string">&quot;meta[itemprop=image]&quot;</span>).first();</span><br><span class="line">        <span class="keyword">if</span> (element != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            favImage = element.attr(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        favImage = element.attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(favImage);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取HTML页面的所有链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/temp/index.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Elements</span> <span class="variable">links</span> <span class="operator">=</span> document.select(<span class="string">&quot;a[href]&quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (Element link : links) </span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;link : &quot;</span> + link.attr(<span class="string">&quot;href&quot;</span>));  </span><br><span class="line">         System.out.println(<span class="string">&quot;text : &quot;</span> + link.text());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取HTML页面中所有的图像</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/temp/index.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">Elements</span> <span class="variable">images</span> <span class="operator">=</span> document.select(<span class="string">&quot;img[src~=(?i)\\.(png|jpe?g|gif)]&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Element image : images) </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;src : &quot;</span> + image.attr(<span class="string">&quot;src&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;height : &quot;</span> + image.attr(<span class="string">&quot;height&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;width : &quot;</span> + image.attr(<span class="string">&quot;width&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;alt : &quot;</span> + image.attr(<span class="string">&quot;alt&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改获取的HTML标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Users/zkpkhua/Desktop/yiibai.com.html&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//将所有div标签替换为p标签</span></span><br><span class="line">    document.select(<span class="string">&quot;div&quot;</span>).tagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">    <span class="type">Elements</span> <span class="variable">links</span> <span class="operator">=</span> document.select(<span class="string">&quot;a[href]&quot;</span>);  </span><br><span class="line">    <span class="comment">//给所有a标签添加属性rel=&quot;nofollow&quot;</span></span><br><span class="line">    links.attr(<span class="string">&quot;rel&quot;</span>, <span class="string">&quot;nofollow&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>消除不信任的HTML（防止XSS攻击）</p>
<ul>
<li>Jsoup在提供强大的API的同时，人性化方面也做得很好。在做网站的时候，经常会提供用户的评论的功能。有些用户比较淘气，会搞一些脚本到评论内容中，而这些脚本可能会破坏整个页面的功能，更严重的是获取一些机要信息，例如XSS跨站攻击之类的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dirtyHTML</span> <span class="operator">=</span> <span class="string">&quot;&lt;p&gt;&lt;a href=&#x27;http://www.yiibai.com/&#x27; onclick=&#x27;sendCookiesToMe()&#x27;&gt;Link&lt;/a&gt;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">cleanHTML</span> <span class="operator">=</span> Jsoup.clean(dirtyHTML, Whitelist.basic());</span><br><span class="line">System.out.println(cleanHTML);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行后输出结果</span></span><br><span class="line">&lt;p&gt;&lt;a href=<span class="string">&quot;http://www.yiibai.com/&quot;</span> rel=<span class="string">&quot;nofollow&quot;</span>&gt;Link&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Jsoup使用一个Whitelist类来对HTML文档进行过滤，该类提供了几个常用的方法</p>
</li>
<li>
<table>
<thead>
<tr>
<th>方法名</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>none()</td>
<td>只允许包含文本信息</td>
</tr>
<tr>
<td>basic()</td>
<td>允许的标签包括：a,b,blockquote,br,cite, code,dd,dl,dt,em,i,li,ol,p.pre,q,small,strong,sub,sujp,u,ul,以及合适的属性</td>
</tr>
<tr>
<td>simpel(）</td>
<td>只允许b，em，i，strong，u，这些标签</td>
</tr>
<tr>
<td>basicWithImage()</td>
<td>在basic()基础上增加了图片</td>
</tr>
<tr>
<td>relax()</td>
<td>这个过滤器允许的标签最多，包括：a，b，blockquote，br，caption，cite，code，col，colgroup，dd，dl，dt，em，h1-h6，i，img，li，ol，p，pre，q，small，strike，strong，sub，sup， table，tbody，td，tfoot，th，thead，tr，u，ul</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>如果这五个过滤器都无法满足你的需求，例如你允许用户插入flase动画，没关系，Whitelist提供扩展功能，例如<code>whitelist.addTags(&quot;embed&quot;,&quot;object&quot;,&quot;param&quot;,&quot;span&quot;,&quot;div&quot;)</code>，也可以调用<code>addAttributes</code>为某些元素增加属性</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-web-client" id="3、WebClient">3、WebClient</h3>
<p>ps：它比jsoup好在哪，在我的需求中，它比jsoup获取更深的数据，有时页面的链接并不会直接显式放到a标签中的href属性中，而是放到了js文件中，利用用户点击事件触发执行。webclient相当于一个能模拟浏览器的工具，比如你可以用它在页面中提交表单，发起请求等。</p>
<h4 id="shi-shi-yao-1" id="①是什么-2">①是什么</h4>
<p>WebClient是从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对应的get、post、put、delete等方法，可以用来发起相应的请求。</p>
<h4 id="zen-yao-yong" id="②怎么用">②怎么用</h4>
<ul>
<li>用maven引入依赖，或者直接下载jar包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;	</span><br></pre></td></tr></table></figure>
<ul>
<li>一个例子</li>
</ul>
<p>通过<code>WebClient.create()</code>创建一个WebClient的实例，之后可以通过get()，post() 等选择调用方式，uri() 指定需要请求的路径，retrieve（） 用来发起请求并获得响应，<code>bodyToMono(String.class) </code>用来指定请求结果需要处理为String，并包装为Reactor的Mono对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebClient webClient=WebClient.create();</span><br><span class="line">Mono&lt;String&gt; mono=webClient.get().uri(<span class="string">&quot;https://www.baidu.com&quot;</span>).retrieve().bodyToMono(String.class);</span><br><span class="line">System.out.println(mono.block());</span><br></pre></td></tr></table></figure>
<h4 id="shi-li-1" id="③实例">③实例</h4>
<ul>
<li>
<p>URL中使用路径变量</p>
<ul>
<li>
<p>URL中也可以使用路径变量，路径变量的值可以通过uri方法的第2个参数指定。下面的代码中就定义了URL中拥有一个路径变量id，然后实际访问时该变量将取值1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webClient.get().uri(<span class="string">&quot;http://localhost:8081/user/&#123;id&#125;&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>URL中也可以使用多个路径变量，多个路径变量的赋值将依次使用uri方法的第2个、第3个、第N个参数。下面的代码中就定义了URL中拥有路径变量p1和p2，实际访问的时候将被替换为var1和var2。所以实际访问的URL是<code>http://localhost:8081/user/var1/var2</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webClient.get().uri(<span class="string">&quot;http://localhost:8081/user/&#123;p1&#125;/&#123;p2&#125;&quot;</span>, <span class="string">&quot;var1&quot;</span>, <span class="string">&quot;var2&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用的路径变量也可以通过Map进行赋值。面的代码中就定义了URL中拥有路径变量p1和p2，实际访问的时候会从uriVariables中获取值进行替换。所以实际访问的URL是<code>http://localhost:8081/user/var1/1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; uriVariables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">uriVariables.put(<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;var1&quot;</span>);</span><br><span class="line">uriVariables.put(<span class="string">&quot;p2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">webClient.get().uri(<span class="string">&quot;http://localhost:8081/user/&#123;p1&#125;/&#123;p2&#125;&quot;</span>, uriVariables);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用uriBuilder传递参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://192.1681.5.9:8989&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line">WebClient.<span class="type">RequestBodyUriSpec</span> <span class="variable">request</span> <span class="operator">=</span> webClient.method(HttpMethod.POST);</span><br><span class="line">request.uri(uriBuilder -&gt; uriBuilder</span><br><span class="line">            .scheme(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">            .host(<span class="string">&quot;192.168.5.9&quot;</span>)</span><br><span class="line">            .path(<span class="string">&quot;/mxtest4&quot;</span>)</span><br><span class="line">            .port(<span class="number">8989</span>)</span><br><span class="line">            .path(<span class="string">&quot;/mxtest4&quot;</span>)</span><br><span class="line">            .queryParam(<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;啊&quot;</span>)</span><br><span class="line">            .queryParam(<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;是&quot;</span>)</span><br><span class="line">            .build());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定baseUrl</p>
<ul>
<li>
<p>在应用中使用WebClient时也许你要访问的URL都来自同一个应用，只是对应不同的URL地址，这个时候可以把公用的部分抽出来定义为baseUrl，然后在进行WebClient请求的时候只指定相对于baseUrl的URL部分即可。这样的好处是你的baseUrl需要变更的时候可以只要修改一处即可。下面的代码在创建WebClient时定义了baseUrl为<code>http://localhost:8081</code>，在发起Get请求时指定了URL为<code>/user/1</code>，而实际上访问的URL是<code>http://localhost:8081/user/1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line">Mono&lt;User&gt; mono = webClient.get().uri(<span class="string">&quot;user/&#123;id&#125;&quot;</span>, <span class="number">1</span>).retrieve().bodyToMono(User.class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>表单提交</p>
<ul>
<li>
<p>当传递的请求体对象是一个MultiValueMap对象时，WebClient默认发起的是Form提交。下面的代码中就通过Form提交模拟了用户进行登录操作，给Form表单传递了参数username，值为u123，传递了参数password，值为p123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;u123&quot;</span>);</span><br><span class="line">map.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;p123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;String&gt; mono = webClient.post().uri(<span class="string">&quot;/login&quot;</span>).syncBody(map).retrieve().bodyToMono(String.class);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>请求时携带JSON参数</p>
<ul>
<li>
<p>假设现在拥有一个新增User的接口，按照接口定义客户端应该传递一个JSON对象，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>客户端可以建立一个满足需要的JSON格式的对象，然后直接把该对象作为请求体，WebClient会帮我们自动把它转换为JSON对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; mono = webClient.post().uri(<span class="string">&quot;/user/add&quot;</span>).syncBody(user).retrieve().bodyToMono(Void.class);</span><br><span class="line">mono.block();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有建立对应的对象，直接包装为一个Map对象也是可以的。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">user.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; mono = webClient.post().uri(<span class="string">&quot;/user/add&quot;</span>).syncBody(user).retrieve().bodyToMono(Void.class);</span><br><span class="line">mono.block();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>直接传递一个JSON字符串也是可以的，但是此时需要指定contentType为<code>application/json</code>，也可以加上charset。默认情况下WebClient将根据传递的对象在进行解析处理后自动选择ContentType。直接传递字符串时默认使用的ContentType会是<code>text/plain</code>。其它情况下也可以主动指定ContentType。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> </span><br><span class="line">        <span class="string">&quot;&#123;&quot;</span> + </span><br><span class="line">        <span class="string">&quot;    \&quot;name\&quot;:\&quot;张三\&quot;,\r\n&quot;</span> + </span><br><span class="line">        <span class="string">&quot;    \&quot;username\&quot;:\&quot;zhangsan\&quot;\r\n&quot;</span> + </span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; mono = webClient.post().uri(<span class="string">&quot;/user/add&quot;</span>).contentType(MediaType.APPLICATION_JSON_UTF8).syncBody(userJson).retrieve().bodyToMono(Void.class);</span><br><span class="line">mono.block();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>处理WebClient错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebClient.<span class="type">ResponseSpec</span> <span class="variable">retrieve</span> <span class="operator">=</span> request.retrieve();</span><br><span class="line"></span><br><span class="line">Mono&lt;String&gt; mono = retrieve</span><br><span class="line">        .onStatus(e -&gt; e.is4xxClientError(), resp -&gt; &#123;</span><br><span class="line">            System.out.println(resp.statusCode().value() + <span class="string">&quot;,&quot;</span> + resp.statusCode().getReasonPhrase());</span><br><span class="line">            <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(resp.statusCode().value() + <span class="string">&quot; : &quot;</span> + resp.statusCode().getReasonPhrase()));</span><br><span class="line">        &#125;)</span><br><span class="line">        .bodyToMono(String.class)</span><br><span class="line">        .doOnError(WebClientResponseException.class, err -&gt; &#123;</span><br><span class="line">            System.out.println(err.getRawStatusCode() + <span class="string">&quot;,&quot;</span> + err.getResponseBodyAsString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(err.getMessage());</span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorReturn(<span class="string">&quot;fallback&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;result:&quot;</span> + mono.block());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>上传和下载文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">headers.setContentType(MediaType.IMAGE_PNG);</span><br><span class="line">HttpEntity&lt;ClassPathResource&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;parallel.png&quot;</span>), headers);</span><br><span class="line">MultiValueMap&lt;String, Object&gt; parts = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">parts.add(<span class="string">&quot;file&quot;</span>, entity);</span><br><span class="line">Mono&lt;String&gt; resp = WebClient.create().post()</span><br><span class="line">        .uri(<span class="string">&quot;http://localhost:8080/upload&quot;</span>)</span><br><span class="line">        .contentType(MediaType.MULTIPART_FORM_DATA)</span><br><span class="line">        .body(BodyInserters.fromMultipartData(parts))</span><br><span class="line">        .retrieve().bodyToMono(String.class);</span><br><span class="line">LOGGER.info(<span class="string">&quot;result:&#123;&#125;&quot;</span>,resp.block());</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载图片</span></span><br><span class="line">Mono&lt;Resource&gt; resp = WebClient.create().get()</span><br><span class="line">            .uri(<span class="string">&quot;http://www.toolip.gr/captcha?complexity=99&amp;size=60&amp;length=9&quot;</span>)</span><br><span class="line">            .accept(MediaType.IMAGE_PNG)</span><br><span class="line">            .retrieve().bodyToMono(Resource.class);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resp.block();</span><br><span class="line"><span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> ImageIO.read(resource.getInputStream());</span><br><span class="line">ImageIO.write(bufferedImage, <span class="string">&quot;png&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;captcha.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载文件</span></span><br><span class="line">Mono&lt;ClientResponse&gt; resp = WebClient.create().get()</span><br><span class="line">        .uri(<span class="string">&quot;http://localhost:8080/file/download&quot;</span>)</span><br><span class="line">        .accept(MediaType.APPLICATION_OCTET_STREAM)</span><br><span class="line">        .exchange();</span><br><span class="line"><span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> resp.block();</span><br><span class="line"><span class="type">String</span> <span class="variable">disposition</span> <span class="operator">=</span> response.headers().asHttpHeaders().getFirst(HttpHeaders.CONTENT_DISPOSITION);</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> disposition.substring(disposition.indexOf(<span class="string">&quot;=&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> response.bodyToMono(Resource.class).block();</span><br><span class="line"><span class="type">File</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">FileUtils.copyInputStreamToFile(resource.getInputStream(),out);</span><br><span class="line">LOGGER.info(out.getAbsolutePath());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>异步调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = request.retrieve().bodyToFlux(String.class);</span><br><span class="line"><span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flux.subscribe(tweet -&gt; &#123;</span><br><span class="line">    <span class="comment">//如果jvm结束了，就不能显示了</span></span><br><span class="line">    System.out.println(tweet.toString());</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;result:exit&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取响应头信息</p>
<ul>
<li>前面介绍的示例都是直接获取到了响应的内容，可能你会想获取到响应的头信息、Cookie等。那就可以在通过WebClient请求时把调用<code>retrieve()</code>改为调用<code>exchange()</code>，这样可以访问到代表响应结果的<code>org.springframework.web.reactive.function.client.ClientResponse</code>对象，通过它可以获取响应的状态码、Cookie等。下面的代码先是模拟用户进行了一次表单的登录操作，通过ClientResponse获取到了登录成功后的写入Cookie的sessionId，然后继续请求了用户列表。在请求获取用户列表时传递了存储了sessionId的Cookie。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.create(baseUrl);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;u123&quot;</span>);</span><br><span class="line">map.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;p123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;ClientResponse&gt; mono = webClient.post().uri(<span class="string">&quot;login&quot;</span>).syncBody(map).exchange();</span><br><span class="line"><span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> mono.block();</span><br><span class="line"><span class="keyword">if</span> (response.statusCode() == HttpStatus.OK) &#123;</span><br><span class="line">    Mono&lt;Result&gt; resultMono = response.bodyToMono(Result.class);</span><br><span class="line">    resultMono.subscribe(result -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">            <span class="type">ResponseCookie</span> <span class="variable">sidCookie</span> <span class="operator">=</span> response.cookies().getFirst(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">            Flux&lt;User&gt; userFlux = webClient.get().uri(<span class="string">&quot;users&quot;</span>).cookie(sidCookie.getName(), sidCookie.getValue()).retrieve().bodyToFlux(User.class);</span><br><span class="line">            userFlux.subscribe(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>WebClient.Builder</p>
<ul>
<li>除了可以通过<code>WebClient.create()</code>创建WebClient对象外，还可以通过<code>WebClient.builder()</code>创建一个<code>WebClient.Builder</code>对象，再对Builder对象进行一些配置后调用其<code>build()</code>创建WebClient对象。下面的代码展示了其用法，配置了baseUrl和默认的cookie信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder().baseUrl(baseUrl).defaultCookie(<span class="string">&quot;cookieName&quot;</span>, <span class="string">&quot;cookieValue&quot;</span>).build();</span><br><span class="line"><span class="comment">//使用WebClient构建器，可以自定义选项：包括过滤器、默认标题、cookie、客户端连接器等</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;https://api.github.com&quot;</span>)</span><br><span class="line">        .defaultHeader(HttpHeaders.CONTENT_TYPE, <span class="string">&quot;application/vnd.github.v3+json&quot;</span>)</span><br><span class="line">        .defaultHeader(HttpHeaders.USER_AGENT, <span class="string">&quot;Spring 5 WebClient&quot;</span>)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<ul>
<li>Builder还可以通过<code>clientConnector()</code>定义需要使用的ClientHttpConnector，默认将使用<code>org.springframework.http.client.reactive.ReactorClientHttpConnector</code>，其底层是基于netty的，如果你使用的是Maven，需要确保你的pom.xml中定义了如下依赖。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.projectreactor.ipc&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;reactor-netty&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.7</span><span class="number">.8</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果对默认的发送请求和处理响应结果的编解码不满意，还可以通过exchangeStrategies()定义使用的ExchangeStrategies。ExchangeStrategies中定义了用来编解码的对象，其也有对应的build()方法方便我们来创建ExchangeStrategies对象。</p>
<p><em>WebClient也提供了Filter，对应于org.springframework.web.reactive.function.client.ExchangeFilterFunction接口，其接口方法定义如下。</em></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mono&lt;ClientResponse&gt; <span class="title function_">filter</span><span class="params">(ClientRequest request, ExchangeFunction next)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在进行拦截时可以拦截request，也可以拦截response。下面的代码定义的Filter就拦截了request，给每个request都添加了一个名为header1的header，值为value1。它也拦截了response，response中也是添加了一个新的header信息。拦截response时，如果新的ClientResponse对象是通过<code>ClientResponse.from(response)</code>创建的，新的response是不会包含旧的response的body的，如果需要可以通过<code>ClientResponse.Builder</code>的<code>body()</code>指定，其它诸如header、cookie、状态码是会包含的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder().baseUrl(baseUrl).filter((request, next) -&gt; &#123;</span><br><span class="line">    <span class="type">ClientRequest</span> <span class="variable">newRequest</span> <span class="operator">=</span> ClientRequest.from(request).header(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;value1&quot;</span>).build();</span><br><span class="line">    Mono&lt;ClientResponse&gt; responseMono = next.exchange(newRequest);</span><br><span class="line">    <span class="keyword">return</span> Mono.fromCallable(() -&gt; &#123;</span><br><span class="line">        <span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> responseMono.block();</span><br><span class="line">        <span class="type">ClientResponse</span> <span class="variable">newResponse</span> <span class="operator">=</span> ClientResponse.from(response).header(<span class="string">&quot;responseHeader1&quot;</span>, <span class="string">&quot;Value1&quot;</span>).build();</span><br><span class="line">        <span class="keyword">return</span> newResponse;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure>
<ul>
<li>如果定义的Filter只期望对某个或某些request起作用，可以在Filter内部通过request的相关属性进行拦截，比如cookie信息、header信息、请求的方式或请求的URL等。也可以通过<code>ClientRequest.attribute(attrName)</code>获取某个特定的属性，该属性是在请求时通过<code>attribute(&quot;attrName&quot;, &quot;attrValue&quot;)</code>指定的。这跟在HttpServletRequest中添加的属性的作用范围是类似的。</li>
</ul>
</li>
<li>
<p>配置连接池，超时时间等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ReactorResourceFactory <span class="title function_">resourceFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReactorResourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReactorResourceFactory</span>();</span><br><span class="line">        factory.setUseGlobalResources(<span class="literal">false</span>);</span><br><span class="line">        factory.setConnectionProvider(ConnectionProvider.fixed(<span class="string">&quot;httpClient&quot;</span>, <span class="number">50</span>, <span class="number">10</span>));</span><br><span class="line">        factory.setLoopResources(LoopResources.create(<span class="string">&quot;httpClient&quot;</span>, <span class="number">50</span>, <span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WebClient <span class="title function_">webClient</span><span class="params">()</span> &#123;</span><br><span class="line">        Function&lt;HttpClient, HttpClient&gt; mapper = client -&gt;</span><br><span class="line">                client.tcpConfiguration(c -&gt;</span><br><span class="line">                        c.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">10</span>)</span><br><span class="line">                                .option(TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                                .doOnConnected(conn -&gt; &#123;</span><br><span class="line">                                    conn.addHandlerLast(<span class="keyword">new</span> <span class="title class_">ReadTimeoutHandler</span>(<span class="number">10</span>));</span><br><span class="line">                                    conn.addHandlerLast(<span class="keyword">new</span> <span class="title class_">WriteTimeoutHandler</span>(<span class="number">10</span>));</span><br><span class="line">                                &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="type">ClientHttpConnector</span> <span class="variable">connector</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReactorClientHttpConnector</span>(resourceFactory(), mapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> WebClient.builder().clientConnector(connector).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-can-kao" id="3、参考">3、参考</h3>
<p><a href="https://www.yiibai.com/jsoup/jsoup-quick-start.html">JSoup快速入门 - JSoup教程™ (yiibai.com)</a></p>
<p><a href="https://www.cnblogs.com/grasp/p/12179906.html">Spring的WebClient基本使用 - xuanm - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/posts/5303.html</url>
    <content><![CDATA[<p>——摘录自《MySQL是怎样运行的》</p>
<span id="more"></span>
<h3 id="1-zi-fu-ji-he-bi-jiao-gui-ze" id="1、字符集和比较规则">1、字符集和比较规则</h3>
<h4 id="1-1-zi-fu-ji-jian-jie" id="1-1、字符集简介">1.1、字符集简介</h4>
<p>字符集是人们抽象出来一个字符集的概念来描述某个字符范围的编码规则，简单的来说就是在某个范围的字符建立与二进制数据的映射关系（编码规则）。</p>
<h4 id="1-2-bi-jiao-gui-ze-jian-jie" id="1-2、比较规则简介">1.2、比较规则简介</h4>
<p>对某个字符集中比较大小的规则。比如字符’a‘的编码为0x01,字符’b‘的编码为0x02，所以’a’小于’b’。这种简单的比较规则也可以称为二进制比较规则。但在很多场合下，英文字符都是不区分大小写额，也就是’a’和‘A’是相等的。此时就不可以简单粗暴地使用二进制比较规则，此时可以这样指定比较规则：</p>
<ul>
<li>将两个大小写不同的字符都转为大写或者小写。</li>
<li>再比较这两个字符对应的二进制数据。</li>
</ul>
<h4 id="1-3-chang-jian-de-zi-fu-ji" id="1-3、常见的字符集">1.3、常见的字符集</h4>
<ul>
<li>ASCII字符集（1字节）：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于该字符集总共才128个字符，所以可以使用一个字节来进行编码。
<ul>
<li>‘L’ -&gt;01001100(十六进制0x4C，十进制76)</li>
<li>‘M’ -&gt;01001101(十六进制0x4D，十进制77)</li>
</ul>
</li>
<li>ISO 8859-1字符集：共收录256个字符，它在ASCII字符集的基础上又扩充了128个西欧常用字符（包括德法两国的字母）。ISO 8859-1字符集也可以使用一个字节来进行编码。</li>
<li>GB2312字符集（1-2字节）：共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时，GB 2312收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。整个字符集分成94个区，每区有94个位。这种字符集兼容ASCII字符集，在编码方式有些特别之处：如果字符在ASCII字符集中，则采用一字节编码；否则采用两字节编码
<ul>
<li>GB2312，又称为GB0，由中国国家标准总局发布，1981年5月1日实施</li>
<li>GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个</li>
<li>GB2312是一种区位码。分为94个区(01-94)，每区94个字符(01-94)</li>
<li>01-09区为特殊符号</li>
<li>10-15区没有编码</li>
<li>16-55区为一级汉字，按拼音排序，共3755个</li>
<li>56-87区为二级汉字，按部首／笔画排序，共3008个</li>
<li>88-94区没有编码</li>
<li>GB2312只是编码表，在计算机中通常都是用&quot;EUC-CN&quot;表示法，即在每个区位加上0xA0来表示。区和位分别占用一个字节。</li>
</ul>
</li>
<li>GBK字符集：在收录的字符范围上对GB2312字符集进行了扩充，编码方式兼容GB2312字符集。</li>
<li>UTF-8字符集：编码规则：
<ul>
<li>一个US-ASCIl字符只需1字节编码（Unicode范围由U+0000~U+007F）。</li>
<li>带有变音符号的拉丁文、希腊文、<a href="https://baike.baidu.com/item/%E8%A5%BF%E9%87%8C%E5%B0%94%E5%AD%97%E6%AF%8D/11058406">西里尔字母</a>、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文等字母则需要2字节编码（Unicode范围由U+0080~U+07FF）。</li>
<li>其他语言的字符（包括中日韩文字、东南亚文字、中东文字等）包含了大部分常用字，使用3字节编码。</li>
<li>其他极少使用的语言字符使用4字节编码。</li>
</ul>
</li>
</ul>
<h4 id="1-4-my-sql-zhong-de-utf-8-he-utf-8-mb-4" id="1-4、MySQL中的utf8和utf8mb4">1.4、MySQL中的utf8和utf8mb4</h4>
<ul>
<li>utf8mb3：“阉割”过的utf-8字符集，使用1~3字节表示字符</li>
<li>utf8mb4：正宗的utf-8字符集，使用1~4字节表示字符</li>
</ul>
<p>在mysql中，utf8是utf8mb3的别名，如果需要存储特殊的字符，可以使用4字符编码的utf8mb4</p>
<h4 id="1-5-my-sql-zhong-de-zi-fu-ji-he-bi-jiao-gui-ze" id="1-5、MySQL中的字符集和比较规则">1.5、MySQL中的字符集和比较规则</h4>
<h5 id="cha-kan-dang-qian-mysql-zhi-chi-de-zi-fu-ji" id="查看当前mysql支持的字符集">查看当前mysql支持的字符集</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> charset <span class="keyword">like</span> <span class="string">&#x27;utf8%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511172235587.png" alt="image-20220511172235587" /></p>
<p>Charset:字符集名称<br />
Default_collation:默认的比较规则<br />
Maxlen:最大长度,utf8字符长度为1-3所以MaxLen为3 utf8mb4字符长度1-4所以Maxlen为4</p>
<h5 id="cha-kan-dang-qian-mysql-zhong-zhi-chi-de-bi-jiao-gui-ze" id="查看当前mysql中支持的比较规则">查看当前mysql中支持的比较规则</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">collation</span> <span class="keyword">like</span> <span class="string">&#x27;utf8%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511172428267.png" alt="image-20220511172428267" /></p>
<p>Default:是否是当前字符集默认的比较规则<br />
Complied:是否将字符集编译到了server中<br />
Sortlen:与比较字符串在内存中需要的内存量有关</p>
<p>utf8_str1_str2<br />
str1代表着比较规则所使用的的语言,比如 utf8_polish_xx表示波兰语的比较规则<br />
str2代表着如何比较.<br />
通常情况下我们会使用的是utf8_general_ci与utf8_bin,前者代表着不区分大小写,后者代表着区分大小写</p>
<h5 id="zi-fu-ji-yu-bi-jiao-gui-ze-de-fen-lei" id="字符集与比较规则的分类">字符集与比较规则的分类</h5>
<p>按照应用级别可以分为服务器级别 数据库级别 表级别 列级别</p>
<p><strong>服务器级别</strong></p>
<p>字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">默认: utf8</span><br></pre></td></tr></table></figure>
<p>比较规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_server&#x27;</span>;</span><br><span class="line">默认: utf8_general_ci</span><br></pre></td></tr></table></figure>
<p><strong>数据库级别</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">默认: utf8</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_database&#x27;</span>;</span><br><span class="line">默认:utf8_general_ci</span><br></pre></td></tr></table></figure>
<p>创建数据库时指定:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database xxx [<span class="type">character</span> <span class="keyword">set</span>  <span class="string">&#x27;字符集名&#x27;</span> <span class="keyword">collate</span> <span class="string">&#x27;比较规则名称&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>表级别</strong></p>
<p>表级别没有专门变量表示<br />
创建数据表时指定:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx (xxx) [<span class="type">character</span> <span class="keyword">set</span> 字符集名 <span class="keyword">collate</span> 比较规则名称]</span><br></pre></td></tr></table></figure>
<p><strong>列级别</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx (</span><br><span class="line">id <span class="type">int</span> [<span class="type">character</span> <span class="keyword">set</span> 字符集名称] [<span class="keyword">collate</span> 比较规则名称]</span><br><span class="line">) [<span class="type">character</span> <span class="keyword">set</span>  字符集名 <span class="keyword">collate</span> 比较规则名称]</span><br></pre></td></tr></table></figure>
<p>如果列级别没有设置字符集与比较规则,则使用表的,如果表没有设置,则使用数据库的,如果数据库没有设置则使用服务器的.</p>
<p><strong>mysql通信中的字符集与比较规则</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511173659500.png" alt="image-20220511173659500" /><br />
<img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/image-20220511173739019.png" alt="image-20220511173739019" /></p>
<p><strong>character_set_client(服务端收到请求)</strong></p>
<p>此变量session级<br />
当我们用客户端与服务端通信时,<code>character_set_client</code>指的是,服务端以什么字符集去理解客户端发送过来的请求,默认是当前操作系统字符集.在当前seesion中,此变量为<code>utf8</code>,如果设置成<code>gbk</code>,会导致<code>select '我'</code>会乱码,因为服务端会把从服务端收到的以utf8编码的’我’使用gbk解码,所以会乱码,.</p>
<p><strong>character_set_connection(服务端处理请求)</strong></p>
<p>此变量session级<br />
当服务器将’我’通过character_set_client正确解码后,会按照character_set_connection进行编码,然后按照collation_connection比较规则进行比较,但是如果查询中有列比如<code>select '我'=name from aaa</code>此时会优先采用name列的字符集与比较规则进行判断</p>
<p><strong>character_set_results(服务端响应请求)</strong></p>
<p>此变量session级<br />
服务器将要响应的数据以什么格式进行编码,比如<code>select name from aaa</code> name是以utf8编码的,character_set_results是gbk编码,那么会把查询的结果以gbk编码对客户端响应</p>
<p><strong>客户端接收请求</strong></p>
<p>客户端接收响应的请求后,会以什么编码的方式显示出来,默认就是当前系统的字符集</p>
<h3 id="2-inno-db-ji-lu-cun-chu-jie-gou" id="2、InnoDB记录存储结构">2、InnoDB记录存储结构</h3>
<h4 id="2-1-inno-db-ye-jian-jie" id="2-1、InnoDB页简介">2.1、InnoDB页简介</h4>
<p>页是Innodb中磁盘和内存交互的基本单位，也是Innodb管理存储空间的基本单位，默认大小为16KB。</p>
<h4 id="2-2-inno-db-xing-ge-shi" id="2-2、InnoDB行格式">2.2、InnoDB行格式</h4>
<p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。InnoDB存储引擎设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式。</p>
<h4 id="2-3-xing-ji-lu-ge-shi-de-fen-lei-he-jie-shao" id="2-3、行记录格式的分类和介绍">2.3、行记录格式的分类和介绍</h4>
<p>在早期的InnoDB版本中，由于文件格式只有一种，因此不需要为此文件格式命名。随着InnoDB引擎的发展，开发出了不兼容早期版本的新文件格式，用于支持新的功能。为了在升级和降级情况下帮助管理系统的兼容性，以及运行不同的MySQL版本，InnoDB开始使用命名的文件格式。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b2caf96f361aa29ff2cd1bb511c638a0.png" alt="MySQL怎么从二进制内容看InnoDB行格式" /></p>
<p>在msyql 5.7.9及以后版本，默认行格式由innodb_default_row_format变量决定，它的默认值是dynamic</p>
<h4 id="2-4-xing-ge-shi" id="2-4、行格式">2.4、行格式</h4>
<h5 id="compact" id="COMPACT">COMPACT</h5>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b93590226e885d956bfd5a96887c3fd7.png" alt="MySQL怎么从二进制内容看InnoDB行格式" /></p>
<p><strong>变长字段列表</strong></p>
<p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，我们也可以把拥有这些数据类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。如果该可变字段允许存储的最大字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节记录，否则使用1个字节记录。</p>
<p>问题一：那么为什么用128作为分界线呢？ 一个字节可以最多表示255，但是MySQL设计长度表示时，为了区分是否是一个字节表示长度，规定，如果最高位为1，那么就是两个字节表示长度，否则就是一个字节。例如，01111111，这个就代表长度为127，而如果长度是128，就需要两个字节，就是10000000 10000000，首个字节的最高位为1，那么这就是两个字节表示长度的开头，第二个字节可以用所有位表示长度，并且需要注意的是，MySQL采取Little Endian的计数方式，低位在前，高位在后，所以129就是10000001 10000000。同时，这种标识方式，最大长度就是 2^15-1=32767，也就是32KB。</p>
<p>问题二：如果两个字节也不够表示的长度，该怎么办？ innoDB页大小默认为16KB，对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。这个溢出页机制参考后面的数据溢出。</p>
<p><strong>NULL值列表</strong></p>
<p>表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表。每个允许存储NULL的列对应一个二进制位，二进制位的值为1时，代表该列的值为NULL。二进制位的值为0时，代表该列的值不为NULL。</p>
<p><strong>记录头信息</strong></p>
<p>用于描述记录的记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>长度（bit）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在页的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0 表示普通记录，1 表示B+树非叶子节点记录，2 表示最小记录，3 表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<p><strong>隐藏列</strong></p>
<p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），包括：</p>
<ul>
<li>DB_ROW_ID(row_id)：非必须，6字节，表示行ID，唯一标识一条记录</li>
<li>DB_TRX_ID：必须，6字节，表示事务ID</li>
<li>DB_ROLL_PTR：必须，7字节，表示回滚指针</li>
</ul>
<p>InnoDB表对主键的生成策略是：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique 键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。</p>
<p>DB_TRX_ID（也可以称为trx_id） 和DB_ROLL_PTR（也可以称为roll_ptr） 这两个列是必有的，但是row_id是可选的（在没有自定义主键以及Unique 键的情况下才会添加该列）。</p>
<p>其他的行格式和Compact行格式差别不大。</p>
<h5 id="redundant-xing-ge-shi" id="Redundant行格式">Redundant行格式</h5>
<p>Redundant行格式是MySQL5.0之前用的一种行格式，不予深究。</p>
<h5 id="dynamic-xing-ge-shi" id="Dynamic行格式">Dynamic行格式</h5>
<p>MySQL5.7的默认行格式就是Dynamic，Dynamic行格式和Compact行格式挺像，只不过在处理行溢出数据时有所不同。</p>
<h5 id="compressed-xing-ge-shi" id="Compressed行格式">Compressed行格式</h5>
<p>Compressed行格式在Dynamic行格式的基础上会采用压缩算法对页面进行压缩，以节省空间。以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度数据能够进行有效的存储（减少40%，但对CPU要求更高）。</p>
<h5 id="shu-ju-yi-chu" id="数据溢出">数据溢出</h5>
<p>如果我们定义一个表，表中只有一个VARCHAR字段，如下：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">CREATE</span> <span class="variable">TABLE</span> <span class="function"><span class="title">test_varchar</span>( <span class="variable">c</span> <span class="title">VARCHAR</span>(<span class="number">60000</span>))</span></span><br></pre></td></tr></table></figure>
<p>然后往这个字段插入60000个字符，会发生什么？前边说过，MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的情况。</p>
<p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的该列的前768个字节的数据，然后把剩余的数据分散存储在几个其他的页中，记录的真实数据处用20个字节（768字节后20个字节）存储指向这些页的地址。这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。</p>
<p>Dynamic和Compressed行格式，不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p>
<h3 id="3-inno-db-de-shu-ju-ye" id="3、InnoDB的数据页">3、InnoDB的数据页</h3>
<h4 id="3-1-gai-nian-amp-fen-lei" id="3-1-概念-分类">3.1 概念&amp;分类</h4>
<h5 id="strong-gai-nian-strong" id="概念"><strong>概念</strong></h5>
<p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB，查看命令如下（单位是字节）：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; show status like &#x27;innodb_page_size&#x27;;</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name    | Value |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Innodb_page_size | 16384 |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以把「页」理解为一个容器，这个容器是用来存储「记录」的。</p>
<h5 id="strong-fen-lei-strong" id="分类"><strong>分类</strong></h5>
<p>值得注意的是，InnoDB 中的「页」并非只有一种，比如有存放 Insert Buffer 的页、存放 undo log 的页、存放数据的页等等。其中我们最关注的还是存放我们表数据的页，又称「索引页」，或者数据页。</p>
<p>下面分析和介绍数据页。</p>
<h4 id="3-2-shu-ju-ye-jie-gou" id="3-2-数据页结构">3.2 数据页结构</h4>
<h5 id="strong-gai-shu-strong" id="概述"><strong>概述</strong></h5>
<p>InnoDB 数据页的结构如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-c5c9a86badc7f63ef4aa8cbf737e18cb_720w.jpg" alt="img" /></p>
<p>它由七部分构成，简介如下：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-62671ca47bbd785000cd4fbdfd5b52e8_720w.jpg" alt="img" /></p>
<h5 id="strong-ji-lu-cha-ru-guo-cheng-strong" id="记录插入过程"><strong>记录插入过程</strong></h5>
<p>在数据页中，当记录为空时，User Records 是不存在的。随着记录的一条条插入，会不断从 Free Space 开辟空间分配给记录，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-f0e154fa8e3f1b18d9d7650223735763_720w.jpg" alt="img" /></p>
<h5 id="strong-ye-jie-gou-fen-xi-strong" id="页结构分析"><strong>页结构分析</strong></h5>
<p><strong>记录头信息</strong></p>
<p>为便于描述记录是如何在页中存储的，这里先贴一下前文提到的记录头信息：</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-dab1c35a4ec043e0528b7f965ba58e39_720w.jpg" alt="img" /></p>
<p>它们的各个部分说明如下：</p>
<ul>
<li>
<p>前两个预留位：暂无用处（各占 1 位）</p>
</li>
<li>
<p>delete_mask：1 位，标记该条记录是否被删除</p>
</li>
<li>
<p>min_rec_mask：1位，B+树每层非叶子节点中的最小记录都会添加该标记</p>
</li>
<li>
<p>n_owned：4 位，当前记录拥有的记录数</p>
</li>
<li>
<p>heap_no：13 位，当前记录在记录堆的位置</p>
</li>
<li>
<p>record_type：3 位，记录的类型</p>
</li>
<li>
<p>0：普通记录•  1：B+ 树非叶子节点（后文再介绍，暂时略过）•  2：最小记录•  3：最大记录</p>
</li>
<li>
<p>next_record：16 位，保存下一条记录的相对位置</p>
</li>
<li>
<p>Infimum + Supremum</p>
</li>
</ul>
<p>这部分存储的是固定的两条记录，分别为数据页中的「最小记录」和「最大记录」，如图所示：</p>
<p><img data-src="https://pic2.zhimg.com/80/v2-14d15dc7eee612a0c2ade452a443dd99_720w.jpg" alt="img" /></p>
<p>PS: 由于这两条记录不是我们自定义的，因此不存储在 User Records 空间。</p>
<p><strong>Free Space</strong></p>
<p>空闲空间，数据页中尚未使用的部分。</p>
<p><strong>User Records</strong></p>
<p>用户记录，这里就是存储我们记录的地方。</p>
<p>上面的「最小记录」和「最大记录」是如何跟我们的记录关联起来的呢？</p>
<p>这时候 next_record 的作用就体现出来了。这两条记录和我们自定义的记录之间是通过 next_record 关联起来的，自定义的记录之间也是通过 next_record 关联起来的，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-4ab3fd1b95109efb9b32f838e3570b26_720w.jpg" alt="img" /></p>
<p>即，「最小记录」的 next_record 指向第一条数据记录，最后一条数据记录的 next_record 指向「最大记录」。数据记录之间是按照主键的顺序从小到大排序的。</p>
<p>PS: 此处的 (1,100,‘aaaa’), (2,200,‘bbbb’) 等几条内容是自定义的数据。<br />
记录中的蓝色部分为额外信息，橙色部分为记录数据。</p>
<p><strong>Page Directory</strong></p>
<p>上面是以 4 条记录举例的，如果要查找其中一条，即使遍历也不会很耗时。但是，如果记录数量一直增加，比如到一千条、一万条甚至更多（假设一个数据页能存的下），我们如何去查找其中的一条记录呢？这样再去遍历岂不是很笨？</p>
<p>就像我们从一本书里找某些内容，当只有几页的时候很容易就能找到；但如果有好几百页，总不能一页一页去翻吧？</p>
<p>我们通常是先查找目录，找到在哪一页，然后直接翻到那一页。页目录的作用跟书的目录差不多。</p>
<p>由于记录之间是按主键排序的，可以把它们从小到大分成一个个的「组」，每组包含很少的几条记录，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-5c5f873aa349954a66f580866d184b40_720w.jpg" alt="img" /></p>
<p>分组规则大致如下：</p>
<ul>
<li>「最小记录」自成一组</li>
<li>包含「最大记录」的组一般为 1~8 条记录</li>
<li>其它记录一般是 4~8 条分为一组</li>
</ul>
<p>分组之后，把每组中最大的那条记录的地址偏移量提出来，按顺序存储起来，这些地址偏移量称为槽（Slot），而这些槽就组成了页目录（Page Directory）。就像是给一本书做了目录。</p>
<p>目录有了，怎么使用呢？</p>
<p>此时如果要查找一条记录，步骤大致如下：</p>
<p>1、由于页目录中的槽是有序的，因此可以用「二分法」快速定位到一个槽；</p>
<p>2、找到该槽所在分组中主键值最小的记录；</p>
<p>3、通过 next_record 遍历组中的记录。</p>
<p>这样就比遍历所有的记录快得多了吧！</p>
<p><strong>Page Header</strong></p>
<p>页头部，主要记录数据页的一些信息，比如本页存了多少条记录、页目录中有多少个槽等等。</p>
<p><strong>File Header</strong></p>
<p>页头部存的是一个数据页的概要信息，是一个页专有的，而文件头存的是各种页通用的信息，比如页的类型是什么、页的编号是多少、上一页的页号是多少、下一页的页号是多少等等。</p>
<p>既然有上一页、下一页的定义，说明页与页之间其实是互相连接的，它们之间就像一个双向链表（比如 Java 的 LinkedList）那样，如图所示：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/v2-983d6442b506e0c37e397115158071c6_720w.jpg" alt="img" /></p>
<p><strong>File Trailer</strong></p>
<p>文件尾，主要用于校验一个页是不是完整的。</p>
<h3 id="4-b-shu-suo-yin" id="4、B-树索引">4、B+树索引</h3>
<p>InnoDB存储引擎的是一颗B+树，完整的用户记录都存储在B+树第0层的叶子节点；其他层次的 节点都属于内节点，内节点中存储的是目录项记录。</p>
<p>InnoDB的索引分为两种。</p>
<ul>
<li>聚簇索引：以主键值的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列。</li>
<li>二级索引：以索引列的大小作为页和记录的排序规则，在叶子节点处存储的记录内容是索引列+主键。</li>
</ul>
<p>InnoDB存储引擎的B+树根节点自创建之日就不再移动。</p>
<p>在二级索引的B+树内节点中，目录项记录由索引列的值，主键值和页号组成。</p>
<p>一个数据页至少可以容纳2条记录。</p>
<p>MyISAM存储引擎的数据和索引分开存储，这种存储引擎的索引全部都是二级索引，在叶子节点处存储的是列+行号。</p>
<h3 id="5-b-shu-suo-yin-de-shi-yong" id="5、B-树索引的使用">5、B+树索引的使用</h3>
<p><a href='http://t.csdn.cn/VkLnf '>MySQL中B+树索引的应用场景大全</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC入门</title>
    <url>/posts/41575.html</url>
    <content><![CDATA[<p>在 gRPC 中，客户端应用程序可以直接调用另一台计算机上的服务器应用程序上的方法，就好像它是本地对象一样，从而使您可以更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以使用其参数和返回类型远程调用的方法。在服务器端，服务器实现此接口并运行 gRPC 服务器来处理客户端调用。在客户端，客户端有一个存根，该存根提供与服务器相同的方法。</p>
<span id="more"></span>
<h3 id="yi-jian-jie" id="一、简介">一、简介</h3>
<p>在 gRPC 中，客户端应用程序可以直接调用另一台计算机上的服务器应用程序上的方法，就好像它是本地对象一样，从而使您可以更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以使用其参数和返回类型远程调用的方法。在服务器端，服务器实现此接口并运行 gRPC 服务器来处理客户端调用。在客户端，客户端有一个存根，该存根提供与服务器相同的方法。</p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:800px; height:500px;" src="https://www.processon.com/embed/62f620f1e0b34d075574d809"></iframe>
<h3 id="er-te-xing" id="二、特性">二、特性</h3>
<h4 id="1-ji-yu-http-2" id="1、基于HTTP-2">1、基于HTTP/2</h4>
<p>HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。</p>
<h4 id="2-idl-shi-yong-proto-buf" id="2、IDL使用ProtoBuf">2、IDL使用ProtoBuf</h4>
<p>gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。</p>
<h4 id="3-duo-yu-yan-zhi-chi" id="3、多语言支持">3、多语言支持</h4>
<p>gRPC支持多种语言（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java），并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。</p>
<h4 id="4-g-rpc-you-que-dian" id="4、gRPC优缺点">4、gRPC优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>protobuf二进制消息，性能好/效率高（空间和时间效率都很不错）</li>
<li>proto文件生成目标代码，简单易用</li>
<li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)</li>
<li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li>
<li>支持多种语言（可以把proto文件看做IDL文件）</li>
<li>Netty等一些框架集成</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>GRPC尚未提供连接池，需要自行实现</li>
<li>尚未提供“服务发现”、“负载均衡”机制</li>
<li>因为基于HTTP2，绝大部多数HTTP Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持）</li>
<li>Protobuf二进制可读性差（貌似提供了Text_Fromat功能）<br />
默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li>
</ul>
<h3 id="er-protocol-buffers" id="二、Protocol-Buffers">二、Protocol Buffers</h3>
<p>protobuf 是 Google 公司内部的混合语言数据标准，默认情况下，grpc使用的就是protobuf。你可以理解Protocol Buffers是一种更加灵活、高效的数据格式，与XML、JSON类似，在一些高性能且对响应速度有要求的数据传输场景非常适用。</p>
<blockquote>
<p>目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <strong>RPC 数据交换格式</strong>。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API（即时通讯网注：Protobuf官方工程主页上显示的已支持的开发语言多达10种，分别有：C++、Java、Python、Objective-C、C#、JavaNano、JavaScript、Ruby、Go、PHP，基本上主流的语言都已支持，详见工程主页：<a href="https://link.zhihu.com/?target=https%3A//github.com/52im/protobuf">https://github.com/52im/protobuf</a>）。</p>
</blockquote>
<p><strong>在RPC框架中的作用：</strong></p>
<ul>
<li>定义数据结构</li>
<li>定义服务接口</li>
<li>通过序列化和反序列化，提升传输效率</li>
</ul>
<h4 id="1-ru-he-shi-yong-ta" id="1、如何使用它">1、如何使用它</h4>
<ul>
<li>
<p>在后缀为.proto文件中定义数据结构（被远程调用服务的接口文档）</p>
<ul>
<li>
<pre><code>//使用的版本号
syntax = &quot;proto3&quot;;
option go_package = &quot;../proto;client&quot;;
option java_multiple_files = true;
option java_package=&quot;com.example.grpcexample.helloworld&quot;;
//请求
message Request &#123;
    double num1 = 1;
    double num2 = 2;
    OperateType opType = 3;
&#125;
//枚举类
enum OperateType &#123;
    Addition = 0;
    Division = 1;
    Multiplication = 2;
    Subtraction = 3;
&#125;
//响应
message Response &#123;
    double result = 1;
&#125;

//定义服务
service Operate &#123;
	//一元RPC
    rpc Calculate (Request) returns (Response);
    
    //服务器流式 RPC
    rpc Calculate (Request) returns (stream Response);
    
    //客户端流式RPC
    rpc Calculate (stream Request) returns (Response);
    
    //双向流式RPC
    rpc Calculate (stream Request) returns (Response);
    
&#125;
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * 四种服务类型介绍(消息传输)</span><br><span class="line"></span><br><span class="line">    * 一元RPC（请求响应式）：其中客户端向服务器发送单个请求并获取单个响应，就像普通的函数调用一样。</span><br><span class="line">    * 服务器流式处理 RPC：其中客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息。gRPC 保证单个 RPC 调用中的消息排序。</span><br><span class="line">    * 客户端流式处理 RPC：其中客户端写入一系列消息并将其发送到服务器，再次使用提供的流。客户端完成写入消息后，它将等待服务器读取这些消息并返回其响应。同样，gRPC 保证单个 RPC 调用中的消息排序。</span><br><span class="line">    * 双向流式处理 RPC：其中双方都使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照它们喜欢的任何顺序进行读取和写入：例如，服务器可以等待接收所有客户端消息，然后再写入其响应，或者它可以交替读取消息然后写入消息，或者其他一些读取和写入的组合。将保留每个流中消息的顺序。</span><br><span class="line"></span><br><span class="line">    &lt;iframe <span class="attribute">id</span>=<span class="string">&quot;embed_dom&quot;</span> <span class="attribute">name</span>=<span class="string">&quot;embed_dom&quot;</span> <span class="attribute">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attribute">style</span>=<span class="string">&quot;display:block;width:800px; height:800px;&quot;</span> <span class="attribute">src</span>=<span class="string">&quot;https://www.processon.com/embed/62f64a287d9c08072f9d6743&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">* 第二步，根据服务端（服务提供者）和客户端（服务调用者）语言类型，生成相应的代码，然后再实现/调用方法。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 三、案例(一元rpc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 1、用Java写客户端，Go写服务端</span></span><br><span class="line"></span><br><span class="line">**编写protobuf文件**</span><br><span class="line"></span><br><span class="line">helloworld.proto</span><br><span class="line"></span><br><span class="line">```protobuf</span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">option go_package = <span class="string">&quot;../proto;helloworld&quot;</span>;</span><br><span class="line">option java_multiple_files = <span class="literal">true</span>;</span><br><span class="line">option <span class="attribute">java_package</span>=<span class="string">&quot;com.example.grpc_study.proto&quot;</span>;</span><br><span class="line">message Request&#123;</span><br><span class="line">	string <span class="attribute">source</span>=1;</span><br><span class="line">	string <span class="attribute">language</span>=2;</span><br><span class="line">&#125;</span><br><span class="line">message Response &#123;</span><br><span class="line">	string <span class="attribute">source</span>=1;</span><br><span class="line">	string <span class="attribute">language</span>=2;</span><br><span class="line">&#125;<span class="built_in"></span></span><br><span class="line"><span class="built_in">service </span>HelloWorld &#123;</span><br><span class="line">	rpc TestRpc(Request) returns (Response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>编写Go服务端</strong></p>
<ul>
<li>
<p>安装grpc：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> -u google.golang.org/grpc</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装编译proto文件的插件</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/golang/protobuf/proto</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在proto文件目录中执行命令，生成代码</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">protoc -I . <span class="attribute">--go_out</span>=plugins=grpc:. helloworld.proto</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;grpc_study/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server)</span></span> TestRpc(ctx context.Context,req *helloworld.Request)(*helloworld.Response,<span class="type">error</span>)&#123;</span><br><span class="line">	source:=req.Source</span><br><span class="line">	language:=req.Language</span><br><span class="line">	fmt.Printf(<span class="string">&quot;接收到来自%s%s的请求&quot;</span>,language,source)</span><br><span class="line">	<span class="keyword">return</span> &amp;helloworld.Response&#123;Source:<span class="string">&quot;服务端&quot;</span>,Language:<span class="string">&quot;Go&quot;</span>&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	helloworld.RegisterHelloWorldServer(s,&amp;server&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动服务端：go run server.go</p>
</li>
</ul>
<p><strong>编写Java客户端</strong></p>
<ul>
<li>
<p>创建SpringBoot项目</p>
</li>
<li>
<p>配置maven</p>
<ul>
<li>
<pre><code class="language-xml">&lt;!--    GRPC    --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.devh&lt;/groupId&gt;
    &lt;artifactId&gt;grpc-server-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.13.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--    插件    --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;0.5.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;protocArtifact&gt;com.google.protobuf:protoc:3.7.1:exe:$&#123;os.detected.classifier&#125;&lt;/protocArtifact&gt;
        &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;
        &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.20.0:exe:$&#123;os.detected.classifier&#125;&lt;/pluginArtifact&gt;
        &lt;outputDirectory&gt;$&#123;project.build.sourceDirectory&#125;&lt;/outputDirectory&gt;
        &lt;!--设置是否在生成java文件之前清空outputDirectory的文件，默认值为true，设置为false时也会覆盖同名文件--&gt;
        &lt;clearOutputDirectory&gt;false&lt;/clearOutputDirectory&gt;
        &lt;!--更多配置信息可以查看https://www.xolstice.org/protobuf-maven-plugin/compile-mojo.html--&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;compile&lt;/goal&gt;
                &lt;goal&gt;compile-custom&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">* </span>在java的同级目录创建proto文件夹，并将其标记为Sources Root<span class="operator"></span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">* </span>在proto目录中创建helloworld.proto，内容go服务端内容一样<span class="operator"></span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">* </span>执行：mvn clean install，生成代码<span class="operator"></span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">* </span>创建Client类</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public <span class="keyword">class</span> Client &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">private</span> final ManagedChannel channel;</span><br><span class="line">  	<span class="keyword">private</span> final HelloWorldGrpc.HelloWorldBlockingStub blockingStub;</span><br><span class="line">  	<span class="keyword">private</span> <span class="constructor">Client(ManagedChannel <span class="params">channel</span>)</span> &#123;</span><br><span class="line">  		this.channel = channel;</span><br><span class="line">  		blockingStub = <span class="module-access"><span class="module"><span class="identifier">HelloWorldGrpc</span>.</span></span><span class="keyword">new</span><span class="constructor">BlockingStub(<span class="params">channel</span>)</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	public <span class="constructor">Client(String <span class="params">host</span>, <span class="params">int</span> <span class="params">port</span>)</span> &#123;</span><br><span class="line">  		this(<span class="module-access"><span class="module"><span class="identifier">ManagedChannelBuilder</span>.</span></span><span class="keyword">for</span><span class="constructor">Address(<span class="params">host</span>, <span class="params">port</span>)</span></span><br><span class="line">  				.use<span class="constructor">Plaintext()</span></span><br><span class="line">  				.build<span class="literal">()</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  	public void shutdown<span class="literal">()</span> throws InterruptedException &#123;</span><br><span class="line">  		channel.shutdown<span class="literal">()</span>.await<span class="constructor">Termination(5, TimeUnit.SECONDS)</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">  		<span class="keyword">try</span> &#123;</span><br><span class="line">  			Client service = <span class="keyword">new</span> <span class="constructor">Client(<span class="string">&quot;localhost&quot;</span>, 9090)</span>;</span><br><span class="line">  			Request request=<span class="module-access"><span class="module"><span class="identifier">Request</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span>.set<span class="constructor">Language(<span class="string">&quot;Java&quot;</span>)</span>.set<span class="constructor">Source(<span class="string">&quot;客户端&quot;</span>)</span>.build<span class="literal">()</span>;</span><br><span class="line">  			Response response = service.blockingStub.test<span class="constructor">Rpc(<span class="params">request</span>)</span>;</span><br><span class="line">  			<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;服务调用成功，接收到来自&quot;</span>+response.get<span class="constructor">Language()</span>+response.get<span class="constructor">Source()</span>+<span class="string">&quot;的响应&quot;</span>);</span><br><span class="line">  			service.shutdown<span class="literal">()</span>;</span><br><span class="line">  		&#125; catch (Exception e) &#123;</span><br><span class="line">  			<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(e);</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>启动服务端，再启动客户端</strong></p>
<h4 id="2-yong-go-xie-ke-hu-duan-java-xie-fu-wu-duan" id="2、用Go写客户端，Java写服务端">2、用Go写客户端，Java写服务端</h4>
<p><strong>编写服务端</strong></p>
<p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GrpcService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">extends</span> <span class="title class_">HelloWorldGrpc</span>.HelloWorldImplBase &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRpc</span><span class="params">(Request request, StreamObserver&lt;Response&gt; streamObserver)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;接收到来自&quot;</span>+request.getLanguage()+request.getSource()+<span class="string">&quot;的请求&quot;</span>);</span><br><span class="line">		streamObserver.onNext(Response.newBuilder().setLanguage(<span class="string">&quot;Java&quot;</span>).setSource(<span class="string">&quot;服务端&quot;</span>).build());</span><br><span class="line">		streamObserver.onCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动SpringBoot应用，grpc服务默认启动的是9090端口</p>
<p><strong>编写客户端</strong></p>
<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;grpc_study/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:9090&quot;</span>, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;grpc Dial error&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client := helloworld.NewHelloWorldClient(conn)</span><br><span class="line">    rep, err := client.TestRpc(context.TODO(), &amp;helloworld.Request&#123;Source:<span class="string">&quot;客户端&quot;</span>,Language:<span class="string">&quot;Go&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;服务调用成功,收到来自：%s%s的响应&quot;</span>, rep.Language,rep.Source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>启动服务端，再启动客户端</strong></p>
<h3 id="si-protobuf-wen-jian-yu-fa" id="四、protobuf文件语法">四、protobuf文件语法</h3>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用的版本号</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">//生成go代码的位置，及包名</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;../proto;helloworld&quot;</span>;</span><br><span class="line"><span class="comment">//生成java代码，是否选择多文件</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//生成java代码的路径</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.example.grpc_study.proto&quot;</span>;</span><br><span class="line"><span class="comment">//消息体，1，2为字段标签，用于序列化</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span>&#123;</span><br><span class="line">	<span class="type">string</span> source=<span class="number">1</span>;</span><br><span class="line">	<span class="type">string</span> language=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">	<span class="type">string</span> source=<span class="number">1</span>;</span><br><span class="line">	<span class="type">string</span> language=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务名</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="comment">//TestRpc服务端提供的方法名</span></span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> TestRpc(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-import" id="1、import">1、import</h4>
<p>用来引入其他文件的内容</p>
<p>格式：import “/xxx路径”，路径是从protoc这个命令的当前目录开始算起</p>
<h4 id="2-message" id="2、message">2、message</h4>
<blockquote>
<p>在protobuf中用来定义消息类型的关键字</p>
</blockquote>
<p><strong>格式</strong></p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">message 参数名称&#123;</span><br><span class="line">	修饰符 数据类型 字段名<span class="built_in">=</span>标签;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符：</p>
<ul>
<li>Required: 表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值，对于接收方，必须能够识别该字段的意思。发送之前没有设置required字段或者无法识别required字段都会引发编解码异常，导致消息被丢弃。</li>
<li>Optional：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。—因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。</li>
<li>Repeated：表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值。</li>
</ul>
<p>数据类型：</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202208131444544.png" alt="在这里插入图片描述" /></p>
<ul>
<li>
<p>默认值</p>
<ul>
<li><code>string</code>类型,默认值是空字符串,注意不是null</li>
<li><code>bytes</code>类型,默认值是空bytes</li>
<li><code>bool</code>类型，默认值是false</li>
<li><code>数字</code>类型,默认值是0</li>
<li><code>枚举</code>类型,默认值是第一个枚举值,即0</li>
<li><code>repeated</code>修饰的属性，默认值是空（在相对应的编程语言中通常是一个空的list）.</li>
</ul>
</li>
<li>
<p>Any类型，类似于Java的Object</p>
<ul>
<li>
<pre><code>如果使用any类型，需要导入：google/protobuf/any.proto

import &quot;google/protobuf/any.proto&quot;;

message Response &#123;
	string msg = 1;
	int32 code = 2;
	google.protobuf.Any data = 3; //可以理解成Object
	repeated google.protobuf.Any datas = 4; //可以理解成泛型 List&lt;T&gt; datas;
&#125;
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">标签：</span><br><span class="line"></span><br><span class="line">* 该标签的取值范围为 <span class="number">1</span>~<span class="number">2</span>^<span class="number">32</span>（<span class="number">4294967296</span>），其中 <span class="number">1</span>~<span class="number">15</span>的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低（相对于<span class="number">1</span>-<span class="number">15</span>），当然一般情况下相邻的<span class="number">2</span>个值编码效率的是相同的，除非<span class="number">2</span>个值恰好实在<span class="number">4</span>字节，<span class="number">12</span>字节，<span class="number">20</span>字节等的临界区。比如<span class="number">15</span>和<span class="number">16</span>。<span class="number">1900</span>~<span class="number">2000</span>编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用。</span><br><span class="line">* 当两个字段标签一致时，其修饰符和数据类型也必须相同</span><br><span class="line">* 消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值。</span><br><span class="line">* 建议：项目投入运营以后涉及到版本升级时的新增消息字段全部使用<span class="keyword">optional</span>或者<span class="keyword">repeated</span>，尽量不使用<span class="keyword">required</span>。如果使用了<span class="keyword">required</span>，需要全网统一升级，如果使用<span class="keyword">optional</span>或者<span class="keyword">repeated</span>可以平滑升级。</span><br><span class="line"></span><br><span class="line">**用法**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>//普通的消息类型<br />
message Person {<br />
string name=1;<br />
}<br />
//嵌套消息，无层级限制<br />
message Person {<br />
string name=1;<br />
message Man{<br />
string name =1;<br />
}<br />
repeated Man man=2;<br />
}<br />
message Student{<br />
Person.Man man=1;<br />
}</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">3</span>、enum</span><br><span class="line"></span><br><span class="line">**格式**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>enum 标识符 {<br />
字段名=0;<br />
字段名1=1;<br />
}</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">4</span>、service</span><br><span class="line"></span><br><span class="line">**格式**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>service 服务名 {<br />
rpc 方法名(请求消息) returns (响应消息);<br />
rpc 方法名(stream 请求消息) returns (响应消息);<br />
rpc 方法名(请求消息) returns (stream 响应消息);<br />
rpc 方法名(stream 请求消息) returns (stream 响应消息);<br />
}</p>
<pre><code>


### 五、讨论

#### 1、和其他RPC框架相比，gRPC的优势？

* 跨语言，且自动生成代码
* 性能高，比如protobuf性能高过json, 比如http2.0性能高过http1.1
* 生态好
* 流式处理（基于http2.0）：支持客户端流式，服务端流式，双向流式

#### 2、还有其他的跨语言的RPC吗，gRPC在跨语言RPC框架中是最好的吗？

* Thrift是一种可伸缩的跨语言服务的RPC软件框架。它结合了功能强大的软件堆栈的代码生成引擎，以建设服务，高效、无缝地在多种语言间结合使用

</code></pre>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞定前后端项目部署</title>
    <url>/posts/30975.html</url>
    <content><![CDATA[<h3 id="linux-chang-yong-ming-ling" id="Linux常用命令：">Linux常用命令：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lsof -i:<span class="number">8090</span> <span class="comment">//查看端口是否被占用</span></span><br><span class="line">kill -s <span class="number">9</span> pid <span class="comment">//杀死进程</span></span><br><span class="line">jps <span class="comment">//查看启动的java应用进程</span></span><br><span class="line">scp -P <span class="number">22</span>（服务器端口号） smpe-system-<span class="number">1.0</span><span class="number">.0</span>-RELEASE.jar  root<span class="meta">@ip</span>地址:/data/nginx/www/cloudsafe/cloudsafe_server（服务器中文件夹的绝对路径） </span><br><span class="line"><span class="comment">//远程复制，将本地的xx.jar， 上传到服务器的xxxx/cloudsafe_server文件夹，注：（）为解释，执行时自行删除，此命令是在jar的所在目录下执行的。</span></span><br><span class="line"></span><br><span class="line">docker exec -it a4f598cc4268（容器id） mysqldump -uroot -p*********（数据库密码） --opt research_keyuan（数据库名称） &gt; /root/mysql_file_backup/mysqlbakup_research_keyuan.sql  （用来保存sql文件的路径及文件名）</span><br><span class="line"><span class="comment">//此命令用来备份docker中的mysql数据库sql文件</span></span><br><span class="line"></span><br><span class="line">docker exec -i a4f598cc4268（容器id） mysql -uroot -p*****（数据库密码） research_keyuan &lt; /root/mysql_file_backup/xxxx.sql</span><br><span class="line"><span class="comment">//此命令是用来将sql文件导入到docker中的mysql容器的mysql的指定数据库</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="huan-jing-zhun-bei" id="环境准备">环境准备</h3>
<p>下面的环境只适用于Centos 7.x</p>
<h4 id="docker" id="Docker">Docker</h4>
<p>添加yum源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum update <span class="comment">//检查更新</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y <span class="comment">//添加yum的软件仓库</span></span><br></pre></td></tr></table></figure>
<p>安装docker</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> docker-io -y</span><br></pre></td></tr></table></figure>
<p>运行docker</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>
<p>检查安装结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>停止docker</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<p>docker的常用命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull xxx <span class="comment">//拉取应用镜,如拉取nginx镜像：docker pull nginx</span></span><br><span class="line">docker images <span class="comment">//查看已有镜像</span></span><br><span class="line">docker rmi 镜像id <span class="comment">//删除镜像</span></span><br><span class="line">docker ps <span class="comment">//查看启动的容器</span></span><br><span class="line">docker ps -a <span class="comment">//查看容器，包含了未启动的容器</span></span><br><span class="line">docker stop 容器id <span class="comment">//停止容器</span></span><br><span class="line">docker rm 容器id <span class="comment">//删除容器，需要停止容器</span></span><br><span class="line">docker exec -it 容器id/名称 bash <span class="comment">//进入容器内部</span></span><br><span class="line">docker inspect 容器id/名称 | grep Mounts -A <span class="number">20</span> <span class="comment">//查看容器与服务器的映射目录</span></span><br><span class="line">docker inspect 容器id/名称 | grep IPAddress <span class="comment">//查看容器的ip地址</span></span><br></pre></td></tr></table></figure>
<p>下面需要安装一些公共服务如：mysql ,redis, nginx</p>
<p>两种方案：在docker中安装，在服务器中直接安装，两种方式都可，建议选择一种，仁者见仁吧，根据方式不一样，后端的部署也会有些细微变动。</p>
<h4 id="yi-docker-an-zhuang-ge-chong-fu-wu" id="一、Docker安装各种服务">一、Docker安装各种服务</h4>
<h5 id="docker-an-zhuang-mysql" id="Docker-安装mysql">Docker 安装mysql</h5>
<p>安装</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker pull mysql <span class="regexp">//</span>后面不加版本号，默认最高版本</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -itd --name mysql-test -p <span class="number">3307</span>:<span class="number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> mysql</span><br></pre></td></tr></table></figure>
<ul>
<li>参数说明：
<ul>
<li>*<em>-p 3306:3307</em> ：映射容器的 3306端口到宿主机的 3307 端口，外部主机可以直接通过 <strong>宿主机ip:3307</strong> 访问到 MySQL 的服务。</li>
<li><strong>MYSQL_ROOT_PASSWORD=123456</strong>：设置 MySQL 服务 root 用户的密码。</li>
<li>注：启动后，如果需要远程访问，需要开启服务器的相应端口号</li>
</ul>
</li>
</ul>
<p>检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker ps <span class="comment">//查看是否安装成功</span></span><br></pre></td></tr></table></figure>
<h5 id="docker-an-zhuang-redis" id="Docker-安装Redis">Docker 安装Redis</h5>
<p>安装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p <span class="number">6379</span>:<span class="number">6379</span> -d --restart=always redis redis-server --appendonly yes --requirepass <span class="string">&quot;这是密码&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数说明
<ul>
<li>-p 6379:6379 端口映射：前表示服务器的端口，：后表示容器的端口。</li>
<li>–name myredis  指定该容器名称，查看和进行操作都比较方便。</li>
<li>-d redis 表示后台启动redis</li>
<li>appendonly yes 开启redis 持久化</li>
</ul>
</li>
</ul>
<h5 id="docker-an-zhuang-nginx" id="Docker-安装nginx">Docker 安装nginx</h5>
<p>由于内容有点多，都记录到此篇博客中<a href="https://blog.csdn.net/weixin_44932487/article/details/117193191?ops_request_misc=%7B%22request%5Fid%22%3A%22163628310816780265462295%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=163628310816780265462295&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-117193191.pc_v2_rank_blog_default&amp;utm_term=docker&amp;spm=1018.2226.3001.4450">基于Docker使用Nginx</a></p>
<h4 id="er-fu-wu-qi-an-zhuang-ge-chong-fu-wu" id="二、服务器安装各种服务">二、服务器安装各种服务</h4>
<p>服务器中，我是采用yum源来安装各种服务，这种方式比较简单（强烈推荐）</p>
<h5 id="yum-an-zhuang-mysql" id="yum安装Mysql">yum安装Mysql</h5>
<p>1、检查系统是否安装有mysql</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum list installed mysql*</span><br><span class="line">rpm -qa | grep mysql*</span><br></pre></td></tr></table></figure>
<p>2、安装客户端</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mysql</span><br></pre></td></tr></table></figure>
<p>3、安装服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line">注：可能提示为安装失败</span><br><span class="line">原因：CentOS7自带有MariaDB而不是MySQL，MariaDB和MySQL一样也是开元的数据库</span><br><span class="line">解决方案：如果必须要安装MySQL，首先必须添加mysql社区repo通过输入命令：</span><br><span class="line">sudo rpm -Uvh http:<span class="comment">//dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span></span><br><span class="line"><span class="comment">//执行后， 继续执行</span></span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure>
<p>4、执行</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mysql-devel</span><br></pre></td></tr></table></figure>
<p>5、配置数据库</p>
<p>vim /etc/my.cnf</p>
<p>在配置文件中加入默认字符集：</p>
<p>default-character-set=uft-8</p>
<p>6、启动或关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[root<span class="meta">@localhost</span> ~]#service mysqld start      --启动mysql[root<span class="meta">@localhost</span> ~]#service mysqld stop       --关闭mysql</span><br><span class="line">[root<span class="meta">@localhost</span> ~]#lsof -i:<span class="number">3306</span>              --数据库端口是否开启</span><br></pre></td></tr></table></figure>
<p>7、设置开机启动mysql服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">chkconfig --<span class="built_in">add</span> mysqld</span><br></pre></td></tr></table></figure>
<p>8、创建root管理员</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysqladmin</span> -u root password 密码</span><br></pre></td></tr></table></figure>
<p>9、进入mysql设置远程访问</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">//依次执行</span><br><span class="line">mysql -u root -p</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="symbol">`Host`</span> = <span class="string">&#x27;%&#x27;</span> <span class="keyword">WHERE</span> <span class="symbol">`User`</span> = <span class="string">&#x27;root&#x27;</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>10、在服务器的控制台中防火墙，将数据库端口打开（安全组规则中添加3306端口）</p>
<h5 id="yum-an-zhuang-redis" id="yum安装redis">yum安装redis</h5>
<p>1、yum install redis</p>
<p>2、yum isntall epel-release</p>
<p>3、启动服务</p>
<p>systemctl start redis</p>
<p>4、查看状态</p>
<p>systemctl status redis</p>
<p>5、停止服务</p>
<p>systemctl stop redis</p>
<p>6、重启服务</p>
<p>systemctl restart redis</p>
<p>7、查看redis进程</p>
<p>ps -ef | grep redis</p>
<p>8、设置开机自启动</p>
<p>systemctl enable redis</p>
<p>9、设置远程连接</p>
<p>进入配置文件</p>
<p>vi /etc/redis.conf</p>
<p>注释bind 127.0.0.1</p>
<p>设置protected-mode no</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071933559.png" alt="img" /></p>
<p>修改密码为111111</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111071934861.png" alt="img" /></p>
<p>10、保存并退出编辑重启redis</p>
<p>systemctl restart redis</p>
<p>11、在服务器的控制台的安全组规则，开放redis端口号6379</p>
<h5 id="yum-an-zhuang-git" id="yum-安装git">yum 安装git</h5>
<p>1、安装</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure>
<p>2、配置</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置用户名称和登录邮箱</span></span><br><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.name</span> <span class="string">&#x27;用户名&#x27;</span></span><br><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.email</span> <span class="string">&#x27;邮箱&#x27;</span></span><br></pre></td></tr></table></figure>
<p>3、生成密钥，方便拉取远程仓库代码</p>
<p>建议在服务器根目录执行，**cd / **  可以切换到根目录</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;登录邮箱&#x27;</span><br></pre></td></tr></table></figure>
<p>执行之后，不建议输入密码，直接一直Enter跳过</p>
<p>完成后，一般会在**/root/.ssh/<strong>文件夹中生成两个文件，大家</strong>id-rsa.pub**文件的内容，全部复制，找到github个人账户设置，在ssh key 中的菜单中新增ssh key,将内容粘贴进去即可。</p>
<h3 id="pei-zhi-nginx-dai-li" id="配置Nginx代理">配置Nginx代理</h3>
<p>此方案基于Docker容器中的Nginx</p>
<p>1、查看Nginx挂载目录</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">inspect</span> nginx | <span class="keyword">grep</span> Mounts -A <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081611709.png" alt="image-20211108161137330" /></p>
<p>Source对应服务器的文件夹，Destination对应nginx_config文件夹</p>
<p>注：如果你看的我博客进行配置的，会看到有五个挂载目录，有两个目录，很重要，其他是配置文件和日志的。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081628511.png" alt="image-20211108162847392" /></p>
<p>2、在conf.d文件夹加入项目的nginx配置</p>
<p>文件名：xxx.conf（xxx自己随意命名）</p>
<p>详细的解释，请仔细看注释</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver&#123;</span><br><span class="line">    <span class="comment">#172.17.0.6是项目所在容器的ip地址，8000为项目的端口，请根据实际情况修改；如果项目是在服务器裸奔的，可以直接用127.0.0.1:端口</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">172.17.0.6:8000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    <span class="comment">#监听的端口</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment">#域名，根据实际情况修改，（没域名，可以直接写成ip地址）</span></span><br><span class="line">    <span class="attribute">server_name</span> kygl.ruanzhuinfo.com;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">500m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/host.access.log main;</span><br><span class="line">	<span class="comment">#后台</span></span><br><span class="line">    <span class="section">location</span> /admin &#123;</span><br><span class="line">        <span class="comment">#root 后面路径在服务器的路径为：/data/nginx/www/kygl_v2/dist_web</span></span><br><span class="line">        <span class="comment">#因为nginx需要代替(代理)你访问文件，nginx是在一个docker容器中和服务器不是在一个环境下，</span></span><br><span class="line">        <span class="comment">#所以需要路径改成在容器中的路径，dist_web为前端的打包的文件夹，要保证dist_web中有index.html</span></span><br><span class="line">        <span class="attribute">root</span>   /nginx_config/www/kygl_v2/dist_web/;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html?s=<span class="variable">$uri</span>&amp;<span class="variable">$args</span>;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#前台，如果有前台，可以配置，同上，因为root只能存在一个，所以下面用的alias来配置另一个虚拟目录</span></span><br><span class="line">    <span class="comment">#location /front &#123;</span></span><br><span class="line">    <span class="comment">#   alias   /nginx_config/www/kygl_v2/dist_front/;</span></span><br><span class="line">    <span class="comment">#   try_files $uri $uri/ /index.html?s=$uri&amp;$args;</span></span><br><span class="line">    <span class="comment">#   index index.html index.htm index.php;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#后端</span></span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /auth &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#下面是配置访问swagger</span></span><br><span class="line">    <span class="section">location</span> /swagger-ui.html &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /webjars &#123;</span><br><span class="line">	   <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /swagger-resources &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /v2 &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、记得每次修改nginx的相关配置，都需要重新加载下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>进入nginx容器</span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"><span class="regexp">//</span>测试，看下配置文件是否有问题</span><br><span class="line">nginx -t</span><br><span class="line"><span class="regexp">//</span>重新加载</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081722262.png" alt="image-20211108172223927" /></p>
<p>如果遇到修改配置后，没有生效，请执行下面的命令</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">nginx -s reopen</span><br><span class="line">nginx -s <span class="built_in">stop</span> <span class="comment">//此命令执行后，会退出容器，重新进入即可</span></span><br><span class="line">nginx -<span class="built_in">reload</span></span><br></pre></td></tr></table></figure>
<h3 id="bu-shu-hou-duan-spring-boot-xiang-mu" id="部署后端（SpringBoot项目）">部署后端（SpringBoot项目）</h3>
<p>如果你是把各种服务放到了docker中，请选择<strong>方案一</strong>；如果你把各种服务安装到了服务器中，请选择<strong>方案二</strong>；</p>
<p>下面的所有步骤将以我的<a href="https://github.com/zglgithubx/ourchat.git">github项目</a>为例</p>
<p>克隆项目</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/zglgithubx/</span>ourchat.git</span><br></pre></td></tr></table></figure>
<p>切换到分支develop</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git checkout develop</span></span><br></pre></td></tr></table></figure>
<h4 id="fang-an-yi" id="方案一">方案一</h4>
<p><a href="http://xn--demo-k84ftib84es5a59uer1d9qa14mqveu07dc71bln2c.sh">这个方案用到了一个脚本文件demo.sh</a>，一个Dockerfile文件，说下demo.sh脚本都做了哪些工作：执行Dockerfile文件构建CentoS镜像，在镜像中安装了vim 、git、jdk 、maven—&gt;根据centos镜像启动了一个容器----&gt;在centos容器中拉取项目—&gt;将项目打包成jar包—&gt;启动项目jar包</p>
<p>1、准备文件</p>
<p>下面是脚本文件demo.sh和Dockerfile，部署时请将这两文件放到后端的根目录下</p>
<p>注：如果部署自己的项目需将<strong>SERVER_NAME 、JAR_PATH、Root_File_Name</strong>参数修改</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像名字</span></span><br><span class="line">IMAGE_NAME=centos7_mvn_git_java8</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 容器名字或者jar名字，这里都命名为这个（*必填）</span></span><br><span class="line">SERVER_NAME=ourchat</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的JAR_PATH为jar包所在位置，这路径是jar相对于脚本文件的路径。（*必填）</span></span><br><span class="line">JAR_PATH=./target/demo-0.0.1-RELEASE.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目根目录文件夹名称（*必填）</span></span><br><span class="line">Root_File_Name=ourchat</span><br><span class="line"></span><br><span class="line">profile=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"><span class="comment">#Xms=$4</span></span><br><span class="line"><span class="comment">#Xmx=$5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [init|start|stop|restart|status|pull] [profile] [port]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化——构建镜像和容器(在宿主机执行)</span></span><br><span class="line"><span class="function"><span class="title">init</span></span>()&#123;</span><br><span class="line">  <span class="comment">#容器id</span></span><br><span class="line">  CID=$(docker ps | grep <span class="string">&quot;<span class="variable">$SERVER_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">  <span class="comment">#镜像id</span></span><br><span class="line">  IID=$(docker images | grep <span class="string">&quot;<span class="variable">$IMAGE_NAME</span>&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">	<span class="comment"># 构建docker镜像</span></span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$IID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$SERVER_NAME</span> image，IID=<span class="variable">$IID</span>&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;NOT exit <span class="variable">$SERVER_NAME</span> image，start build image...&quot;</span></span><br><span class="line">		<span class="comment"># 根据项目个路径下的Dockerfile文件，构建镜像</span></span><br><span class="line">		docker build -t <span class="variable">$IMAGE_NAME</span> .</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span> image has been builded&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$CID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;Exit <span class="variable">$SERVER_NAME</span> container，CID=<span class="variable">$CID</span>.   ---Remove container&quot;</span></span><br><span class="line">			docker stop <span class="variable">$SERVER_NAME</span>   <span class="comment"># 停止运行中的容器</span></span><br><span class="line">			docker <span class="built_in">rm</span> <span class="variable">$SERVER_NAME</span>     <span class="comment">##删除原来的容器</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 构建容器</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span> container,start build...&quot;</span></span><br><span class="line">	<span class="comment"># 运行容器</span></span><br><span class="line">	 <span class="comment"># --name 容器的名字</span></span><br><span class="line">	 <span class="comment">#   -d   容器后台运行</span></span><br><span class="line">	 <span class="comment">#   -p   指定容器映射的端口和主机对应的端口</span></span><br><span class="line">	 <span class="comment">#   -v   将主机的目录挂载到容器的目录中（不可少）</span></span><br><span class="line">	docker run -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -<span class="built_in">id</span> -m 512M --memory-swap=1G --name <span class="variable">$SERVER_NAME</span> -v <span class="variable">$PWD</span>/../:/project/<span class="variable">$Root_File_Name</span> <span class="variable">$IMAGE_NAME</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SERVER_NAME</span> container build end&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查程序是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist</span></span>()&#123;</span><br><span class="line">  pid=`ps -ef|grep <span class="variable">$JAR_PATH</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动方法</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SERVER_NAME&#125;</span> is already running. pid=<span class="variable">$&#123;pid&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> --------Starting application --------</span><br><span class="line">    <span class="built_in">nohup</span> java -server -XX:-DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -jar <span class="variable">$JAR_PATH</span> --spring.profiles.active=<span class="variable">$&#123;profile:-dev&#125;</span> --server.port=<span class="variable">$&#123;port:-8000&#125;</span> &gt; start.log 2&gt;&amp;1 &amp;</span><br><span class="line">    <span class="built_in">echo</span> --------------Started!---------------</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止方法</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">    <span class="built_in">echo</span> -----------Application Stopped------------</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出运行状态</span></span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is running. Pid is <span class="variable">$&#123;pid&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#mvn</span></span><br><span class="line"><span class="function"><span class="title">pull</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：find status---------&quot;</span></span><br><span class="line">  git status</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：pull new coads---------&quot;</span></span><br><span class="line">  git pull origin develop</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------mvn clean package -Dmaven.test.skip=true---------&quot;</span></span><br><span class="line">  mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------Preparing start application ---------&quot;</span></span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    restart</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    start</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;init&quot;</span>)</span><br><span class="line">    init</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>)</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;pull&quot;</span>)</span><br><span class="line">    pull</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">RUN yum -y update \</span><br><span class="line">    &amp;&amp; yum -y install vim \</span><br><span class="line">    &amp;&amp; yum -y install git \</span><br><span class="line">    &amp;&amp; yum -y install java-1.8.0-openjdk-devel.x86_64 \</span><br><span class="line">    &amp;&amp; yum install -y maven \</span><br><span class="line">    &amp;&amp; mkdir ~/.m2</span><br><span class="line">RUN echo &#x27;<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span><span class="tag">&lt;<span class="name">mirror</span>&gt;</span><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span><span class="tag">&lt;/<span class="name">settings</span>&gt;</span>&#x27; &gt; ~/.m2/settings.xml</span><br></pre></td></tr></table></figure>
<p>2、初始化、构建镜像</p>
<p>切换到后端项目根目录</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd xxxx<span class="regexp">/ourchat_api/</span></span><br></pre></td></tr></table></figure>
<p>执行初始化命令</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh </span>demo.<span class="keyword">sh </span>init</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081113533.png" alt="image-20211108111350473" /></p>
<p>完成后，会有成功的提示</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081111622.png" alt="image-20211108111147161" /></p>
<p>3、查看容器是否启动</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081115646.png" alt="image-20211108111526577" /></p>
<p>status为up 即为启动成功</p>
<p>4、进入容器</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker exec -<span class="keyword">it</span> ourchat bash</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081116779.png" alt="image-20211108111634691" /></p>
<p>5、切换到容器中的项目后端目录</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">project</span><span class="regexp">/ourchat/</span>ourchat_api/</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202111081118447.png" alt="image-20211108111846333" /></p>
<p>6、脚本命令介绍</p>
<p>到这一步骤，环境基本都搭建完毕了，下面介绍脚本的命令</p>
<p>上面的初始化命令只需要执行一次，之后代码更新，只需要执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">注：下面的命令需要用ssh的方式和远程仓库建立连接，即配置centos容器中git,生成ssh key，将id.res_pub文件内容的key添加到github或coding服务器的个人账户中</span><br><span class="line"><span class="comment">#拉取新代码，重新打包项目，并重新启动</span></span><br><span class="line">sh demo.sh pull</span><br></pre></td></tr></table></figure>
<p>下面的命令是脚本的其他命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看项目启动状态</span></span><br><span class="line">sh demo.sh status</span><br><span class="line"><span class="comment">#启动项目，后面的参数是选填的,dev：环境，8000：项目端口号</span></span><br><span class="line">sh demo.sh start dev 8000</span><br><span class="line"><span class="comment">#停止项目</span></span><br><span class="line">sh demo.sh stop</span><br><span class="line"><span class="comment">#重新启动项目</span></span><br><span class="line">sh demo.sh restart</span><br></pre></td></tr></table></figure>
<h4 id="fang-an-er" id="方案二">方案二</h4>
<p>方案一的好处有很多，项目交付时，服务器可能会发生迁移，新服务器不用再手动安装一些环境，只需要安装docker ,剩下的环境，执行Dockerfile就可以了。</p>
<p>方案二适合在个人服务器部署个人项目，不需要考虑服务器的迁移，可以把所有环境都装到服务器，节省空间</p>
<p>你如果选择了方案二，默认你已经把mysql、redis、及git都已经安装完毕</p>
<p>为了能够启动后端项目，还需要安装maven、jdk</p>
<p>1、安装maven</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> maven</span><br></pre></td></tr></table></figure>
<p>2、安装jdk1.8</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yum</span> install java-<span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure>
<p>3、准备脚本文件</p>
<p>其实这文件是根据demo.sh修改的，也是只需要把这个文件放到后端项目的根目录，如果自己使用只需要更改<strong>SERVER_NAME、JAR_PATH</strong>这两个参数</p>
<p><a href="http://ourchat.sh">ourchat.sh</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 容器名字或者jar名字，这里都命名为这个</span></span><br><span class="line">SERVER_NAME=ourchat</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的JAR_PATH为jar包所在位置</span></span><br><span class="line">JAR_PATH=./target/demo-0.0.1-RELEASE.jar</span><br><span class="line"></span><br><span class="line">profile=<span class="variable">$2</span></span><br><span class="line">port=<span class="variable">$3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用说明，用来提示输入参数</span></span><br><span class="line"><span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: sh 执行脚本.sh [build|start|stop|restart|status|pull] [profile] [port]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">build</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------mvn clean package -Dmaven.test.skip=true---------&quot;</span></span><br><span class="line">  mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------Preparing start application ---------&quot;</span></span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    restart</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    start</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查程序是否在运行</span></span><br><span class="line"><span class="function"><span class="title">is_exist</span></span>()&#123;</span><br><span class="line">  pid=`ps -ef|grep <span class="variable">$JAR_PATH</span>|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line">  <span class="comment">#如果不存在返回1，存在返回0</span></span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;pid&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动方法</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SERVER_NAME&#125;</span> is already running. pid=<span class="variable">$&#123;pid&#125;</span> .&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> --------Starting application --------</span><br><span class="line">    <span class="built_in">nohup</span> java -server -Xms512m -Xmx512m -XX:SurvivorRatio=4 -Xss256k -XX:PermSize=256m -XX:MaxPermSize=512m -XX:-DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -jar <span class="variable">$JAR_PATH</span> --spring.profiles.active=<span class="variable">$&#123;profile:-prod&#125;</span> --server.port=<span class="variable">$&#123;port:-8000&#125;</span>&gt; start.log 2&gt;&amp;1 &amp;</span><br><span class="line">    <span class="built_in">echo</span> --------------Started!---------------</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止方法</span></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">    <span class="built_in">echo</span> -----------Application Stopped------------</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is not running&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出运行状态</span></span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is running. Pid is <span class="variable">$&#123;pid&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;JAR_PATH&#125;</span> is NOT running.&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#mvn</span></span><br><span class="line"><span class="function"><span class="title">pull</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：find status---------&quot;</span></span><br><span class="line">  git status</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------git：pull new coads---------&quot;</span></span><br><span class="line">  git pull origin develop</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------mvn clean package -Dmaven.test.skip=true---------&quot;</span></span><br><span class="line">  mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;----------Preparing start application ---------&quot;</span></span><br><span class="line">  is_exist</span><br><span class="line">  <span class="keyword">if</span> [ $? -eq <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    restart</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    start</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;build&quot;</span>)</span><br><span class="line">    build</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;start&quot;</span>)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;status&quot;</span>)</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  <span class="string">&quot;pull&quot;</span>)</span><br><span class="line">    pull</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>4、在项目后端根目录执行build命令</p>
<p>这个命令会将项目打包并运行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh </span>ourchat.<span class="keyword">sh </span><span class="keyword">build</span></span><br></pre></td></tr></table></figure>
<p>其他命令同方案一中介绍的命令一样</p>
<p>项目代码更新后，重新部署时，只需要执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh ourchat.sh pull</span><br></pre></td></tr></table></figure>
<h3 id="bu-shu-qian-duan-vue-xiang-mu" id="部署前端（Vue项目）">部署前端（Vue项目）</h3>
<p>前端的部署，不外乎将打包好的dist文件夹上传到服务器，可能有的人直接在服务器安装webpack,然后再安装一系列的前端需要的配置，使用git将项目拉取到服务器，然后在服务器运行打包命令。我感觉前端的部署不应该那么复杂，有人可能要说了，直接把dist包每次在本地打包，然后复制到服务器的指定目录不就好了，这都2021年了，其实也不需要那么步骤。下面我介绍一款前端部署插件，可以用来简化这些步骤。</p>
<h4 id="an-zhuang-fe-deploy-cli" id="安装fe-deploy-cli">安装fe-deploy-cli</h4>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>此为全局安装，一次安装受益终身</span><br><span class="line">npm i fe-deloy-cli -g</span><br></pre></td></tr></table></figure>
<p>安装之后，在前端项目根目录打开命令行</p>
<p>执行：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">deploy <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>执行完之后，在项目根目录会生成：deploy文件夹</p>
<p>文件deploy.config.js大概是这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">privateKey</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">//（选填） 本地私钥地址，位置一般在C:/Users/xxx/.ssh/id_rsa，非必填，有私钥则配置</span></span><br><span class="line">  <span class="attr">passphrase</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// （选填）本地私钥密码，非必填，有私钥则配置</span></span><br><span class="line">  <span class="attr">projectName</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 项目名称</span></span><br><span class="line">  <span class="comment">// 根据需要进行配置，如只需部署prod线上环境，请删除dev测试环境配置，反之亦然，支持多环境部署</span></span><br><span class="line">  <span class="attr">dev</span>: &#123; <span class="comment">// 开发环境</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;开发环境&#x27;</span>,</span><br><span class="line">    <span class="attr">script</span>: <span class="string">&quot;npm run build&quot;</span>, <span class="comment">// 测试环境打包脚本</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 测试服务器地址</span></span><br><span class="line">    <span class="attr">port</span>: xx, <span class="comment">// ssh port，一般默认22</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 登录服务器用户名</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;xxxxx&#x27;</span>, <span class="comment">// 登录服务器密码</span></span><br><span class="line">    <span class="attr">distPath</span>: <span class="string">&#x27;dist&#x27;</span>,  <span class="comment">// 本地打包dist目录</span></span><br><span class="line">    <span class="attr">webDir</span>: <span class="string">&#x27;/MyProject/docker/nginx/html&#x27;</span>,  <span class="comment">// // 测试环境服务器地址</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">prod</span>: &#123;  <span class="comment">// 线上环境</span></span><br><span class="line">    同上</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再还有多余的环境按照这个格式写即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面变量都有注释，可以只配置一个环境，只需要把prod的内容删除，如果prod环境你没有配执行时会有报错。</p>
<p>配置完，在项目根目录执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deploy dev <span class="comment">//这代表打包开发环境</span></span><br></pre></td></tr></table></figure>
<p>执行之后，需要你确认下，输入yes就行，执行过程为：打包前端项目–&gt;压缩打包文件–&gt;压缩包上传到指定服务器的文件夹–&gt;解压—&gt;部署成功</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>微信服务平台快速开发小程序</title>
    <url>/posts/29622.html</url>
    <content><![CDATA[<h2 id="xu-qiu" id="需求-3">需求</h2>
<p>根据一个小程序，发布一个和其一模一样的小程序。（可能不只一个）</p>
<p>如果按常规的做法每个小程序都需要经历这样的步骤：在公众平台申请appid——&gt;拉代码到自己的仓库——&gt;打开编译器绑定自己的appId——&gt;上传代码到公众平台——&gt;再提交审核——&gt;在公众平台调整开发设置。</p>
<p>如果用微信开放平台的服务平台开发的步骤：在微信开放平台申请第三方服务平台——&gt;上传小程序模板（只有第一次有）——&gt;调接口上传小程序代码</p>
<p>——&gt;调接口提交审核——&gt;调接口发布小程序。</p>
<p>上传小程序模板的步骤：在公众平台申请appid——&gt;在微信开放平台的第三方服务平台中添加开发小程序——&gt;上传小程序代码（此时会直接上传到了开放平台的草稿箱）——&gt;将草稿箱的代码作为普通模板</p>
<p>这就是服务平台开发平台的便捷，只需上传一次小程序代码，就可以快速的发布小程序。</p>
<span id="more"></span>
<h2 id="shi-xian" id="实现-3">实现</h2>
<h3 id="bu-zou-huo-qu-component-verify-ticket-gt-huo-qu-component-access-token-gt-huo-qu-authorizer-access-token-gt-diao-jie-kou-fa-bu-xiao-cheng-xu" id="步骤：获取component-verify-ticket——-获取component-access-token——-获取authorizer-access-token——-调接口发布小程序">步骤：获取component_verify_ticket——&gt;获取component_access_token——&gt;获取authorizer_access_token——&gt;调接口发布小程序</h3>
<h3 id="1-huo-qu-component-verify-ticket" id="1、获取component-verify-ticket">1、获取component_verify_ticket</h3>
<p>官方文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/component_verify_ticket.html">验证票据 | 微信开放文档 (qq.com)</a></p>
<h3 id="" id="-2"></h3>
<p>因为这个验证票据是微信官方主动推送的，所以需要在第三方平台配置一波</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/202201271429448.png" alt="image-20220127142943253" /></p>
<h4 id="controller" id="controller">controller</h4>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@ApiOperation</span>(value = <span class="string">&quot;微信开放平台：授权事件接收URL,验证票据&quot;</span>, notes = <span class="string">&quot;zhuguangliang&quot;</span>)</span><br><span class="line"><span class="variable">@AnonymousPostMapping</span>(<span class="string">&quot;/pushTicket&quot;</span>)</span><br><span class="line">public String wechatPlatformEvent(<span class="variable">@RequestParam</span>(<span class="string">&quot;timestamp&quot;</span>) String timestamp,</span><br><span class="line">                          <span class="variable">@RequestParam</span>(<span class="string">&quot;nonce&quot;</span>) String nonce,</span><br><span class="line">                          <span class="variable">@RequestParam</span>(<span class="string">&quot;msg_signature&quot;</span>) String msgSignature,</span><br><span class="line">                          <span class="variable">@RequestBody</span> String postData) &#123;</span><br><span class="line">   <span class="selector-tag">return</span> <span class="selector-tag">openPlatformUtil</span><span class="selector-class">.parseRequest</span>(timestamp, nonce, msgSignature, postData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shi-xian-lei" id="实现类">实现类</h4>
<p>关于存储component_verify_ticket方案，我这里是mysql和redis各存一份。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">parseRequest</span><span class="params">(String timeStamp, String nonce, String msgSignature, String postData)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (redisUtils.hasKey(CacheKey.OPEN_PLATFORM_TICKET)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//这个类是微信官网提供的解密类,需要用到消息校验Token 消息加密Key和服务平台appid</span></span><br><span class="line">			<span class="type">WXBizMsgCrypt</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WXBizMsgCrypt</span>(Token, Key, APPID);</span><br><span class="line">			<span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> pc.decryptMsg(msgSignature, timeStamp, nonce, postData);</span><br><span class="line">			Map&lt;String, String&gt; result = WXXmlToMapUtil.xmlToMap(xml);<span class="comment">// 将xml转为map</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">componentVerifyTicket</span> <span class="operator">=</span> result.get(<span class="string">&quot;ComponentVerifyTicket&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.isNotEmpty(componentVerifyTicket)) &#123;</span><br><span class="line">				<span class="comment">// 存储平台授权票据,保存ticket</span></span><br><span class="line">				<span class="type">SpiritOpenPlatform</span> <span class="variable">spiritOpenPlatform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpiritOpenPlatform</span>();</span><br><span class="line">				<span class="keyword">if</span> (platformMapper.selectByAppId(APPID) == <span class="number">0</span>) &#123;</span><br><span class="line">					spiritOpenPlatform.setAppid(APPID);</span><br><span class="line">					spiritOpenPlatform.setAppSecret(AppSecret);</span><br><span class="line">					spiritOpenPlatform.setPlatformKey(Key);</span><br><span class="line">					spiritOpenPlatform.setToken(Token);</span><br><span class="line">					spiritOpenPlatform.setComponentVerifyTicket(componentVerifyTicket);</span><br><span class="line">					platformMapper.insert(spiritOpenPlatform);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					spiritOpenPlatform.setComponentVerifyTicket(componentVerifyTicket);</span><br><span class="line">					LambdaUpdateWrapper&lt;SpiritOpenPlatform&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">					updateWrapper.eq(SpiritOpenPlatform::getAppid, APPID);</span><br><span class="line">					platformMapper.update(spiritOpenPlatform, updateWrapper);</span><br><span class="line">				&#125;</span><br><span class="line">				redisUtils.set(CacheKey.OPEN_PLATFORM_TICKET, componentVerifyTicket, <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>);</span><br><span class="line">				log.info(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】成功&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.error(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】失败&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (AesException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】失败,异常信息：&quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>官方提供的解密类：WXBizMsgCrypt.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.InputSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供接收和推送给公众平台消息的加解密接口(UTF8编码的字符串).</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;  * &lt;li&gt;第三方回复加密消息给公众平台&lt;/li&gt;  * &lt;li&gt;第三方收到公众平台发送的消息，验证消息的安全性，并对消息进行解密。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * 说明：异常java.security.InvalidKeyException:illegal Key Size的解决方案</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;在官方网站下载JCE无限制权限策略文件（JDK7的下载地址：  *</span></span><br><span class="line"><span class="comment"> * http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;如果安装了JRE，将两个jar文件放到%JRE_HOME%\lib\security目录下覆盖原来的文件&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;如果安装了JDK，将两个jar文件放到%JDK_HOME%\jre\lib\security目录下覆盖原来文件&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXBizMsgCrypt</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">	<span class="type">Base64</span> <span class="variable">base64</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base64</span>();</span><br><span class="line">	<span class="type">byte</span>[] aesKey;</span><br><span class="line">	String token;</span><br><span class="line">	String appId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造函数</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> token          公众平台上，开发者设置的token</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encodingAesKey 公众平台上，开发者设置的EncodingAESKey</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> appId          公众平台appid</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException 执行失败，请查看该异常的错误码和具体的错误信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WXBizMsgCrypt</span><span class="params">(String token, String encodingAesKey, String appId)</span> <span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		<span class="keyword">if</span> (encodingAesKey.length() != <span class="number">43</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.IllegalAesKey);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.token = token;</span><br><span class="line">		<span class="built_in">this</span>.appId = appId;</span><br><span class="line">		aesKey = Base64.decodeBase64(encodingAesKey + <span class="string">&quot;=&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还原4个字节的网络字节序</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">recoverNetworkBytesOrder</span><span class="params">(<span class="type">byte</span>[] orderBytes)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sourceNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			sourceNumber &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">			sourceNumber |= orderBytes[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sourceNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对密文进行解密.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> text 需要解密的密文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 解密得到的明文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException aes解密失败</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String <span class="title function_">decrypt</span><span class="params">(String text)</span> <span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		<span class="type">byte</span>[] original;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 设置解密模式为AES的CBC模式</span></span><br><span class="line">			<span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/NoPadding&quot;</span>);</span><br><span class="line">			<span class="type">SecretKeySpec</span> <span class="variable">key_spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(aesKey, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">			<span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(Arrays.copyOfRange(aesKey, <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">			cipher.init(Cipher.DECRYPT_MODE, key_spec, iv);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用BASE64对密文进行解码</span></span><br><span class="line">			<span class="type">byte</span>[] encrypted = Base64.decodeBase64(text);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 解密</span></span><br><span class="line">			original = cipher.doFinal(encrypted);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.DecryptAESError);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String xmlContent, from_appid;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 去除补位字符</span></span><br><span class="line">			<span class="type">byte</span>[] bytes = PKCS7Encoder.decode(original);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 分离16位随机字符串,网络字节序和AppId</span></span><br><span class="line">			<span class="type">byte</span>[] networkOrder = Arrays.copyOfRange(bytes, <span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> <span class="variable">xmlLength</span> <span class="operator">=</span> recoverNetworkBytesOrder(networkOrder);</span><br><span class="line"></span><br><span class="line">			xmlContent = <span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(bytes, <span class="number">20</span>, <span class="number">20</span> + xmlLength), CHARSET);</span><br><span class="line">			from_appid =</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(bytes, <span class="number">20</span> + xmlLength, bytes.length), CHARSET);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.IllegalBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// appid不相同的情况</span></span><br><span class="line">		<span class="keyword">if</span> (!from_appid.equals(appId)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ValidateSignatureError);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> xmlContent;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * * 检验消息的真实性，并且获取解密后的明文.</span></span><br><span class="line"><span class="comment">	 * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;利用收到的密文生成安全签名，进行签名验证&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;若验证通过，则提取xml中的加密消息&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;li&gt;对消息进行解密&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	 * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> msgSignature 签名串，对应URL参数的msg_signature</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timeStamp    时间戳，对应URL参数的timestamp</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nonce        随机串，对应URL参数的nonce</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> postData     密文，对应POST请求的数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 解密后的原文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException 执行失败，请查看该异常的错误码和具体的错误信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">decryptMsg</span><span class="params">(String msgSignature, String timeStamp, String nonce, String postData)</span></span><br><span class="line">			<span class="keyword">throws</span> AesException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 密钥，公众账号的app secret</span></span><br><span class="line">		<span class="comment">// 提取密文</span></span><br><span class="line">		Object[] encrypt = extract(postData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 验证安全签名</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> getSHA1(token, timeStamp, nonce, encrypt[<span class="number">1</span>].toString());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 和URL中的签名比较是否相等</span></span><br><span class="line">		<span class="comment">// System.out.println(&quot;第三方收到URL中的签名：&quot; + msg_sign);</span></span><br><span class="line">		<span class="comment">// System.out.println(&quot;第三方校验签名：&quot; + signature);</span></span><br><span class="line">		<span class="keyword">if</span> (!signature.equals(msgSignature)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ValidateSignatureError);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解密</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> decrypt(encrypt[<span class="number">1</span>].toString());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提取出xml数据包中的加密消息</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xmltext 待提取的xml字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 提取出的加密消息字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Object[] extract(String xmltext) <span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		Object[] result = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">			dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">			dbf.setXIncludeAware(<span class="literal">false</span>);</span><br><span class="line">			dbf.setExpandEntityReferences(<span class="literal">false</span>);</span><br><span class="line">			<span class="type">DocumentBuilder</span> <span class="variable">db</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line">			<span class="type">StringReader</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(xmltext);</span><br><span class="line">			<span class="type">InputSource</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(sr);</span><br><span class="line">			<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> db.parse(is);</span><br><span class="line"></span><br><span class="line">			<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getDocumentElement();</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nodelist1</span> <span class="operator">=</span> root.getElementsByTagName(<span class="string">&quot;Encrypt&quot;</span>);</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nodelist2</span> <span class="operator">=</span> root.getElementsByTagName(<span class="string">&quot;ToUserName&quot;</span>);</span><br><span class="line">			result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			result[<span class="number">1</span>] = nodelist1.item(<span class="number">0</span>).getTextContent();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//注意这里,获取ticket中的xml里面没有ToUserName这个元素,官网原示例代码在这里会报空</span></span><br><span class="line">			<span class="comment">//空指针,所以需要处理一下</span></span><br><span class="line">			<span class="keyword">if</span> (nodelist2 != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nodelist2.item(<span class="number">0</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">					result[<span class="number">2</span>] = nodelist2.item(<span class="number">0</span>).getTextContent();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ParseXmlError);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用SHA1算法生成安全签名</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> token     票据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timestamp 时间戳</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nonce     随机字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encrypt   密文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 安全签名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AesException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSHA1</span><span class="params">(String token, String timestamp, String nonce, String encrypt)</span></span><br><span class="line">			<span class="keyword">throws</span> AesException &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;token, timestamp, nonce, encrypt&#125;;</span><br><span class="line">			<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">			<span class="comment">// 字符串排序</span></span><br><span class="line">			Arrays.sort(array);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">				sb.append(array[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">			<span class="comment">// SHA1签名生成</span></span><br><span class="line">			<span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">			md.update(str.getBytes());</span><br><span class="line">			<span class="type">byte</span>[] digest = md.digest();</span><br><span class="line"></span><br><span class="line">			<span class="type">StringBuffer</span> <span class="variable">hexstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">			<span class="type">String</span> <span class="variable">shaHex</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digest.length; i++) &#123;</span><br><span class="line">				shaHex = Integer.toHexString(digest[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">				<span class="keyword">if</span> (shaHex.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">					hexstr.append(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				hexstr.append(shaHex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> hexstr.toString();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AesException</span>(AesException.ComputeSignatureError);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PKCS7Encode.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供基于PKCS7算法的加解密接口.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PKCS7Encoder</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">BLOCK_SIZE</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得对明文进行补位填充的字节.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> count 需要进行填充补位操作的明文字节个数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 补齐用的字节数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">byte</span>[] encode(<span class="type">int</span> count) &#123;</span><br><span class="line">		<span class="comment">// 计算需要填充的位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">amountToPad</span> <span class="operator">=</span> BLOCK_SIZE - (count % BLOCK_SIZE);</span><br><span class="line">		<span class="keyword">if</span> (amountToPad == <span class="number">0</span>) &#123;</span><br><span class="line">			amountToPad = BLOCK_SIZE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获得补位所用的字符</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">padChr</span> <span class="operator">=</span> chr(amountToPad);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; amountToPad; index++) &#123;</span><br><span class="line">			tmp += padChr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp.getBytes(CHARSET);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除解密后明文的补位字符</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> decrypted 解密后的明文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 删除补位字符后的明文</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">byte</span>[] decode(<span class="type">byte</span>[] decrypted) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pad</span> <span class="operator">=</span> (<span class="type">int</span>) decrypted[decrypted.length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (pad &lt; <span class="number">1</span> || pad &gt; <span class="number">32</span>) &#123;</span><br><span class="line">			pad = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOfRange(decrypted, <span class="number">0</span>, decrypted.length - pad);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将数字转化成ASCII码对应的字符，用于对明文进行补码</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a 需要转化的数字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 转化得到的字符</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span> <span class="title function_">chr</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">target</span> <span class="operator">=</span> (<span class="type">byte</span>) (a &amp; <span class="number">0xFF</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">char</span>) target;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXXmlToMapUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentHelper;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.OutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.XMLWriter;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.OutputKeys;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Transformer;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.TransformerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.dom.DOMSource;</span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.stream.StreamResult;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXXmlToMapUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(WXXmlToMapUtil.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * XML格式字符串转换为Map</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xml XML字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> XML数据转换后的Map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">xmlToMap</span><span class="params">(String xml)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			<span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">			<span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(xml.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">			org.w3c.dom.<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> documentBuilder.parse(stream);</span><br><span class="line">			doc.getDocumentElement().normalize();</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nodeList</span> <span class="operator">=</span> doc.getDocumentElement().getChildNodes();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; nodeList.getLength(); ++idx) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeList.item(idx);</span><br><span class="line">				<span class="keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">					org.w3c.dom.<span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> (org.w3c.dom.Element) node;</span><br><span class="line">					data.put(element.getNodeName(), element.getTextContent());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			stream.close();</span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将Map转换为XML格式的字符串</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data Map类型数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> XML格式的字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">mapToXml</span><span class="params">(Map&lt;String, String&gt; data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">DocumentBuilderFactory</span> <span class="variable">documentBuilderFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">			<span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">			org.w3c.dom.<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> documentBuilder.newDocument();</span><br><span class="line">			org.w3c.dom.<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;xml&quot;</span>);</span><br><span class="line">			document.appendChild(root);</span><br><span class="line">			<span class="keyword">for</span> (String key : data.keySet()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> data.get(key);</span><br><span class="line">				<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">					value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				value = value.trim();</span><br><span class="line">				org.w3c.dom.<span class="type">Element</span> <span class="variable">filed</span> <span class="operator">=</span> document.createElement(key);</span><br><span class="line">				filed.appendChild(document.createTextNode(value));</span><br><span class="line">				root.appendChild(filed);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();</span><br><span class="line">			<span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> tf.newTransformer();</span><br><span class="line">			<span class="type">DOMSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DOMSource</span>(document);</span><br><span class="line">			transformer.setOutputProperty(OutputKeys.ENCODING, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			transformer.setOutputProperty(OutputKeys.INDENT, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">			<span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">			<span class="type">StreamResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamResult</span>(writer);</span><br><span class="line">			transformer.transform(source, result);</span><br><span class="line">			<span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> writer.getBuffer().toString(); <span class="comment">//.replaceAll(&quot;\n|\r&quot;, &quot;&quot;);</span></span><br><span class="line">			writer.close();</span><br><span class="line">			<span class="keyword">return</span> output;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (多层)xml格式字符串转换为map</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xml xml字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 第一个为Root节点，Root节点之后为Root的元素，如果为多层，可以通过key获取下一层Map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">multilayerXmlToMap</span><span class="params">(String xml)</span> &#123;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doc = DocumentHelper.parseText(xml);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">			logger.error(<span class="string">&quot;xml字符串解析，失败 --&gt; &#123;&#125;&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> == doc) &#123;</span><br><span class="line">			<span class="keyword">return</span> map;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取根元素</span></span><br><span class="line">		<span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> doc.getRootElement();</span><br><span class="line">		recursionXmlToMap(rootElement, map);</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * multilayerXmlToMap核心方法，递归调用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element 节点元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> outmap  用于存储xml数据的map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursionXmlToMap</span><span class="params">(Element element, Map&lt;String, Object&gt; outmap)</span> &#123;</span><br><span class="line">		<span class="comment">// 得到根元素下的子元素列表</span></span><br><span class="line">		List&lt;Element&gt; list = element.elements();</span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">		<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果没有子元素,则将其存储进map中</span></span><br><span class="line">			outmap.put(element.getName(), element.getTextTrim());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// innermap用于存储子元素的属性名和属性值</span></span><br><span class="line">			Map&lt;String, Object&gt; innermap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			<span class="comment">// 遍历子元素</span></span><br><span class="line">			list.forEach(childElement -&gt; recursionXmlToMap(childElement, innermap));</span><br><span class="line">			outmap.put(element.getName(), innermap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (多层)map转换为xml格式字符串</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map     需要转换为xml的map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> isCDATA 是否加入CDATA标识符 true:加入 false:不加入</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> xml字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">multilayerMapToXml</span><span class="params">(Map&lt;String, Object&gt; map, <span class="type">boolean</span> isCDATA)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">parentName</span> <span class="operator">=</span> <span class="string">&quot;xml&quot;</span>;</span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> DocumentHelper.createDocument();</span><br><span class="line">		doc.addElement(parentName);</span><br><span class="line">		<span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> recursionMapToXml(doc.getRootElement(), parentName, map, isCDATA);</span><br><span class="line">		<span class="keyword">return</span> formatXML(xml);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * multilayerMapToXml核心方法，递归调用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> element    节点元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentName 根元素属性名</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map        需要转换为xml的map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> isCDATA    是否加入CDATA标识符 true:加入 false:不加入</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> xml字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">recursionMapToXml</span><span class="params">(Element element, String parentName, Map&lt;String, Object&gt; map, <span class="type">boolean</span> isCDATA)</span> &#123;</span><br><span class="line">		<span class="type">Element</span> <span class="variable">xmlElement</span> <span class="operator">=</span> element.addElement(parentName);</span><br><span class="line">		map.keySet().forEach(key -&gt; &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">				recursionMapToXml(xmlElement, key, (Map&lt;String, Object&gt;) obj, isCDATA);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> obj == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : obj.toString();</span><br><span class="line">				<span class="keyword">if</span> (isCDATA) &#123;</span><br><span class="line">					xmlElement.addElement(key).addCDATA(value);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					xmlElement.addElement(key).addText(value);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> xmlElement.asXML();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 格式化xml,显示为容易看的XML格式</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> xml 需要格式化的xml字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">formatXML</span><span class="params">(String xml)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">requestXML</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 拿取解析器</span></span><br><span class="line">			<span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">			<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(<span class="keyword">new</span> <span class="title class_">StringReader</span>(xml));</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">null</span> != document) &#123;</span><br><span class="line">				<span class="type">StringWriter</span> <span class="variable">stringWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">				<span class="comment">// 格式化,每一级前的空格</span></span><br><span class="line">				<span class="type">OutputFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputFormat</span>(<span class="string">&quot;    &quot;</span>, <span class="literal">true</span>);</span><br><span class="line">				<span class="comment">// xml声明与内容是否添加空行</span></span><br><span class="line">				format.setNewLineAfterDeclaration(<span class="literal">false</span>);</span><br><span class="line">				<span class="comment">// 是否设置xml声明头部</span></span><br><span class="line">				format.setSuppressDeclaration(<span class="literal">false</span>);</span><br><span class="line">				<span class="comment">// 是否分行</span></span><br><span class="line">				format.setNewlines(<span class="literal">true</span>);</span><br><span class="line">				<span class="type">XMLWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLWriter</span>(stringWriter, format);</span><br><span class="line">				writer.write(document);</span><br><span class="line">				writer.flush();</span><br><span class="line">				writer.close();</span><br><span class="line">				requestXML = stringWriter.getBuffer().toString();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> requestXML;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.error(<span class="string">&quot;格式化xml，失败 --&gt; &#123;&#125;&quot;</span>, e);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AesException.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AesException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">OK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ValidateSignatureError</span> <span class="operator">=</span> -<span class="number">40001</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ParseXmlError</span> <span class="operator">=</span> -<span class="number">40002</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ComputeSignatureError</span> <span class="operator">=</span> -<span class="number">40003</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">IllegalAesKey</span> <span class="operator">=</span> -<span class="number">40004</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ValidateCorpidError</span> <span class="operator">=</span> -<span class="number">40005</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">EncryptAESError</span> <span class="operator">=</span> -<span class="number">40006</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DecryptAESError</span> <span class="operator">=</span> -<span class="number">40007</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">IllegalBuffer</span> <span class="operator">=</span> -<span class="number">40008</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">			<span class="keyword">case</span> ValidateSignatureError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;签名验证错误&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> ParseXmlError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;xml解析失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> ComputeSignatureError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;sha加密生成签名失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> IllegalAesKey:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;SymmetricKey非法&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> ValidateCorpidError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;corpid校验失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> EncryptAESError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;aes加密失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> DecryptAESError:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;aes解密失败&quot;</span>;</span><br><span class="line">			<span class="keyword">case</span> IllegalBuffer:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;解密后得到的buffer非法&quot;</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// cannot be</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AesException(<span class="type">int</span> code) &#123;</span><br><span class="line">		<span class="built_in">super</span>(getMessage(code));</span><br><span class="line">		<span class="built_in">this</span>.code = code;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-huo-qu-component-access-token" id="2、获取component-access-token">2、获取component_access_token</h3>
<p>官方文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/component_access_token.html">令牌 | 微信开放文档 (qq.com)</a></p>
<h4 id="shi-xian-lei-1" id="实现类-2">实现类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getComponentAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">componentAccessTokenUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_component_token&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(CacheKey.COMPONENT_ACCESS_TOKEN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (redisUtils.getExpire(CacheKey.COMPONENT_ACCESS_TOKEN) &gt; <span class="number">10</span> * <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    <span class="comment">//第三方平台的appid、appsecret</span></span><br><span class="line">    params.put(<span class="string">&quot;component_appid&quot;</span>, APPID);</span><br><span class="line">    params.put(<span class="string">&quot;component_appsecret&quot;</span>, AppSecret);</span><br><span class="line">    String component_verify_ticket;</span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(CacheKey.OPEN_PLATFORM_TICKET)) &#123;</span><br><span class="line">        component_verify_ticket = (String) redisUtils.get(CacheKey.OPEN_PLATFORM_TICKET);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//查询数据库中的component_verify_ticket</span></span><br><span class="line">        component_verify_ticket = platformMapper.selectTicket();</span><br><span class="line">        redisUtils.set(CacheKey.OPEN_PLATFORM_TICKET, component_verify_ticket, <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(component_verify_ticket)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;微信开放平台，第三方平台获取【验证票据】失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    params.put(<span class="string">&quot;component_verify_ticket&quot;</span>, component_verify_ticket);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.post(componentAccessTokenUrl, JSON.toJSONString(params)));</span><br><span class="line">    <span class="keyword">if</span> (data.containsKey(<span class="string">&quot;component_access_token&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">componentAccessToken</span> <span class="operator">=</span> data.getString(<span class="string">&quot;component_access_token&quot;</span>);</span><br><span class="line">        <span class="comment">//将component_access_token存入redis中，并设置2个小时的过期时间</span></span><br><span class="line">        redisUtils.set(CacheKey.COMPONENT_ACCESS_TOKEN, componentAccessToken, <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    redisUtils.del(CacheKey.COMPONENT_ACCESS_TOKEN);</span><br><span class="line">    redisUtils.del(CacheKey.OPEN_PLATFORM_TICKET);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;获取component_access_token失败,请重试,接口返回信息：&quot;</span> + data.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-huo-qu-authorizer-access-token" id="3、获取authorizer-access-token">3、获取authorizer_access_token</h3>
<h4 id="bu-zou" id="步骤：">步骤：</h4>
<h4 id="huo-qu-yu-shou-quan-ma-pre-auth-code-gt-wei-xin-gong-zhong-ping-tai-guan-li-yuan-shou-quan-gt-huo-qu-authorizer-access-token-amp-authorizer-refresh-token" id="获取预授权码pre-auth-code——-微信公众平台管理员授权——-获取authorizer-access-token-authorizer-refresh-token">获取预授权码pre_auth_code——&gt;微信公众平台管理员授权——&gt;获取authorizer_access_token&amp;authorizer_refresh_token</h4>
<p>官方文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Authorization_Process_Technical_Description.html">https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/Before_Develop/Authorization_Process_Technical_Description.html</a></p>
<h4 id="huo-qu-yu-shou-quan-ma-pre-auth-code" id="①获取预授权码pre-auth-code">①获取预授权码pre_auth_code</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPreAuthCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先判断component_access_token是否过期，如果过期重新获取</span></span><br><span class="line">    getComponentAccessToken();</span><br><span class="line">    <span class="type">String</span> <span class="variable">preAuthCodeUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_create_preauthcode?component_access_token=&quot;</span> + redisUtils.get(CacheKey.COMPONENT_ACCESS_TOKEN);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    params.put(<span class="string">&quot;component_appid&quot;</span>, APPID);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.post(preAuthCodeUrl, JSON.toJSONString(params)));</span><br><span class="line">    <span class="keyword">if</span> (data.containsKey(<span class="string">&quot;pre_auth_code&quot;</span>)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> data.getString(<span class="string">&quot;pre_auth_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;获取预授权失败,接口返回信息：&quot;</span> + data.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wei-xin-gong-zhong-ping-tai-guan-li-yuan-shou-quan" id="②微信公众平台管理员授权">②微信公众平台管理员授权</h4>
<p>生成授权链接，可以在前端用a标签填入这个接口地址，点击a标签打开新标签页，管理员进行扫码授权</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toAuthorization</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">authUrl</span> <span class="operator">=</span> <span class="string">&quot;https://mp.weixin.qq.com/cgi-bin/componentloginpagecomponent_appid=%s&amp;pre_auth_code=%s&amp;redirect_uri=%s&amp;auth_type=1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> <span class="string">&quot;https://服务端地址/callback&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">preAuthCode</span> <span class="operator">=</span> getPreAuthCode();</span><br><span class="line">    response.setStatus(<span class="number">301</span>);</span><br><span class="line">    response.sendRedirect(String.format(authUrl, APPID, preAuthCode, redirectUrl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>授权之后，会回调：“<a href="https://xn--zfry9hnb732hgox/callback">https://服务端地址/callback</a>”，并将授权码auth_code携带到这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;微信开放平台：用户授权后，回调地址&quot;, notes = &quot;zhuguangliang&quot;)</span></span><br><span class="line">	<span class="meta">@AnonymousGetMapping(&quot;/callback&quot;)</span></span><br><span class="line">	<span class="meta">@Notice(&quot;2393194918@qq.com&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(String auth_code)</span> &#123;</span><br><span class="line"><span class="comment">//		openPlatformService.getAuthorizationInfo(auth_code);</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="huo-qu-authorizer-access-token-amp-authorizer-refresh-token" id="③获取authorizer-access-token-authorizer-refresh-token">③获取authorizer_access_token&amp;authorizer_refresh_token</h4>
<p>官方文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/authorization_info.html">https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/authorization_info.html</a></p>
<p>说明：authorization_code就是授权之后，返回的授权码</p>
<p>如果你使用微信的第三方平台管理工具，可以在数据库中直接获取authorizer_refresh_token，然后根据：</p>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/ThirdParty/token/api_authorizer_token.html">获取/刷新接口调用令牌 | 微信开放文档 (qq.com)</a>这个接口进行刷新authorizer_access_token，下面是实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//authorizerAppId为授权的appid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAuthorizationInfo</span><span class="params">(String authorizerAppId)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CacheKey.AUTH_ACCESS_TOKEN + authorizerAppId;</span><br><span class="line">    <span class="comment">//这一步是为如果发现这个token快过期，则刷新</span></span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(key) &amp;&amp; redisUtils.getExpire(key) &gt; <span class="number">5</span> * <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getComponentAccessToken();</span><br><span class="line">    <span class="type">String</span> <span class="variable">refreshTokenUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_authorizer_token?component_access_token=&quot;</span> + redisUtils.get(CacheKey.COMPONENT_ACCESS_TOKEN);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    param.put(<span class="string">&quot;component_appid&quot;</span>, APPID);</span><br><span class="line">    param.put(<span class="string">&quot;authorizer_appid&quot;</span>, authorizerAppId);</span><br><span class="line">    String refreshToken;</span><br><span class="line">    <span class="keyword">if</span> (redisUtils.hasKey(CacheKey.AUTH_REFRESH_TOKEN + authorizerAppId)) &#123;</span><br><span class="line">        refreshToken = (String) redisUtils.get(CacheKey.AUTH_REFRESH_TOKEN + authorizerAppId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从微信第三方管理工具的数据库中查询出authorizer_refresh_token</span></span><br><span class="line">        refreshToken = platformMapper.selectRefreshTokenByAppId(authorizerAppId);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(refreshToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;小程序管理员未授权，请让小程序管理员重新授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算刷新令牌的过期时间</span></span><br><span class="line">         <span class="comment">//从微信第三方管理工具的数据库中查询出authorizer_refresh_token的过期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">authTime</span> <span class="operator">=</span> platformMapper.selectAuthTimeByAppId(authorizerAppId).toLocalDateTime();</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(authTime, LocalDateTime.now());</span><br><span class="line">        redisUtils.set(CacheKey.AUTH_REFRESH_TOKEN + authorizerAppId, refreshToken, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> - (duration.toMillis() / <span class="number">1000</span> + <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    param.put(<span class="string">&quot;authorizer_refresh_token&quot;</span>, refreshToken);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">tokenData</span> <span class="operator">=</span> JSONObject.parseObject(HttpUtil.post(refreshTokenUrl, JSON.toJSONString(param)));</span><br><span class="line">    <span class="keyword">if</span> (tokenData.containsKey(<span class="string">&quot;authorizer_access_token&quot;</span>)) &#123;</span><br><span class="line">        redisUtils.set(CacheKey.AUTH_ACCESS_TOKEN + authorizerAppId, tokenData.getString(<span class="string">&quot;authorizer_access_token&quot;</span>), <span class="number">2</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        LambdaUpdateWrapper&lt;SpiritOpenPlatform&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        updateWrapper.eq(SpiritOpenPlatform::getAppid, authorizerAppId);</span><br><span class="line">        <span class="type">SpiritOpenPlatform</span> <span class="variable">openPlatform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpiritOpenPlatform</span>();</span><br><span class="line">        openPlatform.setAuthorizerRefreshToken(refreshToken);</span><br><span class="line">        openPlatform.setAuthorizerAccessToken(tokenData.getString(<span class="string">&quot;authorizer_access_token&quot;</span>));</span><br><span class="line">        platformMapper.update(openPlatform, updateWrapper);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;获取authorizer_access_token失败,接口返回信息：&quot;</span> + tokenData.toJSONString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，微信第三方平台开发中的关键token，authorizer_access_token已经成功获取</p>
<h3 id="4-diao-jie-kou-fa-bu-xiao-cheng-xu" id="4、调接口发布小程序">4、调接口发布小程序</h3>
<h4 id="ti-jiao-dai-ma-jie-kou-a-href-https-developers-weixin-qq-com-doc-oplatform-third-party-platforms-2-0-api-code-commit-html-shang-chuan-xiao-cheng-xu-dai-ma-bing-sheng-cheng-ti-yan-ban-wei-xin-kai-fang-wen-dang-qq-com-a" id="提交代码接口：上传小程序代码并生成体验版-微信开放文档-qq-com">提交代码接口：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/code/commit.html">上传小程序代码并生成体验版 | 微信开放文档 (qq.com)</a></h4>
<h4 id="she-zhi-yong-hu-yin-si-jie-kou-a-href-https-developers-weixin-qq-com-doc-oplatform-third-party-platforms-2-0-api-privacy-config-set-privacy-setting-html-pei-zhi-xiao-cheng-xu-yong-hu-yin-si-bao-hu-zhi-yin-wei-xin-kai-fang-wen-dang-qq-com-a" id="设置用户隐私接口：配置小程序用户隐私保护指引-微信开放文档-qq-com">设置用户隐私接口：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/privacy_config/set_privacy_setting.html">配置小程序用户隐私保护指引 | 微信开放文档 (qq.com)</a></h4>
<h4 id="ti-jiao-shen-he-jie-kou-a-href-https-developers-weixin-qq-com-doc-oplatform-third-party-platforms-2-0-api-code-submit-audit-html-ti-jiao-shen-he-wei-xin-kai-fang-wen-dang-qq-com-a" id="提交审核接口：提交审核-微信开放文档-qq-com">提交审核接口：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/code/submit_audit.html">提交审核 | 微信开放文档 (qq.com)</a></h4>
<h4 id="cha-xun-shen-he-jie-guo-jie-kou-a-href-https-developers-weixin-qq-com-doc-oplatform-third-party-platforms-2-0-api-code-get-latest-auditstatus-html-cha-xun-zui-xin-yi-ci-ti-jiao-de-shen-he-zhuang-tai-wei-xin-kai-fang-wen-dang-qq-com-a" id="查询审核结果接口：查询最新一次提交的审核状态-微信开放文档-qq-com">查询审核结果接口：<a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/api/code/get_latest_auditstatus.html">查询最新一次提交的审核状态 | 微信开放文档 (qq.com)</a></h4>
<ul>
<li>项目中可以采用定时任务的策略调用该接口</li>
</ul>
<h2 id="zui-hou" id="最后-3">最后</h2>
<p>总结：微信第三方平台开发的流程，涉及的接口有点多，微信的文档其实也写的很详细了，但是在开发过程中，免不了遇见莫名其妙的问题，这个时候可以在微信开放社区里找找或者搜下博客。</p>
]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>第三方平台</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/posts/22654.html</url>
    <content><![CDATA[<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<span id="more"></span>
<p>[TOC]</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV17a4y1x7zq">https://www.bilibili.com/video/BV17a4y1x7zq</a></p>
<h1 id="elastic-search">ElasticSearch</h1>
<h2 id="liao-liao-doug-cutting" id="聊聊Doug-Cutting">聊聊Doug Cutting</h2>
<p>1998年9月4日，Google公司在美国硅谷成立。正如大家所知，它是一家做搜索引擎起家的公司。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/75c99654de8d40f0934b31e7d811ad10.png" alt="在这里插入图片描述" /></p>
<p>无独有偶，一位名叫<strong>Doug Cutting</strong>的美国工程师，也迷上了搜索引擎。他做了一个用于文本搜索的函数库（姑且理解为软件的功能组件），命名为<strong>Lucene</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9acb284104e24e8c9129eabb2c641887.png" alt="在这里插入图片描述" /></p>
<p>Lucene是用JAVA写成的，目标是为各种中小型应用软件加入全文检索功能。因为好用而且开源（代码公开），非常受程序员们的欢迎。</p>
<p>早期的时候，这个项目被发布在Doug Cutting的个人网站和SourceForge（一个开源软件网站）。后来，2001年底，Lucene成为Apache软件基金会jakarta项目的一个子项目。</p>
<p><img data-src="https://img-blog.csdnimg.cn/e8b867eb08e04187955eb67500f1cfbb.png" alt="在这里插入图片描述" /></p>
<p>2004年，Doug Cutting再接再励，在Lucene的基础上，和Apache开源伙伴Mike Cafarella合作，开发了一款可以代替当时的主流搜索的开源搜索引擎，命名为<strong>Nutch</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/78e9603f45ea412e8a7f34d04cbbe143.png" alt="在这里插入图片描述" /></p>
<p>Nutch是一个建立在Lucene核心之上的网页搜索应用程序，可以下载下来直接使用。它在Lucene的基础上加了网络爬虫和一些网页相关的功能，目的就是从一个简单的站内检索推广到全球网络的搜索上，就像Google一样。</p>
<p>Nutch在业界的影响力比Lucene更大。</p>
<p>大批网站采用了Nutch平台，大大降低了技术门槛，使低成本的普通计算机取代高价的Web服务器成为可能。甚至有一段时间，在硅谷有了一股用Nutch低成本创业的潮流。（大数据！）</p>
<p>随着时间的推移，无论是Google还是Nutch，都面临搜索对象“体积”不断增大的问题。</p>
<p>尤其是Google，作为互联网搜索引擎，需要存储大量的网页，并不断优化自己的搜索算法，提升搜索效率。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/5d6a6fcb993e42c28b9c0731ec316754.png" alt="在这里插入图片描述" /></p>
<p>在这个过程中，Google确实找到了不少好办法，并且无私地分享了出来。开源！</p>
<p>2003年，Google发表了一篇技术学术论文，公开介绍了自己的谷歌文件系统 <strong>GFS（Google File System）</strong>。这是Google公司为了存储海量搜索数据而设计的专用文件系统。</p>
<p>第二年，也就是2004年，Doug Cutting基于Google的GFS论文，实现了<strong>分布式文件存储系统</strong>，并将它命名为<strong>NDFS（Nutch Distributed File System）</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b4b2bec3cf7d4f5da174e6dcb4989e96.png" alt="在这里插入图片描述" /></p>
<p>还是2004年，Google又发表了一篇技术学术论文，介绍自己的<strong>MapReduce编程模型</strong>。这个编程模型，用于大规模数据集（大于1TB）的并行分析运算。</p>
<p>第二年（2005年），Doug Cutting又基于MapReduce，在Nutch搜索引擎实现了该功能。</p>
<p><img data-src="https://img-blog.csdnimg.cn/e9ef4a81286b420abf38fb4aacd778d6.png" alt="在这里插入图片描述" /></p>
<p>2006年，当时依然很厉害的<strong>Yahoo（雅虎）公司</strong>，招安了Doug Cutting。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/09db6bd51dbc4f26b53976bcd4de8204.png" alt="在这里插入图片描述" /></p>
<p>这里要补充说明一下雅虎招安Doug的背景：2004年之前，作为互联网开拓者的雅虎，是使用Google搜索引擎作为自家搜索服务的。在2004年开始，雅虎放弃了Google，开始自己研发搜索引擎。所以。。。</p>
<p>加盟Yahoo之后，Doug Cutting将NDFS和MapReduce进行了升级改造，并重新命名为Hadoop（NDFS也改名为HDFS，Hadoop Distributed File System）。</p>
<p>这个，就是后来大名鼎鼎的大数据框架系统——Hadoop的由来。而Doug Cutting，则被人们称为Hadoop之父。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e5604e49d5664c5c86dfb83f9aea7ee6.png" alt="在这里插入图片描述" /></p>
<p>Hadoop这个名字，实际上是Doug Cutting他儿子的黄色玩具大象的名字。所以，Hadoop的Logo，就是一只奔跑的黄色大象。</p>
<p><img data-src="https://img-blog.csdnimg.cn/a1dd755b734c4411bb96130a60268369.png" alt="在这里插入图片描述" /></p>
<p>我们继续往下说。</p>
<p>还是2006年，Google又发论文了。</p>
<p>这次，它们介绍了自己的<strong>BigTable</strong>。这是一种分布式数据存储系统，一种用来处理海量数据的非关系型数据库。</p>
<p>Doug Cutting当然没有放过，在自己的hadoop系统里面，引入了BigTable，并命名为<strong>HBase</strong>。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/6f813d03dca6447eaa987f841934e4e1.png" alt="在这里插入图片描述" /></p>
<p>好吧，反正就是紧跟Google时代步伐，你出什么，我学什么。</p>
<p>所以，Hadoop的核心部分，基本上都有Google的影子。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9fca1eefc8b9472ea705582dd7093a7a.png" alt="在这里插入图片描述" /></p>
<p>2008年1月，Hadoop成功上位，正式成为Apache基金会的顶级项目。</p>
<p>同年2月，Yahoo宣布建成了一个拥有1万个内核的Hadoop集群，并将自己的搜索引擎产品部署在上面。</p>
<p>7月，Hadoop打破世界纪录，成为最快排序1TB数据的系统，用时209秒。</p>
<p><strong>回到主题</strong></p>
<p>在学习ElasticSearch之前，先简单了解一下Lucene：</p>
<ul>
<li>
<p>Doug Cutting开发</p>
</li>
<li>
<p>是apache软件基金会4 jakarta项目组的一个子项目</p>
</li>
<li>
<p>是一个开放源代码的全文检索引擎工具包</p>
</li>
<li>
<p>不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）</p>
</li>
<li>
<p>当前以及最近几年最受欢迎的免费Java信息检索程序库。</p>
</li>
</ul>
<p><strong>Lucene和ElasticSearch的关系：</strong></p>
<ul>
<li>ElasticSearch是基于Lucene 做了一下封装和增强</li>
</ul>
<h2 id="yi-elastic-search-gai-shu" id="一、ElasticSearch概述">一、ElasticSearch概述</h2>
<p>Elaticsearch，简称为es，es是一个开源的高扩展的<mark>分布式全文检索引擎</mark>，它可以近乎<mark>实时的存储、检索数据</mark>;本身扩展性很好，可以扩展到上百台服务器，处理PB级别(大数据时代）的数据。es也使用java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是 通过简单的<mark>RESTful API</mark>来隐藏Lucene的复杂性，从而让全文搜索变得简单 。</p>
<p>据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月，ElasticSearch已超过Solr等，成为排名第一的搜索引擎类应用。</p>
<p><strong>历史</strong></p>
<p>多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。</p>
<p>直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便lava程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。</p>
<p>后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做<mark>Elasticsearch</mark>。</p>
<p>第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。</p>
<p>Shay的妻子依旧等待着她的食谱搜索……</p>
<p><strong>谁在使用：</strong></p>
<p>1、维基百科，类似百度百科，全文检索，高亮，搜索推荐/2（权重，百度！）</p>
<p>2、The Guardian (国外新闻网站) ，类似搜狐新闻，用户行为日志(点击，浏览，收藏，评论) +社交网络数据(对某某新闻的相关看法) ，数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈(好，坏，热门，垃圾，鄙视，崇拜)</p>
<p>3、Stack Overflow (国外的程序异常讨论论坛) ，，IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</p>
<p>4、GitHub (开源代码管理)，搜索 上千亿行代码</p>
<p>5、电商网站，检索商品</p>
<p>6、日志数据分析，logstash采集日志，ES进行复杂的数据分析，<mark>ELK技术，elasticsearch+logstash+kibana</mark></p>
<p>7、商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</p>
<p>8、BI系统，商业智能， Business Intelligence。比如说有个大型商场集团，BI ，分析一下某某区域最近3年的用户消费 金额的趋势以及用户群体的组成构成，产出相关的数张报表， **区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘， Kibana进行数据可视化</p>
<p>9、国内:站内搜索(电商，招聘，门户，等等)，IT系统搜索(OA，CRM，ERP，等等)，数据分析(ES热门的一一个使用场景)</p>
<p>ES和 solr 的差别</p>
<h3 id="1-elastic-search-jian-jie" id="1、ElasticSearch简介">1、ElasticSearch简介</h3>
<p>Elasticsearch是一个实时分布式搜索和分析引擎。 它让你以前所未有的速度处理大数据成为可能。</p>
<p>它用于 <strong>全文搜索</strong>、<strong>结构化搜索</strong>、<strong>分析</strong>以及将这三者混合使用:</p>
<p>维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。</p>
<p>英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。</p>
<p>StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。</p>
<p>Github使用Elasticsearch检索1300亿行的代码。</p>
<p>但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。</p>
<p>Elasticsearch可以在你的笔记本上运行，也可以在数以百计的服务器上处理PB级别的数据。</p>
<p>Elasticsearch是一个基于Apache Lucene™的开源搜索引擎。无论在开源还是专有领域， Lucene可被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>
<p>但是， Lucene只是一个库。 想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是， Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p>
<p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h3 id="2-solr-jian-jie" id="2、Solr简介">2、Solr简介</h3>
<p>Solr是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p>
<p>Solr可以独立运行，运行在letty. Tomcat等这些Selrvlet容器中 ， Solr 索引的实现方法很简单，<mark>用POST方法向Solr服务器发送一个描述Field及其内容的XML文档， Solr根据xml文档添加、删除、更新索引</mark>。Solr 搜索只需要发送HTTP GET请求，然后对Solr返回xml、<mark>json</mark>等格式的查询结果进行解析，组织页面布局。</p>
<p>Solr不提供构建UI的功能， Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。</p>
<p>solr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene.</p>
<p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交-定格式的文件，生成索引;也可以通过提出查找请求，并得到返回结果。</p>
<h3 id="3-lucene-jian-jie" id="3、Lucene简介">3、Lucene简介</h3>
<p>Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言)。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</p>
<p>Lucene是一个全文检索引擎的架构。那什么是全文搜索引擎?</p>
<p>全文搜索引擎是名副其实的搜索引擎，国外具代表性的有Google、Fast/AllTheWeb、AltaVista、Inktomi、Teoma、WiseNut等，国内著名的有百度(Baidu )。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主)而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。</p>
<p>从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序( Indexer )，俗称&quot;蜘蛛&quot; ( Spider )程序或&quot;机器人&quot; ( Robot )程序，并自建网页数据库，搜索结果直接从自身的数据库中调用，如上面提到的7家引擎;另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如Lycos引擎。</p>
<h3 id="4-elastic-search-yu-solr-bi-jiao" id="4、ElasticSearch与Solr比较">4、ElasticSearch与Solr比较</h3>
<ol>
<li>当单纯的对已有数据进行搜索时，Solr更快</li>
</ol>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4ed7fbf84abc493a953c6aa904b22871.png" alt="在这里插入图片描述" /></p>
<ol start="2">
<li>当实时建立索引时，Solr会产生io阻塞，查询性能较差，ElasticSearch具有明显的优势</li>
</ol>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/cd3535ed806a455690175d4f8448b70c.png" alt="在这里插入图片描述" /></p>
<ol start="3">
<li>随着数据量的增加，Solr的搜索效率会变得更低，而ElasticSearch却没有明显的变化</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/a19f9641e2a6465d880c97d87d87428e.png" alt="在这里插入图片描述" /></p>
<ol start="4">
<li>转变我们的搜索基础设施后从Solr ElasticSearch，我们看见一个即时~ 50x提高搜索性能！</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/11f760cafd204a48a4a119014b4fee8a.png" alt="加粗样式" /></p>
<p><strong>ElasticSearch vs Solr 总结</strong></p>
<p>1、es基本是开箱即用(解压就可以用!) ，非常简单。Solr安装略微复杂一丢丢!</p>
<p>2、Solr 利用Zookeeper进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能 。</p>
<p>3、Solr 支持更多格式的数据，比如JSON、XML、 CSV ，而Elasticsearch仅支持json文件格式。</p>
<p>4、Solr 官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</p>
<p>5、 Solr 查询快，但更新索引时慢(即插入删除慢) ，用于电商等查询多的应用;</p>
<ul>
<li>
<p>ES建立索引快(即查询慢) ，即实时性查询快，用于facebook新浪等搜索。</p>
</li>
<li>
<p>Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。</p>
</li>
</ul>
<p>6、Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。</p>
<h2 id="er-elastic-search-an-zhuang" id="二、ElasticSearch安装">二、ElasticSearch安装</h2>
<p>官网：<a href="https://www.elastic.co/cn/elasticsearch/">https://www.elastic.co/cn/elasticsearch/</a></p>
<p>JDK8，最低要求</p>
<p>使用Java开发，必须保证ElasticSearch的版本与Java的核心jar包版本对应！（Java环境保证没错）</p>
<p><img data-src="https://img-blog.csdnimg.cn/5ae25fde652d4503917683b50a1503f3.png" alt="在这里插入图片描述" /></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/f7b41243553a4d47b64c60f1df01e8ad.png" alt="在这里插入图片描述" /></p>
<p>下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<p>历史版本下载：<a href="https://www.elastic.co/cn/downloads/past-releases/">https://www.elastic.co/cn/downloads/past-releases/</a></p>
<p>官网下载巨慢，可以使用华为云镜像</p>
<ul>
<li>ElasticSearch: <a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D">https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D</a></li>
<li>logstash: <a href="https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D">https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D</a></li>
<li>kibana: <a href="https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D</a></li>
<li>elasticsearch-analysis-ik: <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></li>
<li>cerebro: <a href="https://github.com/lmenezes/cerebro/releases">https://github.com/lmenezes/cerebro/releases</a></li>
</ul>
<h3 id="2-1-windows-xia-an-zhuang" id="2-1、Windows下安装">2.1、Windows下安装</h3>
<p>1、解压即可（尽量将ElasticSearch相关工具放在统一目录下）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4f4c3861f146402bbd62b4639813ec76.png" alt="在这里插入图片描述" /></p>
<p>2、熟悉目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin	启动文件</span><br><span class="line">config 配置文件目录</span><br><span class="line">	1og4j2 日志配置文件</span><br><span class="line">	jvm.options java虚拟机相关的配置(默认启动占1g内存，内容不够需要自己调整)</span><br><span class="line">	elasticsearch.yml elasticsearch的配置文件! 默认9200端口!跨域!</span><br><span class="line">1ib  相关jar包</span><br><span class="line">modules 功能模块目录</span><br><span class="line">plugins 插件目录 ik分词器</span><br></pre></td></tr></table></figure>
<p>3、启动</p>
<blockquote>
<p>一定要检查自己的java环境是否配置好</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/80752baa4aa84e1e83f30409447b8cf1.png" alt="在这里插入图片描述" /></p>
<p>双击启动</p>
<blockquote>
<p>注意：如果启动后闪退，可能是文件目录有中午或者空格造成的</p>
</blockquote>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/be1942c768854ec39a36715383d4f6df.png" alt="在这里插入图片描述" /></p>
<p>访问 <a href="http://127.0.0.1:9200/">http://127.0.0.1:9200/</a></p>
<p><img data-src="https://img-blog.csdnimg.cn/2948347855074b89a0e34be5777f9a04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<h3 id="2-2-an-zhuang-ke-shi-hua-jie-mian" id="2-2、安装可视化界面">2.2、安装可视化界面</h3>
<p>elasticsearch-head</p>
<p><strong>使用前提</strong>：需要安装nodejs</p>
<p>下载地址：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b976add50915495a883b201b99596d62.png" alt="在这里插入图片描述" /></p>
<p>安装依赖 <code>npm install</code></p>
<p>运行 <code>npm start</code></p>
<p>访问 <a href="http://localhost:9100/">http://localhost:9100/</a></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/c73b892a47304fb49ded0d7fa4e5513e.png" alt="在这里插入图片描述" /></p>
<p>发现存在跨域问题</p>
<p><strong>开启跨域（在elasticsearch解压目录config下elasticsearch.yml中添加）</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启跨域</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 所有人访问</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意配置文件中不要带注释，可能会闪退</p>
<p>重启elasticsearch</p>
<p><img data-src="https://img-blog.csdnimg.cn/31104ac0c70d485fb98563ccf7eef84a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>创建一个索引</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/ce525553a4984849972493e776963f2f.png" alt="在这里插入图片描述" /></p>
<p><img data-src="https://img-blog.csdnimg.cn/666cb2e8ccfe49cfa6bf20b2c9a0f6b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://img-blog.csdnimg.cn/8485dda55a73436aabcf62feba27c0c8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://img-blog.csdnimg.cn/9b86f0d4be42419191732c9e768d21ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><strong>如何理解：</strong></p>
<ul>
<li>
<p>如果你是初学者</p>
<ul>
<li>索引 可以看做 “数据库”</li>
<li>类型 可以看做 “表”</li>
<li>文档 可以看做 “库中的数据（表中的行）”</li>
</ul>
</li>
</ul>
<p>这个head，我们只是把它当做可视化数据展示工具，之后所有的查询都在kibana中进行</p>
<ul>
<li>因为不支持json格式化，不方便</li>
</ul>
<h3 id="2-3-liao-jie-elk" id="2-3、了解ELK">2.3、了解ELK</h3>
<p>ELK是Elasticsearch、Logstash、 Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。</p>
<p>其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。</p>
<p>像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大，市面上很多时候我们简称Elasticsearch为es。</p>
<p>Logstash是ELK的中央数据流引擎，用于从不同目标(文件/数据存储/MQ )收集的不同格式数据，经过过滤后支持输出到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。</p>
<p>Kibana可以将elasticsearch的数据通过友好的页面展示出来 ，提供实时分析的功能。</p>
<p>市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称 ，但实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</p>
<p>收集清洗数据(Logstash) ==&gt; 搜索、存储(ElasticSearch) ==&gt; 展示(Kibana)</p>
<p><img data-src="https://img-blog.csdnimg.cn/c60a6816e5cb4128bce48331063dc414.png" alt="在这里插入图片描述" /></p>
<h3 id="2-4-an-zhuang-kibana" id="2-4、安装kibana">2.4、安装kibana</h3>
<p>Kibana是一个针对ElasticSearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana ，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p>
<p>官网：<a href="https://www.elastic.co/cn/kibana/">https://www.elastic.co/cn/kibana/</a></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b3a7d05d0bb4448e957947e4c856ca8d.png" alt="在这里插入图片描述" /></p>
<p>下载地址：<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a></p>
<p><img data-src="https://img-blog.csdnimg.cn/fd0844bf68a347878b69fe0c1bf9b25c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><mark>版本需要与ElasticSearch版本对应</mark></p>
<p>华为云镜像： <a href="https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D</a></p>
<p>安装</p>
<p>解压即可（尽量将ElasticSearch相关工具放在统一目录下）</p>
<p>进入到 kibana-7.14.0-windows-x86_64\bin 目录下，双击启动</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0040a6fc2f7b43dca8d70b13ad32f6c7.png" alt="在这里插入图片描述" /></p>
<p>访问 <a href="http://127.0.0.1:5601">http://127.0.0.1:5601</a></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/bd1980a003184f44b3fa2b35395d9e13.png" alt="在这里插入图片描述" /></p>
<p>开发工具</p>
<p>（Postman、curl、head、谷歌浏览器插件）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/702849eaab964d6c9c2c702610cf0815.png" alt="在这里插入图片描述" /></p>
<p>如果说，你在英文方面不太擅长，kibana是支持汉化的</p>
<p>kibana汉化</p>
<p>编辑器打开kibana解压目录/config/kibana.yml(kibana-7.13.1-windows-x86_64/config/kibana.yml)，添加</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0393d4d0fc164dc59dcfdbd209354e30.png" alt="在这里插入图片描述" /></p>
<p>重启kibana</p>
<p>汉化成功</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/784bbd78425d4dc78eab349eba69ee4d.png" alt="在这里插入图片描述" /></p>
<h2 id="san-elastic-search-he-xin-gai-nian" id="三、ElasticSearch核心概念">三、ElasticSearch核心概念</h2>
<h3 id="3-1-gai-shu" id="3-1、概述">3.1、概述</h3>
<p>集群，节点，索引，类型，文档，分片，映射是什么？</p>
<p>1、索引（ElasticSearch）</p>
<p>包多个分片</p>
<p>2、字段类型（映射）mapping</p>
<p>字段类型映射（字段是整型，还是字符型…）</p>
<p>3、文档（documents）</p>
<p>4、分片（Lucene索引，倒排索引）</p>
<p><strong>elasticsearch是面向文档，关系型数据库和elasticsearch客观的对比！一切都是json</strong>!</p>
<table>
<thead>
<tr>
<th>Relational DB</th>
<th>Elasticsearch</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库（database）</td>
<td>索引（indices）</td>
</tr>
<tr>
<td>表（tables）</td>
<td>types</td>
</tr>
<tr>
<td>行（rows）</td>
<td>documents</td>
</tr>
<tr>
<td>字段（columns）</td>
<td>fields</td>
</tr>
</tbody>
</table>
<p>elasticsearch（集群）中可以包含多个索引（数据库） ，每个索引中可以包含多个类型（表） ，每个类型下又包含多个文档（行） ，每个文档中又包含多个字段（列）。</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b4b6d49e705c431680358ecfdf601095.png" alt="在这里插入图片描述" /></p>
<p><strong>物理设计：</strong></p>
<p>elasticsearch在后台把每个索引划分成多个分片。每个分片可以在集群中的不同服务器间迁移</p>
<p>一个人就是一个集群! ，即启动的ElasticSearch服务，默认就是一个集群，且默认集群名为elasticsearch</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/f97a6ef1187f4ec0a7a78822a25f9f66.png" alt="在这里插入图片描述" /></p>
<p><strong>逻辑设计：</strong></p>
<p>一个索引类型中，包含多个文档，比如说文档1，文档2。当我们索引一篇文档时，可以通过这样的一个顺序找到它：索引-&gt;类型-&gt;文档id，通过这个组合我们就能索引到某个具体的文档。注意：ID不必是整数，实际上它是一个字符串。</p>
<h3 id="3-2-wen-dang" id="3-2、文档">3.2、文档</h3>
<p>文档（”行“）</p>
<p>就是我们的一条条的记录</p>
<p>之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档， elasticsearch中，文档有几个重要属性:</p>
<ul>
<li>自我包含， 一篇文档同时包含字段和对应的值，也就是同时包含key:value !</li>
<li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的! {就是一 个json对象! fastjson进行自动转换！}</li>
<li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li>
</ul>
<p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。</p>
<h3 id="3-3-lei-xing" id="3-3、类型">3.3、类型</h3>
<p>类型（“表”）</p>
<p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定 义称为映射，比如name映射为字符串类型。我们说文档是无模式的 ，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型， elasticsearch就开始猜，如果这个值是18 ，那么elasticsearch会认为它是整形。但是elasticsearch也可能猜不对 ，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。</p>
<h3 id="3-4-suo-yin" id="3-4、索引">3.4、索引</h3>
<p>索引（“库”）</p>
<p>就是数据库!</p>
<p>索引是映射类型的容器， elasticsearch中的索引是一个非常大的文档集合。索|存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p>
<p>物理设计:节点和分片如何工作</p>
<p><img data-src="https://img-blog.csdnimg.cn/eaa177e252e843e792de6e8144596c29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>一个集群至少有一 个节点，而一个节点就是一-个elasricsearch进程 ，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片( primary shard ，又称主分片)构成的，每一个主分片会有-一个副本( replica shard ，又称复制分片）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/ed34371596c344cbada49df3105a9edf.png" alt="在这里插入图片描述" /></p>
<p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同-个节点内，这样有利于某个节点挂掉了，数据也不至于丢失。实际上， 一个分片是- -个Lucene索引， 一个包含<mark>倒排索引</mark>的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。不过，等等，倒排索引是什么鬼?</p>
<h3 id="3-5-dao-pai-suo-yin" id="3-5、倒排索引">3.5、倒排索引</h3>
<p>elasticsearch使用的是一种称为倒排索引 |的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档，每个文档包含如下内容:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Study <span class="keyword">every</span> <span class="built_in">day</span>， good good up <span class="keyword">to</span> forever  <span class="comment"># 文档1包含的内容</span></span><br><span class="line">To forever， study <span class="keyword">every</span> <span class="built_in">day</span>，good good up  <span class="comment"># 文档2包含的内容</span></span><br></pre></td></tr></table></figure>
<p>为为创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens) ，然后创建一一个包含所有不重 复的词条的排序列表，然后列出每个词条出现在哪个文档:</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Study</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>To</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>every</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>forever</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>day</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>study</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>good</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>every</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>to</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>up</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>现在，我们试图搜索 to forever，只需要查看包含每个词条的文档</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody>
<tr>
<td>to</td>
<td>√</td>
<td>x</td>
</tr>
<tr>
<td>forever</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>total</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。</p>
<p>再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构:</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/dd3138e456594fd29935bba97a751325.png" alt="在这里插入图片描述" /></p>
<p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏，然后获取相关的文章ID即可。完全过滤掉无关的所有数据，提高效率!</p>
<p>elasticsearch的索引和Lucene的索引对比</p>
<p>在elasticsearch中，索引(库)这个词被频繁使用，这就是术语的使用。在elasticsearch中 ，索引被分为多个分片，每份分片是-个Lucene的索引。所以一个elasticsearch索引是由多 个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢!如无特指，说起索引都是指elasticsearch的索引。</p>
<p>接下来的一切操作都在kibana中Dev Tools下的Console里完成。基础操作!</p>
<h2 id="si-ik-fen-ci-qi-elasticsearch-cha-jian" id="四、IK分词器-elasticsearch插件">四、IK分词器(elasticsearch插件)</h2>
<h3 id="4-1-ik-fen-ci-qi" id="4-1、IK分词器">4.1、IK分词器</h3>
<p>中文分词器</p>
<p>分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一一个匹配操作，默认的中文分词是将每个字看成一个词（不使用用IK分词器的情况下），比如“我爱狂神”会被分为”我”，”爱”，”狂”，”神” ，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。</p>
<p>IK提供了两个分词算法: (ik_smart和ik_max_word )，其中ik_smart为最少切分，ik_max_word为最细粒度划分!</p>
<p>1、下载</p>
<p>版本要与ElasticSearch版本对应</p>
<p>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<p>2、安装</p>
<p>ik文件夹是自己创建的</p>
<p>解压放入到es对应的plugins下即可</p>
<p>3、重启观察ES，发现ik插件被加载了</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/38b1d63421ab4382b3311fcb0d3895c0.png" alt="在这里插入图片描述" /></p>
<p>4、elasticsearch-plugin 可以通过这个命令来查看加载进来的插件</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/38f19cf2eab64372a275ffabc24f48c7.png" alt="在这里插入图片描述" /></p>
<p>5、使用kibana测试</p>
<p>查看不同的分词效果</p>
<p>ik_smart：最少切分</p>
<p><img data-src="https://img-blog.csdnimg.cn/3fde229f03a1473cb51f08b432c35fc6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>ik_max_word：最细粒度划分（穷尽词库的可能）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4d73848123e84b208b4e40816b571650.png" alt="在这里插入图片描述" /></p>
<p>我们输入 超级喜欢狂神说java</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/38aea40d916f438790ab9ca400181243.png" alt="在这里插入图片描述" /></p>
<p>发现问题：狂神说被拆开了！</p>
<p>这种自己需要的词，需要自己加到我们的分词器的字典中！</p>
<p><strong>ik 分词器增加自己的配置</strong></p>
<p>添加自定义的词添加到扩展字典中</p>
<p>elasticsearch目录/plugins/ik/config/IKAnalyzer.cfg.xml</p>
<p>创建 <code>kuang.dic</code> 字典文件，添加字典内容</p>
<p><img data-src="https://img-blog.csdnimg.cn/08b073c0fb7342cb89f71cbaecf73ef9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>打开 IKAnalyzer.cfg.xml 文件，扩展字典</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/8a9feed75ad24bb78327a1330655659b.png" alt="在这里插入图片描述" /></p>
<p>重启ElasticSearch，再次使用kibana测试</p>
<p><strong>加载了自己的</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/3715bb78330f447885bb4d18e72f7726.png" alt="在这里插入图片描述" /></p>
<p><strong>测试kibana</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/ce04eb6b519d4c14a0801e2236985016.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>以后的话，我们需要自己配置分词就在自己定义的dic文件进行配置即可！</p>
<h2 id="wu-rest-feng-ge-shuo-ming" id="五、Rest风格说明">五、Rest风格说明</h2>
<p><strong>一种软件架构风格</strong>,而不是标准,只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以<strong>更简洁</strong>，<strong>更有层次</strong>，<strong>更易于实现缓存</strong>等机制。</p>
<h3 id="5-1-ji-ben-rest-ming-ling-shuo-ming" id="5-1、基本Rest命令说明：">5.1、基本Rest命令说明：</h3>
<table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUT（创建,修改）</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>创建文档（指定文档id）</td>
</tr>
<tr>
<td>POST（创建）</td>
<td>localhost:9200/索引名称/类型名称</td>
<td>创建文档（随机文档id）</td>
</tr>
<tr>
<td>POST（修改）</td>
<td>localhost:9200/索引名称/类型名称/文档id/_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE（删除）</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET（查询）</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>查询文档通过文档ID</td>
</tr>
<tr>
<td>POST（查询）</td>
<td>localhost:9200/索引名称/类型名称/文档id/_search</td>
<td>查询所有数据</td>
</tr>
</tbody>
</table>
<h3 id="5-2-guan-yu-suo-yin-de-ji-ben-cao-zuo" id="5-2、关于索引的基本操作">5.2、关于索引的基本操作</h3>
<p>1、创建一个索引，添加</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引名/~类型名~/文档id</span><br><span class="line"><span class="punctuation">&#123;</span>请求体<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test1/type1/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;流柚&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回结果</span><br><span class="line"># 警告信息： 不支持在文档索引请求中的指定类型</span><br><span class="line"># 而是使用无类型的断点(/<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span><span class="punctuation">,</span> /<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_doc<span class="punctuation">,</span> or /<span class="punctuation">&#123;</span>index<span class="punctuation">&#125;</span>/_create/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span>).</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;test1&quot;</span><span class="punctuation">,</span>	# 索引</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;type1&quot;</span><span class="punctuation">,</span>	# 类型（已经废弃）</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span>			# id</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>		# 版本</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;created&quot;</span><span class="punctuation">,</span>	# 操作类型</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span>			# 分片信息</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>完成了自动增加索引！数据也成功的添加了，这就是我说大家在初期可以把它当做数据库学习的原因！</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/a1662e1682294fe8931f6c8f4b687389.png" alt="在这里插入图片描述" /></p>
<p>2、字段数据类型</p>
<ul>
<li>
<p>字符串类型</p>
<p>text、keyword</p>
<ul>
<li>text：支持分词，全文检索,支持模糊、精确查询,不支持聚合,排序操作;text类型的最大支持的字符长度无限制,适合大字段存储；</li>
<li>keyword：不进行分词，直接索引、支持模糊、支持精确匹配，支持聚合、排序操作。keyword类型的最大支持的长度为——32766个UTF-8类型的字符,可以通过设置ignore_above指定自持字符长度，超过给定长度后的数据将不被索引，无法通过term精确匹配检索返回结果。</li>
</ul>
</li>
<li>
<p>数值型</p>
<p>long、Integer、short、byte、double、float、half float、scaled float</p>
</li>
<li>
<p>日期类型</p>
<p>date</p>
</li>
<li>
<p>te布尔类型</p>
<p>boolean</p>
</li>
<li>
<p>二进制类型</p>
<p>binary</p>
<p>等等…</p>
</li>
</ul>
<p>3、指定字段的类型（使用PUT）</p>
<p>创建规则 类似于建库（建立索引和字段对应类型），也可看做规则的建立</p>
<p><img data-src="https://img-blog.csdnimg.cn/970cd3944d8549fe883ce0e12b4c71f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>4、获取规则</p>
<p>可以通过 GET 请求获取具体的信息</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9ce725800ca3465a8c34ffccd7d8bd2b.png" alt="在这里插入图片描述" /></p>
<p>5、查看默认信息</p>
<p><code>_doc</code> 默认类型（default type），type 在未来的版本中会逐渐弃用，因此产生一个默认类型进行代替</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4da91cb2d5df42bebac4fcb58f8b99f4.png" alt="在这里插入图片描述" /></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/19a9e6e92488420e83d34d77502d0472.png" alt="在这里插入图片描述" /></p>
<p>如果自己的文档字段没有指定，那么es就会给我们默认配置字段类型！</p>
<p>扩展：通过命令 elasticsearch索引情况！通过<code>get _cat/</code> 可以获取ElasticSearch的当前的很多信息！</p>
<p><img data-src="https://img-blog.csdnimg.cn/981f1f82ba0244c8a063cca8ac0c5939.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/c63b3977ea4c4f4999c6582f8c8aba04.png" alt="在这里插入图片描述" /></p>
<p>6、修改</p>
<p>两种方案</p>
<p>旧的（使用put覆盖原来的值）</p>
<p>版本+1（_version）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/a51c87dd6df847a4a1f5d477ddecebc6.png" alt="在这里插入图片描述" /></p>
<p>但是如果漏掉某个字段没有写，那么更新是没有写的字段 ，会消失</p>
<p>新的（使用post的update）</p>
<p><img data-src="https://img-blog.csdnimg.cn/d09be475ac2042079ba2c630ecd8c595.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>version不会改变</p>
<p>需要注意doc</p>
<p>不会丢失字段</p>
<p>7、删除</p>
<p>通过DELETE 命令实现删除，根据你的请求来判断是删除索引还是删除文档记录！</p>
<p>使用RESTFUL 风格是我们ES推荐大家使用的！</p>
<h3 id="5-3-guan-yu-wen-dang-de-ji-ben-cao-zuo-zhong-dian" id="5-3、关于文档的基本操作（重点）">5.3、关于文档的基本操作（重点）</h3>
<h4 id="ji-ben-cao-zuo" id="基本操作">基本操作</h4>
<p>1、添加数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kuangshen/user/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;狂神说&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一顿操作猛如虎，一看工资2500&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;运动&quot;</span><span class="punctuation">,</span><span class="string">&quot;阳光&quot;</span><span class="punctuation">,</span><span class="string">&quot;直男&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/8dfa5df40a8b452eb658ed6ea52939ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kuangshen/user/<span class="number">2</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;法外狂徒&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;运动&quot;</span><span class="punctuation">,</span><span class="string">&quot;旅游&quot;</span><span class="punctuation">,</span><span class="string">&quot;渣男&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /kuangshen/user/<span class="number">3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mmp,不知道 如何形容&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;靓仔&quot;</span><span class="punctuation">,</span><span class="string">&quot;旅游&quot;</span><span class="punctuation">,</span><span class="string">&quot;唱歌&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>2、获取数据 GET</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0e50324e7c9d4073befc3e9c5b839f60.png" alt="在这里插入图片描述" /></p>
<p>3、更新数据 PUT</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /kuangshen/user/<span class="number">3</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四233&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mmp,不知道 如何形容&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;靓仔&quot;</span><span class="punctuation">,</span><span class="string">&quot;旅游&quot;</span><span class="punctuation">,</span><span class="string">&quot;唱歌&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e5007de387844be5bfce42147f181e11.png" alt="在这里插入图片描述" /></p>
<p>4、Post  _update，推荐使用这种更新方式！</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/9e051316013f400891b1ffd5d4473408.png" alt="在这里插入图片描述" /></p>
<p>简单的搜索</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET kuangshen/user/<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>简单的条件查询，可以根据默认的映射规则，产生基本的查询！</p>
<p><img data-src="https://img-blog.csdnimg.cn/0b0ea5fffae64c5099fc021f1924b7af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>这边name是text 所以做了分词的查询 如果是keyword就不会分词搜索了</p>
<h4 id="fu-za-cao-zuo" id="复杂操作">复杂操作</h4>
<p>复杂操作搜索 select（排序，分页，高亮，模糊查询，精准查询）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/a20e749f1863490d89cd3746c954a9de.png" alt="在这里插入图片描述" /></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试只能一个字段查询</span></span><br><span class="line">GET lisen/user/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李森&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出结果，不想要那么多，只展示列表中某些字段</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/b7907b445a9a47598675e271890f7263.png" alt="在这里插入图片描述" /></p>
<p>我们之后使用java操作es，所有的方法和对象就是这里面的key</p>
<p><strong>排序</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/583539109f444b15a44de8ef0a527751.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><strong>分页</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/0ffa8f13a2d04d1c874e4cdf42b1168f.png" alt="在这里插入图片描述" /></p>
<p>数据下标还是从0开始的，和学的所有数据结构是一样的！</p>
<p><strong>多条件查询</strong></p>
<p>布尔值查询</p>
<p>must（and），所有的条件都要符合 where id=1 and name = xxx</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/3589fc9a7b7b48c79c8493997be7adbe.png" alt="在这里插入图片描述" /></p>
<p>should（or），所有的条件都要符合  where id=1 or name = xxx</p>
<p><img data-src="https://img-blog.csdnimg.cn/721a2b681384440ea87daee668eea7eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>must_not（not）</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/4ac6b16f0a7d4b2687e35c2f7cc03fad.png" alt="在这里插入图片描述" /></p>
<p><strong>过滤器 filter</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/23a68a449b51445eba3a88e9b30eb97a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<ul>
<li>gt 大于</li>
<li>gte 大于等于</li>
<li>lte 小于</li>
<li>lte 小于等于</li>
</ul>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e8bc04cc80a94c1589c21d522fdcae76.png" alt="在这里插入图片描述" /></p>
<p><strong>匹配多个条件（数组）</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/5c36c5aa99f64a5f86839e2982870c30.png" alt="在这里插入图片描述" /></p>
<p><strong>精确查询</strong></p>
<p>term查询是直接通过倒排索引指定的词条进程精确查找的</p>
<p>关于分词</p>
<ul>
<li>term，直接查询精确的</li>
<li>match，会使用分词器解析！（先分析文档，然后通过分析的文档进行查询）</li>
</ul>
<p>两个类型 text  keyword</p>
<p><img data-src="https://img-blog.csdnimg.cn/e30c975c422e4312ba98abfda5987aaa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://img-blog.csdnimg.cn/8cbfcbf35fb74cedb63a91c05298229f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/3de24b19e77441c39c6b2eaf1df58f6f.png" alt="在这里插入图片描述" /></p>
<p><strong>多个值匹配精确查询</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/f5fc6c7a9b794c829fa48d56bfd81f96.png" alt="在这里插入图片描述" /></p>
<p><strong>高亮</strong></p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/6bbe3eee045a44b9ab52097aedd27964.png" alt="在这里插入图片描述" /></p>
<p>还能自定义高亮的样式</p>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/1b8f05ec014343a2b6e85a0564dbe4b5.png" alt="在这里插入图片描述" /></p>
<p>这些mysql也能做，只是效率比较低</p>
<ul>
<li>匹配</li>
<li>按条件匹配</li>
<li>精确匹配</li>
<li>区间范围匹配</li>
<li>匹配字段过滤</li>
<li>多条件查询</li>
<li>高亮查询</li>
</ul>
<h2 id="liu-springboot-ji-cheng" id="六、Springboot集成">六、Springboot集成</h2>
<p>找官方文档</p>
<p><img data-src="https://img-blog.csdnimg.cn/03a46f66dbe7480182fcc45536f8b3e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://img-blog.csdnimg.cn/19b99197625040c28a2f44f26feaa791.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p><img data-src="https://img-blog.csdnimg.cn/e186b75d68d14b41b62f8fa0e444e333.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<h3 id="6-1-dao-ru-yi-lai" id="6-1、导入依赖">6.1、导入依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意下spring-boot的parent包内的依赖的es的版本是不是你对应的版本</p>
<p>不是的话就在pom文件下写个properties的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这边配置下自己对应的版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.14.0<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-zhao-dui-xiang" id="6-2、找对象">6.2、找对象</h3>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/e3d293ae07494d09a4cec0c2fe18e7db.png" alt="在这里插入图片描述" /></p>
<h3 id="6-3-fen-xi-zhe-ge-lei-zhong-de-fang-fa" id="6-3、分析这个类中的方法">6.3、分析这个类中的方法</h3>
<p>配置基本的项目</p>
<p>一定要保证我们导入的依赖和我们本地的es版本一致</p>
<p><img data-src="https://img-blog.csdnimg.cn/b0876b20083740afa52422eabb14462d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6b6Z5a6HXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p>
<p>新建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、找对象</span></span><br><span class="line"><span class="comment">// 2、放到spring中待用</span></span><br><span class="line"><span class="comment">// 3、如果是springboot 就先分析源码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticSearchClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">            RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://mynotepicture.oss-cn-hangzhou.aliyuncs.com/img/5ffde15a8f0a4ca0a59a72508654579b.png" alt="在这里插入图片描述" /></p>
<p>虽然这里导入了3个类，都是静态内部类，核心类就一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.elasticsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.auth.AuthScope;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.auth.Credentials;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.auth.UsernamePasswordCredentials;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig.Builder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.BasicCredentialsProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.nio.client.HttpAsyncClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.PropertyMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RestHighLevelClient.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;RestClient.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ElasticsearchRestClientProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchRestClientAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElasticsearchRestClientAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PropertiesCredentialsProvider</span> <span class="keyword">extends</span> <span class="title class_">BasicCredentialsProvider</span> &#123;</span><br><span class="line">        PropertiesCredentialsProvider(ElasticsearchRestClientProperties properties) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(properties.getUsername())) &#123;</span><br><span class="line">                <span class="type">Credentials</span> <span class="variable">credentials</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(properties.getUsername(), properties.getPassword());</span><br><span class="line">                <span class="built_in">this</span>.setCredentials(AuthScope.ANY, credentials);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.getUris().stream().map(<span class="built_in">this</span>::toUri).filter(<span class="built_in">this</span>::hasUserInfo).forEach(<span class="built_in">this</span>::addUserInfoCredentials);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URI <span class="title function_">toUri</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> URI.create(uri);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasUserInfo</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> uri != <span class="literal">null</span> &amp;&amp; StringUtils.hasLength(uri.getUserInfo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addUserInfoCredentials</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">            <span class="type">AuthScope</span> <span class="variable">authScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthScope</span>(uri.getHost(), uri.getPort());</span><br><span class="line">            <span class="type">Credentials</span> <span class="variable">credentials</span> <span class="operator">=</span> <span class="built_in">this</span>.createUserInfoCredentials(uri.getUserInfo());</span><br><span class="line">            <span class="built_in">this</span>.setCredentials(authScope, credentials);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Credentials <span class="title function_">createUserInfoCredentials</span><span class="params">(String userInfo)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">delimiter</span> <span class="operator">=</span> userInfo.indexOf(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (delimiter == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(userInfo, (String)<span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> userInfo.substring(<span class="number">0</span>, delimiter);</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> userInfo.substring(delimiter + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordCredentials</span>(username, password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultRestClientBuilderCustomizer</span> <span class="keyword">implements</span> <span class="title class_">RestClientBuilderCustomizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PropertyMapper</span> <span class="variable">map</span> <span class="operator">=</span> PropertyMapper.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchRestClientProperties properties;</span><br><span class="line"></span><br><span class="line">        DefaultRestClientBuilderCustomizer(ElasticsearchRestClientProperties properties) &#123;</span><br><span class="line">            <span class="built_in">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(RestClientBuilder builder)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(HttpAsyncClientBuilder builder)</span> &#123;</span><br><span class="line">            builder.setDefaultCredentialsProvider(<span class="keyword">new</span> <span class="title class_">ElasticsearchRestClientAutoConfiguration</span>.PropertiesCredentialsProvider(<span class="built_in">this</span>.properties));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">            <span class="type">PropertyMapper</span> <span class="variable">var10000</span> <span class="operator">=</span> map;</span><br><span class="line">            <span class="type">ElasticsearchRestClientProperties</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.properties;</span><br><span class="line">            var10001.getClass();</span><br><span class="line">            var10000.from(var10001::getConnectionTimeout).whenNonNull().asInt(Duration::toMillis).to(builder::setConnectTimeout);</span><br><span class="line">            var10000 = map;</span><br><span class="line">            var10001 = <span class="built_in">this</span>.properties;</span><br><span class="line">            var10001.getClass();</span><br><span class="line">            var10000.from(var10001::getReadTimeout).whenNonNull().asInt(Duration::toMillis).to(builder::setSocketTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">        proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;RestHighLevelClient.class&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RestHighLevelClientConfiguration</span> &#123;</span><br><span class="line">        RestHighLevelClientConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RestHighLevelClient 高级客户端，也是我们这里要讲，后面项目会用到客户端</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        RestHighLevelClient <span class="title function_">elasticsearchRestHighLevelClient</span><span class="params">(RestClientBuilder restClientBuilder)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(restClientBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">        proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;RestClientBuilder.class&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RestClientBuilderConfiguration</span> &#123;</span><br><span class="line">        RestClientBuilderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        RestClientBuilderCustomizer <span class="title function_">defaultRestClientBuilderCustomizer</span><span class="params">(ElasticsearchRestClientProperties properties)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchRestClientAutoConfiguration</span>.DefaultRestClientBuilderCustomizer(properties);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RestClientBuilder</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        RestClientBuilder <span class="title function_">elasticsearchRestClientBuilder</span><span class="params">(ElasticsearchRestClientProperties properties, ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers)</span> &#123;</span><br><span class="line">            HttpHost[] hosts = (HttpHost[])properties.getUris().stream().map(<span class="built_in">this</span>::createHttpHost).toArray((x$<span class="number">0</span>) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>[x$<span class="number">0</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">RestClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RestClient.builder(hosts);</span><br><span class="line">            builder.setHttpClientConfigCallback((httpClientBuilder) -&gt; &#123;</span><br><span class="line">                builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123;</span><br><span class="line">                    customizer.customize(httpClientBuilder);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> httpClientBuilder;</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.setRequestConfigCallback((requestConfigBuilder) -&gt; &#123;</span><br><span class="line">                builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123;</span><br><span class="line">                    customizer.customize(requestConfigBuilder);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> requestConfigBuilder;</span><br><span class="line">            &#125;);</span><br><span class="line">            builderCustomizers.orderedStream().forEach((customizer) -&gt; &#123;</span><br><span class="line">                customizer.customize(builder);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> builder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HttpHost <span class="title function_">createHttpHost</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.createHttpHost(URI.create(uri));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var3) &#123;</span><br><span class="line">                <span class="keyword">return</span> HttpHost.create(uri);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HttpHost <span class="title function_">createHttpHost</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasLength(uri.getUserInfo())) &#123;</span><br><span class="line">                <span class="keyword">return</span> HttpHost.create(uri.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> HttpHost.create((<span class="keyword">new</span> <span class="title class_">URI</span>(uri.getScheme(), (String)<span class="literal">null</span>, uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment())).toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (URISyntaxException var3) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-suo-yin-de-zeng-shan-shi-fou-cun-zai" id="6-4、索引的增、删、是否存在">6.4、索引的增、删、是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试索引的创建 request</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 1、创建索引请求</span></span><br><span class="line">   <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">   <span class="comment">// 2、客户端执行请求 indexResponse, 请求后获得相应</span></span><br><span class="line">   <span class="type">CreateIndexResponse</span> <span class="variable">createIndexResponse</span> <span class="operator">=</span> client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">   System.out.println(createIndexResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试获取索引，只能判断其是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">   System.out.println(exists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除索引</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">   <span class="type">AcknowledgedResponse</span> <span class="variable">delete</span> <span class="operator">=</span> client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">   System.out.println(delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-wen-dang-de-cao-zuo" id="6-5、文档的操作">6.5、文档的操作</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试创建文档</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;狂神说&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则 put /kuang_index/_doc/1</span></span><br><span class="line">    request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    request.timeout(TimeValue.timeValueDays(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//    request.timeout(&quot;1&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将我们的数据放入请求 json</span></span><br><span class="line">    request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端发送请求，获取响应结果</span></span><br><span class="line">    <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    System.out.println(indexResponse.toString());</span><br><span class="line">    System.out.println(indexResponse.status());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档，判断是否存在 get /index/doc/1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIsExists</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 不获取返回的 _source 的上下文了</span></span><br><span class="line">    request.fetchSourceContext(<span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">false</span>));</span><br><span class="line">    request.storedFields(<span class="string">&quot;_none_&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(getResponse.getSourceAsString()); <span class="comment">// 打印文档的内容</span></span><br><span class="line">    System.out.println(getResponse);  <span class="comment">// 返回的全部内容和命令是一样的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新文档的信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    updateRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;狂神说java&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    updateRequest.doc(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line"></span><br><span class="line">    <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(updateResponse.status());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文档记录</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">DeleteResponse</span> <span class="variable">delete</span> <span class="operator">=</span> client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.status());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量插入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;kuangshen1&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;kuangshen2&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;kuangshen3&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;qinjiang1&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;qinjiang2&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;qinjiang3&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批处理请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 批量更新和批量删除，就在这里修改对应的请求就可以了</span></span><br><span class="line">        bulkRequest.add(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;kuang_index&quot;</span>)</span><br><span class="line">            .id(<span class="string">&quot;&quot;</span> + (i + <span class="number">1</span>))</span><br><span class="line">            .source(JSON.toJSONString(list.get(i)), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(bulkResponse.hasFailures());  <span class="comment">// 是否失败,返回false代表成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="comment">// SearchRequest 搜索请求</span></span><br><span class="line"><span class="comment">// SearchSourceBuilder 条件构造</span></span><br><span class="line"><span class="comment">// HighLightBuilder 构建高亮</span></span><br><span class="line"><span class="comment">// TermQueryBuilder  精确查询</span></span><br><span class="line"><span class="comment">// MatchAllQueryBuilder</span></span><br><span class="line"><span class="comment">// xxx QueryBuilder 对应我们刚才看到的命令！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">    <span class="comment">// 构建搜索条件</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询条件，我们可以使用 QueryBuilders 工具来实现</span></span><br><span class="line">    <span class="comment">// QueryBuilders.termQuery  精确</span></span><br><span class="line">    <span class="comment">//QueryBuilders.matchAllQuery 匹配所有</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TermQueryBuilder</span> <span class="variable">termQueryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;qinjiang1&quot;</span>);</span><br><span class="line">    <span class="comment">//    MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();</span></span><br><span class="line">    sourceBuilder.query(termQueryBuilder);</span><br><span class="line">    sourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(JSON.toJSONString(searchResponse.getHits()));</span><br><span class="line">    System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SearchHit documentFields : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
</search>
